/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"

#import "UserStore.h"
#import "Types.h"
#import "Errors.h"
#import <limits.h>

#import "NoteStore.h"


@implementation EDAMNoteStoreConstants
+ (void) initialize {
}
@end

@implementation EDAMSyncState

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic currentTime;
@dynamic fullSyncBefore;
@dynamic updateCount;
@dynamic uploaded;
#endif

- (id) initWithCurrentTime: (EDAMTimestamp) currentTime fullSyncBefore: (EDAMTimestamp) fullSyncBefore updateCount: (int32_t) updateCount uploaded: (int64_t) uploaded
{
  self = [super init];
  __currentTime = currentTime;
  __currentTime_isset = YES;
  __fullSyncBefore = fullSyncBefore;
  __fullSyncBefore_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  __uploaded = uploaded;
  __uploaded_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"currentTime"])
  {
    __currentTime = [decoder decodeInt64ForKey: @"currentTime"];
    __currentTime_isset = YES;
  }
  if ([decoder containsValueForKey: @"fullSyncBefore"])
  {
    __fullSyncBefore = [decoder decodeInt64ForKey: @"fullSyncBefore"];
    __fullSyncBefore_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  if ([decoder containsValueForKey: @"uploaded"])
  {
    __uploaded = [decoder decodeInt64ForKey: @"uploaded"];
    __uploaded_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__currentTime_isset)
  {
    [encoder encodeInt64: __currentTime forKey: @"currentTime"];
  }
  if (__fullSyncBefore_isset)
  {
    [encoder encodeInt64: __fullSyncBefore forKey: @"fullSyncBefore"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
  if (__uploaded_isset)
  {
    [encoder encodeInt64: __uploaded forKey: @"uploaded"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int64_t) currentTime {
  return __currentTime;
}

- (void) setCurrentTime: (int64_t) currentTime {
  __currentTime = currentTime;
  __currentTime_isset = YES;
}

- (BOOL) currentTimeIsSet {
  return __currentTime_isset;
}

- (void) unsetCurrentTime {
  __currentTime_isset = NO;
}

- (int64_t) fullSyncBefore {
  return __fullSyncBefore;
}

- (void) setFullSyncBefore: (int64_t) fullSyncBefore {
  __fullSyncBefore = fullSyncBefore;
  __fullSyncBefore_isset = YES;
}

- (BOOL) fullSyncBeforeIsSet {
  return __fullSyncBefore_isset;
}

- (void) unsetFullSyncBefore {
  __fullSyncBefore_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (int64_t) uploaded {
  return __uploaded;
}

- (void) setUploaded: (int64_t) uploaded {
  __uploaded = uploaded;
  __uploaded_isset = YES;
}

- (BOOL) uploadedIsSet {
  return __uploaded_isset;
}

- (void) unsetUploaded {
  __uploaded_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCurrentTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setFullSyncBefore: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setUploaded: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SyncState"];
  if (__currentTime_isset) {
    [outProtocol writeFieldBeginWithName: @"currentTime" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __currentTime];
    [outProtocol writeFieldEnd];
  }
  if (__fullSyncBefore_isset) {
    [outProtocol writeFieldBeginWithName: @"fullSyncBefore" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __fullSyncBefore];
    [outProtocol writeFieldEnd];
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  if (__uploaded_isset) {
    [outProtocol writeFieldBeginWithName: @"uploaded" type: TType_I64 fieldID: 4];
    [outProtocol writeI64: __uploaded];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SyncState("];
  [ms appendString: @"currentTime:"];
  [ms appendFormat: @"%qi", __currentTime];
  [ms appendString: @",fullSyncBefore:"];
  [ms appendFormat: @"%qi", __fullSyncBefore];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @",uploaded:"];
  [ms appendFormat: @"%qi", __uploaded];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMSyncChunk

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic currentTime;
@dynamic chunkHighUSN;
@dynamic updateCount;
@dynamic notes;
@dynamic notebooks;
@dynamic tags;
@dynamic searches;
@dynamic resources;
@dynamic expungedNotes;
@dynamic expungedNotebooks;
@dynamic expungedTags;
@dynamic expungedSearches;
#endif

- (id) initWithCurrentTime: (EDAMTimestamp) currentTime chunkHighUSN: (int32_t) chunkHighUSN updateCount: (int32_t) updateCount notes: (NSArray *) notes notebooks: (NSArray *) notebooks tags: (NSArray *) tags searches: (NSArray *) searches resources: (NSArray *) resources expungedNotes: (NSArray *) expungedNotes expungedNotebooks: (NSArray *) expungedNotebooks expungedTags: (NSArray *) expungedTags expungedSearches: (NSArray *) expungedSearches
{
  self = [super init];
  __currentTime = currentTime;
  __currentTime_isset = YES;
  __chunkHighUSN = chunkHighUSN;
  __chunkHighUSN_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  __notes = [notes retain];
  __notes_isset = YES;
  __notebooks = [notebooks retain];
  __notebooks_isset = YES;
  __tags = [tags retain];
  __tags_isset = YES;
  __searches = [searches retain];
  __searches_isset = YES;
  __resources = [resources retain];
  __resources_isset = YES;
  __expungedNotes = [expungedNotes retain];
  __expungedNotes_isset = YES;
  __expungedNotebooks = [expungedNotebooks retain];
  __expungedNotebooks_isset = YES;
  __expungedTags = [expungedTags retain];
  __expungedTags_isset = YES;
  __expungedSearches = [expungedSearches retain];
  __expungedSearches_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"currentTime"])
  {
    __currentTime = [decoder decodeInt64ForKey: @"currentTime"];
    __currentTime_isset = YES;
  }
  if ([decoder containsValueForKey: @"chunkHighUSN"])
  {
    __chunkHighUSN = [decoder decodeInt32ForKey: @"chunkHighUSN"];
    __chunkHighUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebooks"])
  {
    __notebooks = [[decoder decodeObjectForKey: @"notebooks"] retain];
    __notebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"tags"])
  {
    __tags = [[decoder decodeObjectForKey: @"tags"] retain];
    __tags_isset = YES;
  }
  if ([decoder containsValueForKey: @"searches"])
  {
    __searches = [[decoder decodeObjectForKey: @"searches"] retain];
    __searches_isset = YES;
  }
  if ([decoder containsValueForKey: @"resources"])
  {
    __resources = [[decoder decodeObjectForKey: @"resources"] retain];
    __resources_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedNotes"])
  {
    __expungedNotes = [[decoder decodeObjectForKey: @"expungedNotes"] retain];
    __expungedNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedNotebooks"])
  {
    __expungedNotebooks = [[decoder decodeObjectForKey: @"expungedNotebooks"] retain];
    __expungedNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedTags"])
  {
    __expungedTags = [[decoder decodeObjectForKey: @"expungedTags"] retain];
    __expungedTags_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedSearches"])
  {
    __expungedSearches = [[decoder decodeObjectForKey: @"expungedSearches"] retain];
    __expungedSearches_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__currentTime_isset)
  {
    [encoder encodeInt64: __currentTime forKey: @"currentTime"];
  }
  if (__chunkHighUSN_isset)
  {
    [encoder encodeInt32: __chunkHighUSN forKey: @"chunkHighUSN"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__notebooks_isset)
  {
    [encoder encodeObject: __notebooks forKey: @"notebooks"];
  }
  if (__tags_isset)
  {
    [encoder encodeObject: __tags forKey: @"tags"];
  }
  if (__searches_isset)
  {
    [encoder encodeObject: __searches forKey: @"searches"];
  }
  if (__resources_isset)
  {
    [encoder encodeObject: __resources forKey: @"resources"];
  }
  if (__expungedNotes_isset)
  {
    [encoder encodeObject: __expungedNotes forKey: @"expungedNotes"];
  }
  if (__expungedNotebooks_isset)
  {
    [encoder encodeObject: __expungedNotebooks forKey: @"expungedNotebooks"];
  }
  if (__expungedTags_isset)
  {
    [encoder encodeObject: __expungedTags forKey: @"expungedTags"];
  }
  if (__expungedSearches_isset)
  {
    [encoder encodeObject: __expungedSearches forKey: @"expungedSearches"];
  }
}

- (void) dealloc
{
  [__notes release];
  [__notebooks release];
  [__tags release];
  [__searches release];
  [__resources release];
  [__expungedNotes release];
  [__expungedNotebooks release];
  [__expungedTags release];
  [__expungedSearches release];
  [super dealloc];
}

- (int64_t) currentTime {
  return __currentTime;
}

- (void) setCurrentTime: (int64_t) currentTime {
  __currentTime = currentTime;
  __currentTime_isset = YES;
}

- (BOOL) currentTimeIsSet {
  return __currentTime_isset;
}

- (void) unsetCurrentTime {
  __currentTime_isset = NO;
}

- (int32_t) chunkHighUSN {
  return __chunkHighUSN;
}

- (void) setChunkHighUSN: (int32_t) chunkHighUSN {
  __chunkHighUSN = chunkHighUSN;
  __chunkHighUSN_isset = YES;
}

- (BOOL) chunkHighUSNIsSet {
  return __chunkHighUSN_isset;
}

- (void) unsetChunkHighUSN {
  __chunkHighUSN_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (NSArray *) notes {
  return [[__notes retain] autorelease];
}

- (void) setNotes: (NSArray *) notes {
  [notes retain];
  [__notes release];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release];
  __notes = nil;
  __notes_isset = NO;
}

- (NSArray *) notebooks {
  return [[__notebooks retain] autorelease];
}

- (void) setNotebooks: (NSArray *) notebooks {
  [notebooks retain];
  [__notebooks release];
  __notebooks = notebooks;
  __notebooks_isset = YES;
}

- (BOOL) notebooksIsSet {
  return __notebooks_isset;
}

- (void) unsetNotebooks {
  [__notebooks release];
  __notebooks = nil;
  __notebooks_isset = NO;
}

- (NSArray *) tags {
  return [[__tags retain] autorelease];
}

- (void) setTags: (NSArray *) tags {
  [tags retain];
  [__tags release];
  __tags = tags;
  __tags_isset = YES;
}

- (BOOL) tagsIsSet {
  return __tags_isset;
}

- (void) unsetTags {
  [__tags release];
  __tags = nil;
  __tags_isset = NO;
}

- (NSArray *) searches {
  return [[__searches retain] autorelease];
}

- (void) setSearches: (NSArray *) searches {
  [searches retain];
  [__searches release];
  __searches = searches;
  __searches_isset = YES;
}

- (BOOL) searchesIsSet {
  return __searches_isset;
}

- (void) unsetSearches {
  [__searches release];
  __searches = nil;
  __searches_isset = NO;
}

- (NSArray *) resources {
  return [[__resources retain] autorelease];
}

- (void) setResources: (NSArray *) resources {
  [resources retain];
  [__resources release];
  __resources = resources;
  __resources_isset = YES;
}

- (BOOL) resourcesIsSet {
  return __resources_isset;
}

- (void) unsetResources {
  [__resources release];
  __resources = nil;
  __resources_isset = NO;
}

- (NSArray *) expungedNotes {
  return [[__expungedNotes retain] autorelease];
}

- (void) setExpungedNotes: (NSArray *) expungedNotes {
  [expungedNotes retain];
  [__expungedNotes release];
  __expungedNotes = expungedNotes;
  __expungedNotes_isset = YES;
}

- (BOOL) expungedNotesIsSet {
  return __expungedNotes_isset;
}

- (void) unsetExpungedNotes {
  [__expungedNotes release];
  __expungedNotes = nil;
  __expungedNotes_isset = NO;
}

- (NSArray *) expungedNotebooks {
  return [[__expungedNotebooks retain] autorelease];
}

- (void) setExpungedNotebooks: (NSArray *) expungedNotebooks {
  [expungedNotebooks retain];
  [__expungedNotebooks release];
  __expungedNotebooks = expungedNotebooks;
  __expungedNotebooks_isset = YES;
}

- (BOOL) expungedNotebooksIsSet {
  return __expungedNotebooks_isset;
}

- (void) unsetExpungedNotebooks {
  [__expungedNotebooks release];
  __expungedNotebooks = nil;
  __expungedNotebooks_isset = NO;
}

- (NSArray *) expungedTags {
  return [[__expungedTags retain] autorelease];
}

- (void) setExpungedTags: (NSArray *) expungedTags {
  [expungedTags retain];
  [__expungedTags release];
  __expungedTags = expungedTags;
  __expungedTags_isset = YES;
}

- (BOOL) expungedTagsIsSet {
  return __expungedTags_isset;
}

- (void) unsetExpungedTags {
  [__expungedTags release];
  __expungedTags = nil;
  __expungedTags_isset = NO;
}

- (NSArray *) expungedSearches {
  return [[__expungedSearches retain] autorelease];
}

- (void) setExpungedSearches: (NSArray *) expungedSearches {
  [expungedSearches retain];
  [__expungedSearches release];
  __expungedSearches = expungedSearches;
  __expungedSearches_isset = YES;
}

- (BOOL) expungedSearchesIsSet {
  return __expungedSearches_isset;
}

- (void) unsetExpungedSearches {
  [__expungedSearches release];
  __expungedSearches = nil;
  __expungedSearches_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCurrentTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setChunkHighUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            EDAMNote *_elem2 = [[EDAMNote alloc] init];
            [_elem2 read: inProtocol];
            [fieldValue addObject: _elem2];
            [_elem2 release];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size3;
          [inProtocol readListBeginReturningElementType: NULL size: &_size3];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size3];
          int _i4;
          for (_i4 = 0; _i4 < _size3; ++_i4)
          {
            EDAMNotebook *_elem5 = [[EDAMNotebook alloc] init];
            [_elem5 read: inProtocol];
            [fieldValue addObject: _elem5];
            [_elem5 release];
          }
          [inProtocol readListEnd];
          [self setNotebooks: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_LIST) {
          int _size6;
          [inProtocol readListBeginReturningElementType: NULL size: &_size6];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size6];
          int _i7;
          for (_i7 = 0; _i7 < _size6; ++_i7)
          {
            EDAMTag *_elem8 = [[EDAMTag alloc] init];
            [_elem8 read: inProtocol];
            [fieldValue addObject: _elem8];
            [_elem8 release];
          }
          [inProtocol readListEnd];
          [self setTags: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_LIST) {
          int _size9;
          [inProtocol readListBeginReturningElementType: NULL size: &_size9];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size9];
          int _i10;
          for (_i10 = 0; _i10 < _size9; ++_i10)
          {
            EDAMSavedSearch *_elem11 = [[EDAMSavedSearch alloc] init];
            [_elem11 read: inProtocol];
            [fieldValue addObject: _elem11];
            [_elem11 release];
          }
          [inProtocol readListEnd];
          [self setSearches: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_LIST) {
          int _size12;
          [inProtocol readListBeginReturningElementType: NULL size: &_size12];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size12];
          int _i13;
          for (_i13 = 0; _i13 < _size12; ++_i13)
          {
            EDAMResource *_elem14 = [[EDAMResource alloc] init];
            [_elem14 read: inProtocol];
            [fieldValue addObject: _elem14];
            [_elem14 release];
          }
          [inProtocol readListEnd];
          [self setResources: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 9:
        if (fieldType == TType_LIST) {
          int _size15;
          [inProtocol readListBeginReturningElementType: NULL size: &_size15];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size15];
          int _i16;
          for (_i16 = 0; _i16 < _size15; ++_i16)
          {
            NSString * _elem17 = [inProtocol readString];
            [fieldValue addObject: _elem17];
          }
          [inProtocol readListEnd];
          [self setExpungedNotes: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_LIST) {
          int _size18;
          [inProtocol readListBeginReturningElementType: NULL size: &_size18];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size18];
          int _i19;
          for (_i19 = 0; _i19 < _size18; ++_i19)
          {
            NSString * _elem20 = [inProtocol readString];
            [fieldValue addObject: _elem20];
          }
          [inProtocol readListEnd];
          [self setExpungedNotebooks: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_LIST) {
          int _size21;
          [inProtocol readListBeginReturningElementType: NULL size: &_size21];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size21];
          int _i22;
          for (_i22 = 0; _i22 < _size21; ++_i22)
          {
            NSString * _elem23 = [inProtocol readString];
            [fieldValue addObject: _elem23];
          }
          [inProtocol readListEnd];
          [self setExpungedTags: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_LIST) {
          int _size24;
          [inProtocol readListBeginReturningElementType: NULL size: &_size24];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size24];
          int _i25;
          for (_i25 = 0; _i25 < _size24; ++_i25)
          {
            NSString * _elem26 = [inProtocol readString];
            [fieldValue addObject: _elem26];
          }
          [inProtocol readListEnd];
          [self setExpungedSearches: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SyncChunk"];
  if (__currentTime_isset) {
    [outProtocol writeFieldBeginWithName: @"currentTime" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __currentTime];
    [outProtocol writeFieldEnd];
  }
  if (__chunkHighUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"chunkHighUSN" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __chunkHighUSN];
    [outProtocol writeFieldEnd];
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        NSUInteger i28;
        for (i28 = 0; i28 < [__notes count]; i28++)
        {
          [[__notes objectAtIndex: i28] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebooks_isset) {
    if (__notebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"notebooks" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notebooks count]];
        NSUInteger i30;
        for (i30 = 0; i30 < [__notebooks count]; i30++)
        {
          [[__notebooks objectAtIndex: i30] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__tags_isset) {
    if (__tags != nil) {
      [outProtocol writeFieldBeginWithName: @"tags" type: TType_LIST fieldID: 6];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__tags count]];
        NSUInteger i32;
        for (i32 = 0; i32 < [__tags count]; i32++)
        {
          [[__tags objectAtIndex: i32] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__searches_isset) {
    if (__searches != nil) {
      [outProtocol writeFieldBeginWithName: @"searches" type: TType_LIST fieldID: 7];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__searches count]];
        NSUInteger i34;
        for (i34 = 0; i34 < [__searches count]; i34++)
        {
          [[__searches objectAtIndex: i34] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__resources_isset) {
    if (__resources != nil) {
      [outProtocol writeFieldBeginWithName: @"resources" type: TType_LIST fieldID: 8];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__resources count]];
        NSUInteger i36;
        for (i36 = 0; i36 < [__resources count]; i36++)
        {
          [[__resources objectAtIndex: i36] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedNotes_isset) {
    if (__expungedNotes != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedNotes" type: TType_LIST fieldID: 9];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedNotes count]];
        NSUInteger i38;
        for (i38 = 0; i38 < [__expungedNotes count]; i38++)
        {
          [outProtocol writeString: [__expungedNotes objectAtIndex: i38]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedNotebooks_isset) {
    if (__expungedNotebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedNotebooks" type: TType_LIST fieldID: 10];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedNotebooks count]];
        NSUInteger i40;
        for (i40 = 0; i40 < [__expungedNotebooks count]; i40++)
        {
          [outProtocol writeString: [__expungedNotebooks objectAtIndex: i40]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedTags_isset) {
    if (__expungedTags != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedTags" type: TType_LIST fieldID: 11];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedTags count]];
        NSUInteger i42;
        for (i42 = 0; i42 < [__expungedTags count]; i42++)
        {
          [outProtocol writeString: [__expungedTags objectAtIndex: i42]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedSearches_isset) {
    if (__expungedSearches != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedSearches" type: TType_LIST fieldID: 12];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedSearches count]];
        NSUInteger i44;
        for (i44 = 0; i44 < [__expungedSearches count]; i44++)
        {
          [outProtocol writeString: [__expungedSearches objectAtIndex: i44]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SyncChunk("];
  [ms appendString: @"currentTime:"];
  [ms appendFormat: @"%qi", __currentTime];
  [ms appendString: @",chunkHighUSN:"];
  [ms appendFormat: @"%i", __chunkHighUSN];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @",notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",notebooks:"];
  [ms appendFormat: @"%@", __notebooks];
  [ms appendString: @",tags:"];
  [ms appendFormat: @"%@", __tags];
  [ms appendString: @",searches:"];
  [ms appendFormat: @"%@", __searches];
  [ms appendString: @",resources:"];
  [ms appendFormat: @"%@", __resources];
  [ms appendString: @",expungedNotes:"];
  [ms appendFormat: @"%@", __expungedNotes];
  [ms appendString: @",expungedNotebooks:"];
  [ms appendFormat: @"%@", __expungedNotebooks];
  [ms appendString: @",expungedTags:"];
  [ms appendFormat: @"%@", __expungedTags];
  [ms appendString: @",expungedSearches:"];
  [ms appendFormat: @"%@", __expungedSearches];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteFilter

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic order;
@dynamic ascending;
@dynamic words;
@dynamic notebookGuid;
@dynamic tagGuids;
@dynamic timeZone;
@dynamic inactive;
#endif

- (id) initWithOrder: (int32_t) order ascending: (BOOL) ascending words: (NSString *) words notebookGuid: (EDAMGuid) notebookGuid tagGuids: (NSArray *) tagGuids timeZone: (NSString *) timeZone inactive: (BOOL) inactive
{
  self = [super init];
  __order = order;
  __order_isset = YES;
  __ascending = ascending;
  __ascending_isset = YES;
  __words = [words retain];
  __words_isset = YES;
  __notebookGuid = [notebookGuid retain];
  __notebookGuid_isset = YES;
  __tagGuids = [tagGuids retain];
  __tagGuids_isset = YES;
  __timeZone = [timeZone retain];
  __timeZone_isset = YES;
  __inactive = inactive;
  __inactive_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"order"])
  {
    __order = [decoder decodeInt32ForKey: @"order"];
    __order_isset = YES;
  }
  if ([decoder containsValueForKey: @"ascending"])
  {
    __ascending = [decoder decodeBoolForKey: @"ascending"];
    __ascending_isset = YES;
  }
  if ([decoder containsValueForKey: @"words"])
  {
    __words = [[decoder decodeObjectForKey: @"words"] retain];
    __words_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain];
    __notebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"tagGuids"])
  {
    __tagGuids = [[decoder decodeObjectForKey: @"tagGuids"] retain];
    __tagGuids_isset = YES;
  }
  if ([decoder containsValueForKey: @"timeZone"])
  {
    __timeZone = [[decoder decodeObjectForKey: @"timeZone"] retain];
    __timeZone_isset = YES;
  }
  if ([decoder containsValueForKey: @"inactive"])
  {
    __inactive = [decoder decodeBoolForKey: @"inactive"];
    __inactive_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__order_isset)
  {
    [encoder encodeInt32: __order forKey: @"order"];
  }
  if (__ascending_isset)
  {
    [encoder encodeBool: __ascending forKey: @"ascending"];
  }
  if (__words_isset)
  {
    [encoder encodeObject: __words forKey: @"words"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
  if (__tagGuids_isset)
  {
    [encoder encodeObject: __tagGuids forKey: @"tagGuids"];
  }
  if (__timeZone_isset)
  {
    [encoder encodeObject: __timeZone forKey: @"timeZone"];
  }
  if (__inactive_isset)
  {
    [encoder encodeBool: __inactive forKey: @"inactive"];
  }
}

- (void) dealloc
{
  [__words release];
  [__notebookGuid release];
  [__tagGuids release];
  [__timeZone release];
  [super dealloc];
}

- (int32_t) order {
  return __order;
}

- (void) setOrder: (int32_t) order {
  __order = order;
  __order_isset = YES;
}

- (BOOL) orderIsSet {
  return __order_isset;
}

- (void) unsetOrder {
  __order_isset = NO;
}

- (BOOL) ascending {
  return __ascending;
}

- (void) setAscending: (BOOL) ascending {
  __ascending = ascending;
  __ascending_isset = YES;
}

- (BOOL) ascendingIsSet {
  return __ascending_isset;
}

- (void) unsetAscending {
  __ascending_isset = NO;
}

- (NSString *) words {
  return [[__words retain] autorelease];
}

- (void) setWords: (NSString *) words {
  [words retain];
  [__words release];
  __words = words;
  __words_isset = YES;
}

- (BOOL) wordsIsSet {
  return __words_isset;
}

- (void) unsetWords {
  [__words release];
  __words = nil;
  __words_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain] autorelease];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain];
  [__notebookGuid release];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (NSArray *) tagGuids {
  return [[__tagGuids retain] autorelease];
}

- (void) setTagGuids: (NSArray *) tagGuids {
  [tagGuids retain];
  [__tagGuids release];
  __tagGuids = tagGuids;
  __tagGuids_isset = YES;
}

- (BOOL) tagGuidsIsSet {
  return __tagGuids_isset;
}

- (void) unsetTagGuids {
  [__tagGuids release];
  __tagGuids = nil;
  __tagGuids_isset = NO;
}

- (NSString *) timeZone {
  return [[__timeZone retain] autorelease];
}

- (void) setTimeZone: (NSString *) timeZone {
  [timeZone retain];
  [__timeZone release];
  __timeZone = timeZone;
  __timeZone_isset = YES;
}

- (BOOL) timeZoneIsSet {
  return __timeZone_isset;
}

- (void) unsetTimeZone {
  [__timeZone release];
  __timeZone = nil;
  __timeZone_isset = NO;
}

- (BOOL) inactive {
  return __inactive;
}

- (void) setInactive: (BOOL) inactive {
  __inactive = inactive;
  __inactive_isset = YES;
}

- (BOOL) inactiveIsSet {
  return __inactive_isset;
}

- (void) unsetInactive {
  __inactive_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOrder: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setAscending: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setWords: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size45;
          [inProtocol readListBeginReturningElementType: NULL size: &_size45];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size45];
          int _i46;
          for (_i46 = 0; _i46 < _size45; ++_i46)
          {
            NSString * _elem47 = [inProtocol readString];
            [fieldValue addObject: _elem47];
          }
          [inProtocol readListEnd];
          [self setTagGuids: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTimeZone: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setInactive: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteFilter"];
  if (__order_isset) {
    [outProtocol writeFieldBeginWithName: @"order" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __order];
    [outProtocol writeFieldEnd];
  }
  if (__ascending_isset) {
    [outProtocol writeFieldBeginWithName: @"ascending" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __ascending];
    [outProtocol writeFieldEnd];
  }
  if (__words_isset) {
    if (__words != nil) {
      [outProtocol writeFieldBeginWithName: @"words" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __words];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tagGuids_isset) {
    if (__tagGuids != nil) {
      [outProtocol writeFieldBeginWithName: @"tagGuids" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__tagGuids count]];
        NSUInteger i49;
        for (i49 = 0; i49 < [__tagGuids count]; i49++)
        {
          [outProtocol writeString: [__tagGuids objectAtIndex: i49]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__timeZone_isset) {
    if (__timeZone != nil) {
      [outProtocol writeFieldBeginWithName: @"timeZone" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __timeZone];
      [outProtocol writeFieldEnd];
    }
  }
  if (__inactive_isset) {
    [outProtocol writeFieldBeginWithName: @"inactive" type: TType_BOOL fieldID: 7];
    [outProtocol writeBool: __inactive];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteFilter("];
  [ms appendString: @"order:"];
  [ms appendFormat: @"%i", __order];
  [ms appendString: @",ascending:"];
  [ms appendFormat: @"%i", __ascending];
  [ms appendString: @",words:"];
  [ms appendFormat: @"\"%@\"", __words];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @",tagGuids:"];
  [ms appendFormat: @"%@", __tagGuids];
  [ms appendString: @",timeZone:"];
  [ms appendFormat: @"\"%@\"", __timeZone];
  [ms appendString: @",inactive:"];
  [ms appendFormat: @"%i", __inactive];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteList

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic startIndex;
@dynamic totalNotes;
@dynamic notes;
@dynamic stoppedWords;
@dynamic searchedWords;
#endif

- (id) initWithStartIndex: (int32_t) startIndex totalNotes: (int32_t) totalNotes notes: (NSArray *) notes stoppedWords: (NSArray *) stoppedWords searchedWords: (NSArray *) searchedWords
{
  self = [super init];
  __startIndex = startIndex;
  __startIndex_isset = YES;
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
  __notes = [notes retain];
  __notes_isset = YES;
  __stoppedWords = [stoppedWords retain];
  __stoppedWords_isset = YES;
  __searchedWords = [searchedWords retain];
  __searchedWords_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"startIndex"])
  {
    __startIndex = [decoder decodeInt32ForKey: @"startIndex"];
    __startIndex_isset = YES;
  }
  if ([decoder containsValueForKey: @"totalNotes"])
  {
    __totalNotes = [decoder decodeInt32ForKey: @"totalNotes"];
    __totalNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"stoppedWords"])
  {
    __stoppedWords = [[decoder decodeObjectForKey: @"stoppedWords"] retain];
    __stoppedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"searchedWords"])
  {
    __searchedWords = [[decoder decodeObjectForKey: @"searchedWords"] retain];
    __searchedWords_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__startIndex_isset)
  {
    [encoder encodeInt32: __startIndex forKey: @"startIndex"];
  }
  if (__totalNotes_isset)
  {
    [encoder encodeInt32: __totalNotes forKey: @"totalNotes"];
  }
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__stoppedWords_isset)
  {
    [encoder encodeObject: __stoppedWords forKey: @"stoppedWords"];
  }
  if (__searchedWords_isset)
  {
    [encoder encodeObject: __searchedWords forKey: @"searchedWords"];
  }
}

- (void) dealloc
{
  [__notes release];
  [__stoppedWords release];
  [__searchedWords release];
  [super dealloc];
}

- (int32_t) startIndex {
  return __startIndex;
}

- (void) setStartIndex: (int32_t) startIndex {
  __startIndex = startIndex;
  __startIndex_isset = YES;
}

- (BOOL) startIndexIsSet {
  return __startIndex_isset;
}

- (void) unsetStartIndex {
  __startIndex_isset = NO;
}

- (int32_t) totalNotes {
  return __totalNotes;
}

- (void) setTotalNotes: (int32_t) totalNotes {
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
}

- (BOOL) totalNotesIsSet {
  return __totalNotes_isset;
}

- (void) unsetTotalNotes {
  __totalNotes_isset = NO;
}

- (NSArray *) notes {
  return [[__notes retain] autorelease];
}

- (void) setNotes: (NSArray *) notes {
  [notes retain];
  [__notes release];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release];
  __notes = nil;
  __notes_isset = NO;
}

- (NSArray *) stoppedWords {
  return [[__stoppedWords retain] autorelease];
}

- (void) setStoppedWords: (NSArray *) stoppedWords {
  [stoppedWords retain];
  [__stoppedWords release];
  __stoppedWords = stoppedWords;
  __stoppedWords_isset = YES;
}

- (BOOL) stoppedWordsIsSet {
  return __stoppedWords_isset;
}

- (void) unsetStoppedWords {
  [__stoppedWords release];
  __stoppedWords = nil;
  __stoppedWords_isset = NO;
}

- (NSArray *) searchedWords {
  return [[__searchedWords retain] autorelease];
}

- (void) setSearchedWords: (NSArray *) searchedWords {
  [searchedWords retain];
  [__searchedWords release];
  __searchedWords = searchedWords;
  __searchedWords_isset = YES;
}

- (BOOL) searchedWordsIsSet {
  return __searchedWords_isset;
}

- (void) unsetSearchedWords {
  [__searchedWords release];
  __searchedWords = nil;
  __searchedWords_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setStartIndex: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTotalNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size50;
          [inProtocol readListBeginReturningElementType: NULL size: &_size50];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size50];
          int _i51;
          for (_i51 = 0; _i51 < _size50; ++_i51)
          {
            EDAMNote *_elem52 = [[EDAMNote alloc] init];
            [_elem52 read: inProtocol];
            [fieldValue addObject: _elem52];
            [_elem52 release];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size53;
          [inProtocol readListBeginReturningElementType: NULL size: &_size53];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size53];
          int _i54;
          for (_i54 = 0; _i54 < _size53; ++_i54)
          {
            NSString * _elem55 = [inProtocol readString];
            [fieldValue addObject: _elem55];
          }
          [inProtocol readListEnd];
          [self setStoppedWords: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size56;
          [inProtocol readListBeginReturningElementType: NULL size: &_size56];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size56];
          int _i57;
          for (_i57 = 0; _i57 < _size56; ++_i57)
          {
            NSString * _elem58 = [inProtocol readString];
            [fieldValue addObject: _elem58];
          }
          [inProtocol readListEnd];
          [self setSearchedWords: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteList"];
  if (__startIndex_isset) {
    [outProtocol writeFieldBeginWithName: @"startIndex" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __startIndex];
    [outProtocol writeFieldEnd];
  }
  if (__totalNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"totalNotes" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __totalNotes];
    [outProtocol writeFieldEnd];
  }
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        NSUInteger i60;
        for (i60 = 0; i60 < [__notes count]; i60++)
        {
          [[__notes objectAtIndex: i60] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__stoppedWords_isset) {
    if (__stoppedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"stoppedWords" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__stoppedWords count]];
        NSUInteger i62;
        for (i62 = 0; i62 < [__stoppedWords count]; i62++)
        {
          [outProtocol writeString: [__stoppedWords objectAtIndex: i62]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__searchedWords_isset) {
    if (__searchedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"searchedWords" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__searchedWords count]];
        NSUInteger i64;
        for (i64 = 0; i64 < [__searchedWords count]; i64++)
        {
          [outProtocol writeString: [__searchedWords objectAtIndex: i64]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteList("];
  [ms appendString: @"startIndex:"];
  [ms appendFormat: @"%i", __startIndex];
  [ms appendString: @",totalNotes:"];
  [ms appendFormat: @"%i", __totalNotes];
  [ms appendString: @",notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",stoppedWords:"];
  [ms appendFormat: @"%@", __stoppedWords];
  [ms appendString: @",searchedWords:"];
  [ms appendFormat: @"%@", __searchedWords];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteCollectionCounts

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic notebookCounts;
@dynamic tagCounts;
@dynamic trashCount;
#endif

- (id) initWithNotebookCounts: (NSDictionary *) notebookCounts tagCounts: (NSDictionary *) tagCounts trashCount: (int32_t) trashCount
{
  self = [super init];
  __notebookCounts = [notebookCounts retain];
  __notebookCounts_isset = YES;
  __tagCounts = [tagCounts retain];
  __tagCounts_isset = YES;
  __trashCount = trashCount;
  __trashCount_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"notebookCounts"])
  {
    __notebookCounts = [[decoder decodeObjectForKey: @"notebookCounts"] retain];
    __notebookCounts_isset = YES;
  }
  if ([decoder containsValueForKey: @"tagCounts"])
  {
    __tagCounts = [[decoder decodeObjectForKey: @"tagCounts"] retain];
    __tagCounts_isset = YES;
  }
  if ([decoder containsValueForKey: @"trashCount"])
  {
    __trashCount = [decoder decodeInt32ForKey: @"trashCount"];
    __trashCount_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__notebookCounts_isset)
  {
    [encoder encodeObject: __notebookCounts forKey: @"notebookCounts"];
  }
  if (__tagCounts_isset)
  {
    [encoder encodeObject: __tagCounts forKey: @"tagCounts"];
  }
  if (__trashCount_isset)
  {
    [encoder encodeInt32: __trashCount forKey: @"trashCount"];
  }
}

- (void) dealloc
{
  [__notebookCounts release];
  [__tagCounts release];
  [super dealloc];
}

- (NSDictionary *) notebookCounts {
  return [[__notebookCounts retain] autorelease];
}

- (void) setNotebookCounts: (NSDictionary *) notebookCounts {
  [notebookCounts retain];
  [__notebookCounts release];
  __notebookCounts = notebookCounts;
  __notebookCounts_isset = YES;
}

- (BOOL) notebookCountsIsSet {
  return __notebookCounts_isset;
}

- (void) unsetNotebookCounts {
  [__notebookCounts release];
  __notebookCounts = nil;
  __notebookCounts_isset = NO;
}

- (NSDictionary *) tagCounts {
  return [[__tagCounts retain] autorelease];
}

- (void) setTagCounts: (NSDictionary *) tagCounts {
  [tagCounts retain];
  [__tagCounts release];
  __tagCounts = tagCounts;
  __tagCounts_isset = YES;
}

- (BOOL) tagCountsIsSet {
  return __tagCounts_isset;
}

- (void) unsetTagCounts {
  [__tagCounts release];
  __tagCounts = nil;
  __tagCounts_isset = NO;
}

- (int32_t) trashCount {
  return __trashCount;
}

- (void) setTrashCount: (int32_t) trashCount {
  __trashCount = trashCount;
  __trashCount_isset = YES;
}

- (BOOL) trashCountIsSet {
  return __trashCount_isset;
}

- (void) unsetTrashCount {
  __trashCount_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_MAP) {
          int _size65;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size65];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size65];
          int _i66;
          for (_i66 = 0; _i66 < _size65; ++_i66)
          {
            NSString * _key67 = [inProtocol readString];
            int32_t _val68 = [inProtocol readI32];
            [fieldValue setObject: [NSNumber numberWithLong: _val68] forKey: _key67];
          }
          [inProtocol readMapEnd];
          [self setNotebookCounts: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_MAP) {
          int _size69;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size69];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size69];
          int _i70;
          for (_i70 = 0; _i70 < _size69; ++_i70)
          {
            NSString * _key71 = [inProtocol readString];
            int32_t _val72 = [inProtocol readI32];
            [fieldValue setObject: [NSNumber numberWithLong: _val72] forKey: _key71];
          }
          [inProtocol readMapEnd];
          [self setTagCounts: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTrashCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteCollectionCounts"];
  if (__notebookCounts_isset) {
    if (__notebookCounts != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookCounts" type: TType_MAP fieldID: 1];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_I32 size: [__notebookCounts count]];
        NSEnumerator * _iter73 = [__notebookCounts keyEnumerator];
        id key74;
        while ((key74 = [_iter73 nextObject]))
        {
          [outProtocol writeString: key74];
          [outProtocol writeI32: [[__notebookCounts objectForKey: key74] longValue]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__tagCounts_isset) {
    if (__tagCounts != nil) {
      [outProtocol writeFieldBeginWithName: @"tagCounts" type: TType_MAP fieldID: 2];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_I32 size: [__tagCounts count]];
        NSEnumerator * _iter75 = [__tagCounts keyEnumerator];
        id key76;
        while ((key76 = [_iter75 nextObject]))
        {
          [outProtocol writeString: key76];
          [outProtocol writeI32: [[__tagCounts objectForKey: key76] longValue]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__trashCount_isset) {
    [outProtocol writeFieldBeginWithName: @"trashCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __trashCount];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteCollectionCounts("];
  [ms appendString: @"notebookCounts:"];
  [ms appendFormat: @"%@", __notebookCounts];
  [ms appendString: @",tagCounts:"];
  [ms appendFormat: @"%@", __tagCounts];
  [ms appendString: @",trashCount:"];
  [ms appendFormat: @"%i", __trashCount];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMAdImpressions

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic adId;
@dynamic impressionCount;
@dynamic impressionTime;
#endif

- (id) initWithAdId: (int32_t) adId impressionCount: (int32_t) impressionCount impressionTime: (int32_t) impressionTime
{
  self = [super init];
  __adId = adId;
  __adId_isset = YES;
  __impressionCount = impressionCount;
  __impressionCount_isset = YES;
  __impressionTime = impressionTime;
  __impressionTime_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"adId"])
  {
    __adId = [decoder decodeInt32ForKey: @"adId"];
    __adId_isset = YES;
  }
  if ([decoder containsValueForKey: @"impressionCount"])
  {
    __impressionCount = [decoder decodeInt32ForKey: @"impressionCount"];
    __impressionCount_isset = YES;
  }
  if ([decoder containsValueForKey: @"impressionTime"])
  {
    __impressionTime = [decoder decodeInt32ForKey: @"impressionTime"];
    __impressionTime_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__adId_isset)
  {
    [encoder encodeInt32: __adId forKey: @"adId"];
  }
  if (__impressionCount_isset)
  {
    [encoder encodeInt32: __impressionCount forKey: @"impressionCount"];
  }
  if (__impressionTime_isset)
  {
    [encoder encodeInt32: __impressionTime forKey: @"impressionTime"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) adId {
  return __adId;
}

- (void) setAdId: (int32_t) adId {
  __adId = adId;
  __adId_isset = YES;
}

- (BOOL) adIdIsSet {
  return __adId_isset;
}

- (void) unsetAdId {
  __adId_isset = NO;
}

- (int32_t) impressionCount {
  return __impressionCount;
}

- (void) setImpressionCount: (int32_t) impressionCount {
  __impressionCount = impressionCount;
  __impressionCount_isset = YES;
}

- (BOOL) impressionCountIsSet {
  return __impressionCount_isset;
}

- (void) unsetImpressionCount {
  __impressionCount_isset = NO;
}

- (int32_t) impressionTime {
  return __impressionTime;
}

- (void) setImpressionTime: (int32_t) impressionTime {
  __impressionTime = impressionTime;
  __impressionTime_isset = YES;
}

- (BOOL) impressionTimeIsSet {
  return __impressionTime_isset;
}

- (void) unsetImpressionTime {
  __impressionTime_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAdId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setImpressionCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setImpressionTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AdImpressions"];
  if (__adId_isset) {
    [outProtocol writeFieldBeginWithName: @"adId" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __adId];
    [outProtocol writeFieldEnd];
  }
  if (__impressionCount_isset) {
    [outProtocol writeFieldBeginWithName: @"impressionCount" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __impressionCount];
    [outProtocol writeFieldEnd];
  }
  if (__impressionTime_isset) {
    [outProtocol writeFieldBeginWithName: @"impressionTime" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __impressionTime];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AdImpressions("];
  [ms appendString: @"adId:"];
  [ms appendFormat: @"%i", __adId];
  [ms appendString: @",impressionCount:"];
  [ms appendFormat: @"%i", __impressionCount];
  [ms appendString: @",impressionTime:"];
  [ms appendFormat: @"%i", __impressionTime];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMAdParameters

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic clientLanguage;
@dynamic impressions;
@dynamic supportHtml;
@dynamic clientProperties;
#endif

- (id) initWithClientLanguage: (NSString *) clientLanguage impressions: (NSArray *) impressions supportHtml: (BOOL) supportHtml clientProperties: (NSDictionary *) clientProperties
{
  self = [super init];
  __clientLanguage = [clientLanguage retain];
  __clientLanguage_isset = YES;
  __impressions = [impressions retain];
  __impressions_isset = YES;
  __supportHtml = supportHtml;
  __supportHtml_isset = YES;
  __clientProperties = [clientProperties retain];
  __clientProperties_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"clientLanguage"])
  {
    __clientLanguage = [[decoder decodeObjectForKey: @"clientLanguage"] retain];
    __clientLanguage_isset = YES;
  }
  if ([decoder containsValueForKey: @"impressions"])
  {
    __impressions = [[decoder decodeObjectForKey: @"impressions"] retain];
    __impressions_isset = YES;
  }
  if ([decoder containsValueForKey: @"supportHtml"])
  {
    __supportHtml = [decoder decodeBoolForKey: @"supportHtml"];
    __supportHtml_isset = YES;
  }
  if ([decoder containsValueForKey: @"clientProperties"])
  {
    __clientProperties = [[decoder decodeObjectForKey: @"clientProperties"] retain];
    __clientProperties_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__clientLanguage_isset)
  {
    [encoder encodeObject: __clientLanguage forKey: @"clientLanguage"];
  }
  if (__impressions_isset)
  {
    [encoder encodeObject: __impressions forKey: @"impressions"];
  }
  if (__supportHtml_isset)
  {
    [encoder encodeBool: __supportHtml forKey: @"supportHtml"];
  }
  if (__clientProperties_isset)
  {
    [encoder encodeObject: __clientProperties forKey: @"clientProperties"];
  }
}

- (void) dealloc
{
  [__clientLanguage release];
  [__impressions release];
  [__clientProperties release];
  [super dealloc];
}

- (NSString *) clientLanguage {
  return [[__clientLanguage retain] autorelease];
}

- (void) setClientLanguage: (NSString *) clientLanguage {
  [clientLanguage retain];
  [__clientLanguage release];
  __clientLanguage = clientLanguage;
  __clientLanguage_isset = YES;
}

- (BOOL) clientLanguageIsSet {
  return __clientLanguage_isset;
}

- (void) unsetClientLanguage {
  [__clientLanguage release];
  __clientLanguage = nil;
  __clientLanguage_isset = NO;
}

- (NSArray *) impressions {
  return [[__impressions retain] autorelease];
}

- (void) setImpressions: (NSArray *) impressions {
  [impressions retain];
  [__impressions release];
  __impressions = impressions;
  __impressions_isset = YES;
}

- (BOOL) impressionsIsSet {
  return __impressions_isset;
}

- (void) unsetImpressions {
  [__impressions release];
  __impressions = nil;
  __impressions_isset = NO;
}

- (BOOL) supportHtml {
  return __supportHtml;
}

- (void) setSupportHtml: (BOOL) supportHtml {
  __supportHtml = supportHtml;
  __supportHtml_isset = YES;
}

- (BOOL) supportHtmlIsSet {
  return __supportHtml_isset;
}

- (void) unsetSupportHtml {
  __supportHtml_isset = NO;
}

- (NSDictionary *) clientProperties {
  return [[__clientProperties retain] autorelease];
}

- (void) setClientProperties: (NSDictionary *) clientProperties {
  [clientProperties retain];
  [__clientProperties release];
  __clientProperties = clientProperties;
  __clientProperties_isset = YES;
}

- (BOOL) clientPropertiesIsSet {
  return __clientProperties_isset;
}

- (void) unsetClientProperties {
  [__clientProperties release];
  __clientProperties = nil;
  __clientProperties_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setClientLanguage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size77;
          [inProtocol readListBeginReturningElementType: NULL size: &_size77];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size77];
          int _i78;
          for (_i78 = 0; _i78 < _size77; ++_i78)
          {
            EDAMAdImpressions *_elem79 = [[EDAMAdImpressions alloc] init];
            [_elem79 read: inProtocol];
            [fieldValue addObject: _elem79];
            [_elem79 release];
          }
          [inProtocol readListEnd];
          [self setImpressions: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setSupportHtml: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_MAP) {
          int _size80;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size80];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size80];
          int _i81;
          for (_i81 = 0; _i81 < _size80; ++_i81)
          {
            NSString * _key82 = [inProtocol readString];
            NSString * _val83 = [inProtocol readString];
            [fieldValue setObject: _val83 forKey: _key82];
          }
          [inProtocol readMapEnd];
          [self setClientProperties: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AdParameters"];
  if (__clientLanguage_isset) {
    if (__clientLanguage != nil) {
      [outProtocol writeFieldBeginWithName: @"clientLanguage" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __clientLanguage];
      [outProtocol writeFieldEnd];
    }
  }
  if (__impressions_isset) {
    if (__impressions != nil) {
      [outProtocol writeFieldBeginWithName: @"impressions" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__impressions count]];
        NSUInteger i85;
        for (i85 = 0; i85 < [__impressions count]; i85++)
        {
          [[__impressions objectAtIndex: i85] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__supportHtml_isset) {
    [outProtocol writeFieldBeginWithName: @"supportHtml" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __supportHtml];
    [outProtocol writeFieldEnd];
  }
  if (__clientProperties_isset) {
    if (__clientProperties != nil) {
      [outProtocol writeFieldBeginWithName: @"clientProperties" type: TType_MAP fieldID: 6];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_STRING size: [__clientProperties count]];
        NSEnumerator * _iter86 = [__clientProperties keyEnumerator];
        id key87;
        while ((key87 = [_iter86 nextObject]))
        {
          [outProtocol writeString: key87];
          [outProtocol writeString: [__clientProperties objectForKey: key87]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AdParameters("];
  [ms appendString: @"clientLanguage:"];
  [ms appendFormat: @"\"%@\"", __clientLanguage];
  [ms appendString: @",impressions:"];
  [ms appendFormat: @"%@", __impressions];
  [ms appendString: @",supportHtml:"];
  [ms appendFormat: @"%i", __supportHtml];
  [ms appendString: @",clientProperties:"];
  [ms appendFormat: @"%@", __clientProperties];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteEmailParameters

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic guid;
@dynamic note;
@dynamic toAddresses;
@dynamic ccAddresses;
@dynamic subject;
@dynamic message;
#endif

- (id) initWithGuid: (NSString *) guid note: (EDAMNote *) note toAddresses: (NSArray *) toAddresses ccAddresses: (NSArray *) ccAddresses subject: (NSString *) subject message: (NSString *) message
{
  self = [super init];
  __guid = [guid retain];
  __guid_isset = YES;
  __note = [note retain];
  __note_isset = YES;
  __toAddresses = [toAddresses retain];
  __toAddresses_isset = YES;
  __ccAddresses = [ccAddresses retain];
  __ccAddresses_isset = YES;
  __subject = [subject retain];
  __subject_isset = YES;
  __message = [message retain];
  __message_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain];
    __note_isset = YES;
  }
  if ([decoder containsValueForKey: @"toAddresses"])
  {
    __toAddresses = [[decoder decodeObjectForKey: @"toAddresses"] retain];
    __toAddresses_isset = YES;
  }
  if ([decoder containsValueForKey: @"ccAddresses"])
  {
    __ccAddresses = [[decoder decodeObjectForKey: @"ccAddresses"] retain];
    __ccAddresses_isset = YES;
  }
  if ([decoder containsValueForKey: @"subject"])
  {
    __subject = [[decoder decodeObjectForKey: @"subject"] retain];
    __subject_isset = YES;
  }
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain];
    __message_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
  if (__toAddresses_isset)
  {
    [encoder encodeObject: __toAddresses forKey: @"toAddresses"];
  }
  if (__ccAddresses_isset)
  {
    [encoder encodeObject: __ccAddresses forKey: @"ccAddresses"];
  }
  if (__subject_isset)
  {
    [encoder encodeObject: __subject forKey: @"subject"];
  }
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
}

- (void) dealloc
{
  [__guid release];
  [__note release];
  [__toAddresses release];
  [__ccAddresses release];
  [__subject release];
  [__message release];
  [super dealloc];
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain] autorelease];
}

- (void) setNote: (EDAMNote *) note {
  [note retain];
  [__note release];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release];
  __note = nil;
  __note_isset = NO;
}

- (NSArray *) toAddresses {
  return [[__toAddresses retain] autorelease];
}

- (void) setToAddresses: (NSArray *) toAddresses {
  [toAddresses retain];
  [__toAddresses release];
  __toAddresses = toAddresses;
  __toAddresses_isset = YES;
}

- (BOOL) toAddressesIsSet {
  return __toAddresses_isset;
}

- (void) unsetToAddresses {
  [__toAddresses release];
  __toAddresses = nil;
  __toAddresses_isset = NO;
}

- (NSArray *) ccAddresses {
  return [[__ccAddresses retain] autorelease];
}

- (void) setCcAddresses: (NSArray *) ccAddresses {
  [ccAddresses retain];
  [__ccAddresses release];
  __ccAddresses = ccAddresses;
  __ccAddresses_isset = YES;
}

- (BOOL) ccAddressesIsSet {
  return __ccAddresses_isset;
}

- (void) unsetCcAddresses {
  [__ccAddresses release];
  __ccAddresses = nil;
  __ccAddresses_isset = NO;
}

- (NSString *) subject {
  return [[__subject retain] autorelease];
}

- (void) setSubject: (NSString *) subject {
  [subject retain];
  [__subject release];
  __subject = subject;
  __subject_isset = YES;
}

- (BOOL) subjectIsSet {
  return __subject_isset;
}

- (void) unsetSubject {
  [__subject release];
  __subject = nil;
  __subject_isset = NO;
}

- (NSString *) message {
  return [[__message retain] autorelease];
}

- (void) setMessage: (NSString *) message {
  [message retain];
  [__message release];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release];
  __message = nil;
  __message_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size88;
          [inProtocol readListBeginReturningElementType: NULL size: &_size88];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size88];
          int _i89;
          for (_i89 = 0; _i89 < _size88; ++_i89)
          {
            NSString * _elem90 = [inProtocol readString];
            [fieldValue addObject: _elem90];
          }
          [inProtocol readListEnd];
          [self setToAddresses: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size91;
          [inProtocol readListBeginReturningElementType: NULL size: &_size91];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size91];
          int _i92;
          for (_i92 = 0; _i92 < _size91; ++_i92)
          {
            NSString * _elem93 = [inProtocol readString];
            [fieldValue addObject: _elem93];
          }
          [inProtocol readListEnd];
          [self setCcAddresses: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubject: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteEmailParameters"];
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__toAddresses_isset) {
    if (__toAddresses != nil) {
      [outProtocol writeFieldBeginWithName: @"toAddresses" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__toAddresses count]];
        NSUInteger i95;
        for (i95 = 0; i95 < [__toAddresses count]; i95++)
        {
          [outProtocol writeString: [__toAddresses objectAtIndex: i95]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__ccAddresses_isset) {
    if (__ccAddresses != nil) {
      [outProtocol writeFieldBeginWithName: @"ccAddresses" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__ccAddresses count]];
        NSUInteger i97;
        for (i97 = 0; i97 < [__ccAddresses count]; i97++)
        {
          [outProtocol writeString: [__ccAddresses objectAtIndex: i97]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__subject_isset) {
    if (__subject != nil) {
      [outProtocol writeFieldBeginWithName: @"subject" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __subject];
      [outProtocol writeFieldEnd];
    }
  }
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteEmailParameters("];
  [ms appendString: @"guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @",toAddresses:"];
  [ms appendFormat: @"%@", __toAddresses];
  [ms appendString: @",ccAddresses:"];
  [ms appendFormat: @"%@", __ccAddresses];
  [ms appendString: @",subject:"];
  [ms appendFormat: @"\"%@\"", __subject];
  [ms appendString: @",message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteVersionId

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic updateSequenceNum;
@dynamic updated;
@dynamic saved;
@dynamic title;
#endif

- (id) initWithUpdateSequenceNum: (int32_t) updateSequenceNum updated: (EDAMTimestamp) updated saved: (EDAMTimestamp) saved title: (NSString *) title
{
  self = [super init];
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
  __updated = updated;
  __updated_isset = YES;
  __saved = saved;
  __saved_isset = YES;
  __title = [title retain];
  __title_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"updateSequenceNum"])
  {
    __updateSequenceNum = [decoder decodeInt32ForKey: @"updateSequenceNum"];
    __updateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"updated"])
  {
    __updated = [decoder decodeInt64ForKey: @"updated"];
    __updated_isset = YES;
  }
  if ([decoder containsValueForKey: @"saved"])
  {
    __saved = [decoder decodeInt64ForKey: @"saved"];
    __saved_isset = YES;
  }
  if ([decoder containsValueForKey: @"title"])
  {
    __title = [[decoder decodeObjectForKey: @"title"] retain];
    __title_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__updateSequenceNum_isset)
  {
    [encoder encodeInt32: __updateSequenceNum forKey: @"updateSequenceNum"];
  }
  if (__updated_isset)
  {
    [encoder encodeInt64: __updated forKey: @"updated"];
  }
  if (__saved_isset)
  {
    [encoder encodeInt64: __saved forKey: @"saved"];
  }
  if (__title_isset)
  {
    [encoder encodeObject: __title forKey: @"title"];
  }
}

- (void) dealloc
{
  [__title release];
  [super dealloc];
}

- (int32_t) updateSequenceNum {
  return __updateSequenceNum;
}

- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum {
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
}

- (BOOL) updateSequenceNumIsSet {
  return __updateSequenceNum_isset;
}

- (void) unsetUpdateSequenceNum {
  __updateSequenceNum_isset = NO;
}

- (int64_t) updated {
  return __updated;
}

- (void) setUpdated: (int64_t) updated {
  __updated = updated;
  __updated_isset = YES;
}

- (BOOL) updatedIsSet {
  return __updated_isset;
}

- (void) unsetUpdated {
  __updated_isset = NO;
}

- (int64_t) saved {
  return __saved;
}

- (void) setSaved: (int64_t) saved {
  __saved = saved;
  __saved_isset = YES;
}

- (BOOL) savedIsSet {
  return __saved_isset;
}

- (void) unsetSaved {
  __saved_isset = NO;
}

- (NSString *) title {
  return [[__title retain] autorelease];
}

- (void) setTitle: (NSString *) title {
  [title retain];
  [__title release];
  __title = title;
  __title_isset = YES;
}

- (BOOL) titleIsSet {
  return __title_isset;
}

- (void) unsetTitle {
  [__title release];
  __title = nil;
  __title_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setUpdated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setSaved: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteVersionId"];
  if (__updateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __updateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__updated_isset) {
    [outProtocol writeFieldBeginWithName: @"updated" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __updated];
    [outProtocol writeFieldEnd];
  }
  if (__saved_isset) {
    [outProtocol writeFieldBeginWithName: @"saved" type: TType_I64 fieldID: 3];
    [outProtocol writeI64: __saved];
    [outProtocol writeFieldEnd];
  }
  if (__title_isset) {
    if (__title != nil) {
      [outProtocol writeFieldBeginWithName: @"title" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __title];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteVersionId("];
  [ms appendString: @"updateSequenceNum:"];
  [ms appendFormat: @"%i", __updateSequenceNum];
  [ms appendString: @",updated:"];
  [ms appendFormat: @"%qi", __updated];
  [ms appendString: @",saved:"];
  [ms appendFormat: @"%qi", __saved];
  [ms appendString: @",title:"];
  [ms appendFormat: @"\"%@\"", __title];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSyncState_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMgetSyncState_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSyncState_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSyncState_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSyncState_result : NSObject <NSCoding> {
  EDAMSyncState * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSyncState * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMSyncState *) success;
- (void) setSuccess: (EDAMSyncState *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetSyncState_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSyncState *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSyncState *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncState *fieldValue = [[EDAMSyncState alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSyncState_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSyncState_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSyncChunk_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  int32_t __afterUSN;
  int32_t __maxEntries;
  BOOL __fullSyncOnly;

  BOOL __authenticationToken_isset;
  BOOL __afterUSN_isset;
  BOOL __maxEntries_isset;
  BOOL __fullSyncOnly_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, getter=afterUSN, setter=setAfterUSN:) int32_t afterUSN;
@property (nonatomic, getter=maxEntries, setter=setMaxEntries:) int32_t maxEntries;
@property (nonatomic, getter=fullSyncOnly, setter=setFullSyncOnly:) BOOL fullSyncOnly;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (int32_t) afterUSN;
- (void) setAfterUSN: (int32_t) afterUSN;
- (BOOL) afterUSNIsSet;

- (int32_t) maxEntries;
- (void) setMaxEntries: (int32_t) maxEntries;
- (BOOL) maxEntriesIsSet;

- (BOOL) fullSyncOnly;
- (void) setFullSyncOnly: (BOOL) fullSyncOnly;
- (BOOL) fullSyncOnlyIsSet;

@end

@implementation EDAMgetSyncChunk_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic afterUSN;
@dynamic maxEntries;
@dynamic fullSyncOnly;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"afterUSN"])
  {
    __afterUSN = [decoder decodeInt32ForKey: @"afterUSN"];
    __afterUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxEntries"])
  {
    __maxEntries = [decoder decodeInt32ForKey: @"maxEntries"];
    __maxEntries_isset = YES;
  }
  if ([decoder containsValueForKey: @"fullSyncOnly"])
  {
    __fullSyncOnly = [decoder decodeBoolForKey: @"fullSyncOnly"];
    __fullSyncOnly_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__afterUSN_isset)
  {
    [encoder encodeInt32: __afterUSN forKey: @"afterUSN"];
  }
  if (__maxEntries_isset)
  {
    [encoder encodeInt32: __maxEntries forKey: @"maxEntries"];
  }
  if (__fullSyncOnly_isset)
  {
    [encoder encodeBool: __fullSyncOnly forKey: @"fullSyncOnly"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (int32_t) afterUSN {
  return __afterUSN;
}

- (void) setAfterUSN: (int32_t) afterUSN {
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
}

- (BOOL) afterUSNIsSet {
  return __afterUSN_isset;
}

- (void) unsetAfterUSN {
  __afterUSN_isset = NO;
}

- (int32_t) maxEntries {
  return __maxEntries;
}

- (void) setMaxEntries: (int32_t) maxEntries {
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
}

- (BOOL) maxEntriesIsSet {
  return __maxEntries_isset;
}

- (void) unsetMaxEntries {
  __maxEntries_isset = NO;
}

- (BOOL) fullSyncOnly {
  return __fullSyncOnly;
}

- (void) setFullSyncOnly: (BOOL) fullSyncOnly {
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
}

- (BOOL) fullSyncOnlyIsSet {
  return __fullSyncOnly_isset;
}

- (void) unsetFullSyncOnly {
  __fullSyncOnly_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAfterUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxEntries: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setFullSyncOnly: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSyncChunk_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__afterUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __afterUSN];
    [outProtocol writeFieldEnd];
  }
  if (__maxEntries_isset) {
    [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __maxEntries];
    [outProtocol writeFieldEnd];
  }
  if (__fullSyncOnly_isset) {
    [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __fullSyncOnly];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSyncChunk_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",afterUSN:"];
  [ms appendFormat: @"%i", __afterUSN];
  [ms appendString: @",maxEntries:"];
  [ms appendFormat: @"%i", __maxEntries];
  [ms appendString: @",fullSyncOnly:"];
  [ms appendFormat: @"%i", __fullSyncOnly];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSyncChunk_result : NSObject <NSCoding> {
  EDAMSyncChunk * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSyncChunk * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMSyncChunk *) success;
- (void) setSuccess: (EDAMSyncChunk *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetSyncChunk_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSyncChunk *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSyncChunk *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunk *fieldValue = [[EDAMSyncChunk alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSyncChunk_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSyncChunk_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistNotebooks_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListNotebooks_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListNotebooks_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size98;
          [inProtocol readListBeginReturningElementType: NULL size: &_size98];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size98];
          int _i99;
          for (_i99 = 0; _i99 < _size98; ++_i99)
          {
            EDAMNotebook *_elem100 = [[EDAMNotebook alloc] init];
            [_elem100 read: inProtocol];
            [fieldValue addObject: _elem100];
            [_elem100 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        NSUInteger i102;
        for (i102 = 0; i102 < [__success count]; i102++)
        {
          [[__success objectAtIndex: i102] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetDefaultNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMgetDefaultNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getDefaultNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getDefaultNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetDefaultNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetDefaultNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetDefaultNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetDefaultNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNotebook * __notebook;

  BOOL __authenticationToken_isset;
  BOOL __notebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=notebook, setter=setNotebook:) EDAMNotebook * notebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMNotebook *) notebook;
- (void) setNotebook: (EDAMNotebook *) notebook;
- (BOOL) notebookIsSet;

@end

@implementation EDAMcreateNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic notebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __notebook = [notebook retain];
  __notebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebook"])
  {
    __notebook = [[decoder decodeObjectForKey: @"notebook"] retain];
    __notebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebook_isset)
  {
    [encoder encodeObject: __notebook forKey: @"notebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__notebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNotebook *) notebook {
  return [[__notebook retain] autorelease];
}

- (void) setNotebook: (EDAMNotebook *) notebook {
  [notebook retain];
  [__notebook release];
  __notebook = notebook;
  __notebook_isset = YES;
}

- (BOOL) notebookIsSet {
  return __notebook_isset;
}

- (void) unsetNotebook {
  [__notebook release];
  __notebook = nil;
  __notebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebook_isset) {
    if (__notebook != nil) {
      [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
      [__notebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebook:"];
  [ms appendFormat: @"%@", __notebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMCreateNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNotebook * __notebook;

  BOOL __authenticationToken_isset;
  BOOL __notebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=notebook, setter=setNotebook:) EDAMNotebook * notebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMNotebook *) notebook;
- (void) setNotebook: (EDAMNotebook *) notebook;
- (BOOL) notebookIsSet;

@end

@implementation EDAMupdateNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic notebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __notebook = [notebook retain];
  __notebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebook"])
  {
    __notebook = [[decoder decodeObjectForKey: @"notebook"] retain];
    __notebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebook_isset)
  {
    [encoder encodeObject: __notebook forKey: @"notebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__notebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNotebook *) notebook {
  return [[__notebook retain] autorelease];
}

- (void) setNotebook: (EDAMNotebook *) notebook {
  [notebook retain];
  [__notebook release];
  __notebook = notebook;
  __notebook_isset = YES;
}

- (BOOL) notebookIsSet {
  return __notebook_isset;
}

- (void) unsetNotebook {
  [__notebook release];
  __notebook = nil;
  __notebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebook_isset) {
    if (__notebook != nil) {
      [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
      [__notebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebook:"];
  [ms appendFormat: @"%@", __notebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistTags_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistTags_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listTags_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listTags_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListTags_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListTags_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size103;
          [inProtocol readListBeginReturningElementType: NULL size: &_size103];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size103];
          int _i104;
          for (_i104 = 0; _i104 < _size103; ++_i104)
          {
            EDAMTag *_elem105 = [[EDAMTag alloc] init];
            [_elem105 read: inProtocol];
            [fieldValue addObject: _elem105];
            [_elem105 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListTags_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        NSUInteger i107;
        for (i107 = 0; i107 < [__success count]; i107++)
        {
          [[__success objectAtIndex: i107] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListTags_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistTagsByNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __notebookGuid;

  BOOL __authenticationToken_isset;
  BOOL __notebookGuid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=notebookGuid, setter=setNotebookGuid:) EDAMGuid notebookGuid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) notebookGuid;
- (void) setNotebookGuid: (EDAMGuid) notebookGuid;
- (BOOL) notebookGuidIsSet;

@end

@implementation EDAMlistTagsByNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic notebookGuid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __notebookGuid = [notebookGuid retain];
  __notebookGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain];
    __notebookGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__notebookGuid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain] autorelease];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain];
  [__notebookGuid release];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listTagsByNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listTagsByNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListTagsByNotebook_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMListTagsByNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size108;
          [inProtocol readListBeginReturningElementType: NULL size: &_size108];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size108];
          int _i109;
          for (_i109 = 0; _i109 < _size108; ++_i109)
          {
            EDAMTag *_elem110 = [[EDAMTag alloc] init];
            [_elem110 read: inProtocol];
            [fieldValue addObject: _elem110];
            [_elem110 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListTagsByNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        NSUInteger i112;
        for (i112 = 0; i112 < [__success count]; i112++)
        {
          [[__success objectAtIndex: i112] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListTagsByNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetTag_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetTag_result : NSObject <NSCoding> {
  EDAMTag * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMTag * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMTag *) success;
- (void) setSuccess: (EDAMTag *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetTag_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMTag *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMTag *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetTag_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMTag * __tag;

  BOOL __authenticationToken_isset;
  BOOL __tag_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=tag, setter=setTag:) EDAMTag * tag;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMTag *) tag;
- (void) setTag: (EDAMTag *) tag;
- (BOOL) tagIsSet;

@end

@implementation EDAMcreateTag_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic tag;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __tag = [tag retain];
  __tag_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"tag"])
  {
    __tag = [[decoder decodeObjectForKey: @"tag"] retain];
    __tag_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__tag_isset)
  {
    [encoder encodeObject: __tag forKey: @"tag"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__tag release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMTag *) tag {
  return [[__tag retain] autorelease];
}

- (void) setTag: (EDAMTag *) tag {
  [tag retain];
  [__tag release];
  __tag = tag;
  __tag_isset = YES;
}

- (BOOL) tagIsSet {
  return __tag_isset;
}

- (void) unsetTag {
  [__tag release];
  __tag = nil;
  __tag_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setTag: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tag_isset) {
    if (__tag != nil) {
      [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
      [__tag write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",tag:"];
  [ms appendFormat: @"%@", __tag];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateTag_result : NSObject <NSCoding> {
  EDAMTag * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMTag * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMTag *) success;
- (void) setSuccess: (EDAMTag *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMCreateTag_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMTag *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMTag *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateTag_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMTag * __tag;

  BOOL __authenticationToken_isset;
  BOOL __tag_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=tag, setter=setTag:) EDAMTag * tag;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMTag *) tag;
- (void) setTag: (EDAMTag *) tag;
- (BOOL) tagIsSet;

@end

@implementation EDAMupdateTag_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic tag;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __tag = [tag retain];
  __tag_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"tag"])
  {
    __tag = [[decoder decodeObjectForKey: @"tag"] retain];
    __tag_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__tag_isset)
  {
    [encoder encodeObject: __tag forKey: @"tag"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__tag release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMTag *) tag {
  return [[__tag retain] autorelease];
}

- (void) setTag: (EDAMTag *) tag {
  [tag retain];
  [__tag release];
  __tag = tag;
  __tag_isset = YES;
}

- (BOOL) tagIsSet {
  return __tag_isset;
}

- (void) unsetTag {
  [__tag release];
  __tag = nil;
  __tag_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setTag: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tag_isset) {
    if (__tag != nil) {
      [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
      [__tag write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",tag:"];
  [ms appendFormat: @"%@", __tag];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateTag_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateTag_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateTag_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMuntagAll_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMuntagAll_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"untagAll_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"untagAll_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUntagAll_result : NSObject <NSCoding> {
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithUserException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUntagAll_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithUserException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UntagAll_result"];

  if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UntagAll_result("];
  [ms appendString: @"userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeTag_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeTag_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeTag_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeTag_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistSearches_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistSearches_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listSearches_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listSearches_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListSearches_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListSearches_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size113;
          [inProtocol readListBeginReturningElementType: NULL size: &_size113];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size113];
          int _i114;
          for (_i114 = 0; _i114 < _size113; ++_i114)
          {
            EDAMSavedSearch *_elem115 = [[EDAMSavedSearch alloc] init];
            [_elem115 read: inProtocol];
            [fieldValue addObject: _elem115];
            [_elem115 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListSearches_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        NSUInteger i117;
        for (i117 = 0; i117 < [__success count]; i117++)
        {
          [[__success objectAtIndex: i117] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListSearches_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetSearch_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSearch_result : NSObject <NSCoding> {
  EDAMSavedSearch * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSavedSearch * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMSavedSearch *) success;
- (void) setSuccess: (EDAMSavedSearch *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetSearch_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMSavedSearch *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSavedSearch *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSearch_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSavedSearch * __search;

  BOOL __authenticationToken_isset;
  BOOL __search_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=search, setter=setSearch:) EDAMSavedSearch * search;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMSavedSearch *) search;
- (void) setSearch: (EDAMSavedSearch *) search;
- (BOOL) searchIsSet;

@end

@implementation EDAMcreateSearch_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic search;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __search = [search retain];
  __search_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"search"])
  {
    __search = [[decoder decodeObjectForKey: @"search"] retain];
    __search_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__search_isset)
  {
    [encoder encodeObject: __search forKey: @"search"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__search release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSavedSearch *) search {
  return [[__search retain] autorelease];
}

- (void) setSearch: (EDAMSavedSearch *) search {
  [search retain];
  [__search release];
  __search = search;
  __search_isset = YES;
}

- (BOOL) searchIsSet {
  return __search_isset;
}

- (void) unsetSearch {
  [__search release];
  __search = nil;
  __search_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSearch: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__search_isset) {
    if (__search != nil) {
      [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
      [__search write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",search:"];
  [ms appendFormat: @"%@", __search];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateSearch_result : NSObject <NSCoding> {
  EDAMSavedSearch * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSavedSearch * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMSavedSearch *) success;
- (void) setSuccess: (EDAMSavedSearch *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMCreateSearch_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSavedSearch *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSavedSearch *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateSearch_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSavedSearch * __search;

  BOOL __authenticationToken_isset;
  BOOL __search_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=search, setter=setSearch:) EDAMSavedSearch * search;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMSavedSearch *) search;
- (void) setSearch: (EDAMSavedSearch *) search;
- (BOOL) searchIsSet;

@end

@implementation EDAMupdateSearch_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic search;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __search = [search retain];
  __search_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"search"])
  {
    __search = [[decoder decodeObjectForKey: @"search"] retain];
    __search_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__search_isset)
  {
    [encoder encodeObject: __search forKey: @"search"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__search release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSavedSearch *) search {
  return [[__search retain] autorelease];
}

- (void) setSearch: (EDAMSavedSearch *) search {
  [search retain];
  [__search release];
  __search = search;
  __search_isset = YES;
}

- (BOOL) searchIsSet {
  return __search_isset;
}

- (void) unsetSearch {
  [__search release];
  __search = nil;
  __search_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSearch: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__search_isset) {
    if (__search != nil) {
      [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
      [__search write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",search:"];
  [ms appendFormat: @"%@", __search];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateSearch_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateSearch_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateSearch_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeSearch_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeSearch_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeSearch_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeSearch_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  int32_t __offset;
  int32_t __maxNotes;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __offset_isset;
  BOOL __maxNotes_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, getter=offset, setter=setOffset:) int32_t offset;
@property (nonatomic, getter=maxNotes, setter=setMaxNotes:) int32_t maxNotes;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;
- (BOOL) filterIsSet;

- (int32_t) offset;
- (void) setOffset: (int32_t) offset;
- (BOOL) offsetIsSet;

- (int32_t) maxNotes;
- (void) setMaxNotes: (int32_t) maxNotes;
- (BOOL) maxNotesIsSet;

@end

@implementation EDAMfindNotes_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic filter;
@dynamic offset;
@dynamic maxNotes;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __filter = [filter retain];
  __filter_isset = YES;
  __offset = offset;
  __offset_isset = YES;
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"offset"])
  {
    __offset = [decoder decodeInt32ForKey: @"offset"];
    __offset_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxNotes"])
  {
    __maxNotes = [decoder decodeInt32ForKey: @"maxNotes"];
    __maxNotes_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__offset_isset)
  {
    [encoder encodeInt32: __offset forKey: @"offset"];
  }
  if (__maxNotes_isset)
  {
    [encoder encodeInt32: __maxNotes forKey: @"maxNotes"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__filter release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain] autorelease];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain];
  [__filter release];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release];
  __filter = nil;
  __filter_isset = NO;
}

- (int32_t) offset {
  return __offset;
}

- (void) setOffset: (int32_t) offset {
  __offset = offset;
  __offset_isset = YES;
}

- (BOOL) offsetIsSet {
  return __offset_isset;
}

- (void) unsetOffset {
  __offset_isset = NO;
}

- (int32_t) maxNotes {
  return __maxNotes;
}

- (void) setMaxNotes: (int32_t) maxNotes {
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
}

- (BOOL) maxNotesIsSet {
  return __maxNotes_isset;
}

- (void) unsetMaxNotes {
  __maxNotes_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOffset: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__offset_isset) {
    [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __offset];
    [outProtocol writeFieldEnd];
  }
  if (__maxNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __maxNotes];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",offset:"];
  [ms appendFormat: @"%i", __offset];
  [ms appendString: @",maxNotes:"];
  [ms appendFormat: @"%i", __maxNotes];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNotes_result : NSObject <NSCoding> {
  EDAMNoteList * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNoteList * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNoteList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNoteList *) success;
- (void) setSuccess: (EDAMNoteList *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMFindNotes_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNoteList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNoteList *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNoteList *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNoteList *fieldValue = [[EDAMNoteList alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNotes_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNoteCounts_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  BOOL __withTrash;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __withTrash_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, getter=withTrash, setter=setWithTrash:) BOOL withTrash;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;
- (BOOL) filterIsSet;

- (BOOL) withTrash;
- (void) setWithTrash: (BOOL) withTrash;
- (BOOL) withTrashIsSet;

@end

@implementation EDAMfindNoteCounts_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic filter;
@dynamic withTrash;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __filter = [filter retain];
  __filter_isset = YES;
  __withTrash = withTrash;
  __withTrash_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"withTrash"])
  {
    __withTrash = [decoder decodeBoolForKey: @"withTrash"];
    __withTrash_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__withTrash_isset)
  {
    [encoder encodeBool: __withTrash forKey: @"withTrash"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__filter release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain] autorelease];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain];
  [__filter release];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release];
  __filter = nil;
  __filter_isset = NO;
}

- (BOOL) withTrash {
  return __withTrash;
}

- (void) setWithTrash: (BOOL) withTrash {
  __withTrash = withTrash;
  __withTrash_isset = YES;
}

- (BOOL) withTrashIsSet {
  return __withTrash_isset;
}

- (void) unsetWithTrash {
  __withTrash_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithTrash: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNoteCounts_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withTrash_isset) {
    [outProtocol writeFieldBeginWithName: @"withTrash" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withTrash];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNoteCounts_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",withTrash:"];
  [ms appendFormat: @"%i", __withTrash];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNoteCounts_result : NSObject <NSCoding> {
  EDAMNoteCollectionCounts * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNoteCollectionCounts * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNoteCollectionCounts *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNoteCollectionCounts *) success;
- (void) setSuccess: (EDAMNoteCollectionCounts *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMFindNoteCounts_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNoteCollectionCounts *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNoteCollectionCounts *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNoteCollectionCounts *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNoteCollectionCounts *fieldValue = [[EDAMNoteCollectionCounts alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNoteCounts_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNoteCounts_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  BOOL __withContent;
  BOOL __withResourcesData;
  BOOL __withResourcesRecognition;
  BOOL __withResourcesAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __withContent_isset;
  BOOL __withResourcesData_isset;
  BOOL __withResourcesRecognition_isset;
  BOOL __withResourcesAlternateData_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, getter=withContent, setter=setWithContent:) BOOL withContent;
@property (nonatomic, getter=withResourcesData, setter=setWithResourcesData:) BOOL withResourcesData;
@property (nonatomic, getter=withResourcesRecognition, setter=setWithResourcesRecognition:) BOOL withResourcesRecognition;
@property (nonatomic, getter=withResourcesAlternateData, setter=setWithResourcesAlternateData:) BOOL withResourcesAlternateData;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

- (BOOL) withContent;
- (void) setWithContent: (BOOL) withContent;
- (BOOL) withContentIsSet;

- (BOOL) withResourcesData;
- (void) setWithResourcesData: (BOOL) withResourcesData;
- (BOOL) withResourcesDataIsSet;

- (BOOL) withResourcesRecognition;
- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition;
- (BOOL) withResourcesRecognitionIsSet;

- (BOOL) withResourcesAlternateData;
- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData;
- (BOOL) withResourcesAlternateDataIsSet;

@end

@implementation EDAMgetNote_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
@dynamic withContent;
@dynamic withResourcesData;
@dynamic withResourcesRecognition;
@dynamic withResourcesAlternateData;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __withContent = withContent;
  __withContent_isset = YES;
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"withContent"])
  {
    __withContent = [decoder decodeBoolForKey: @"withContent"];
    __withContent_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesData"])
  {
    __withResourcesData = [decoder decodeBoolForKey: @"withResourcesData"];
    __withResourcesData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesRecognition"])
  {
    __withResourcesRecognition = [decoder decodeBoolForKey: @"withResourcesRecognition"];
    __withResourcesRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesAlternateData"])
  {
    __withResourcesAlternateData = [decoder decodeBoolForKey: @"withResourcesAlternateData"];
    __withResourcesAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__withContent_isset)
  {
    [encoder encodeBool: __withContent forKey: @"withContent"];
  }
  if (__withResourcesData_isset)
  {
    [encoder encodeBool: __withResourcesData forKey: @"withResourcesData"];
  }
  if (__withResourcesRecognition_isset)
  {
    [encoder encodeBool: __withResourcesRecognition forKey: @"withResourcesRecognition"];
  }
  if (__withResourcesAlternateData_isset)
  {
    [encoder encodeBool: __withResourcesAlternateData forKey: @"withResourcesAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (BOOL) withContent {
  return __withContent;
}

- (void) setWithContent: (BOOL) withContent {
  __withContent = withContent;
  __withContent_isset = YES;
}

- (BOOL) withContentIsSet {
  return __withContent_isset;
}

- (void) unsetWithContent {
  __withContent_isset = NO;
}

- (BOOL) withResourcesData {
  return __withResourcesData;
}

- (void) setWithResourcesData: (BOOL) withResourcesData {
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
}

- (BOOL) withResourcesDataIsSet {
  return __withResourcesData_isset;
}

- (void) unsetWithResourcesData {
  __withResourcesData_isset = NO;
}

- (BOOL) withResourcesRecognition {
  return __withResourcesRecognition;
}

- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition {
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
}

- (BOOL) withResourcesRecognitionIsSet {
  return __withResourcesRecognition_isset;
}

- (void) unsetWithResourcesRecognition {
  __withResourcesRecognition_isset = NO;
}

- (BOOL) withResourcesAlternateData {
  return __withResourcesAlternateData;
}

- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData {
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
}

- (BOOL) withResourcesAlternateDataIsSet {
  return __withResourcesAlternateData_isset;
}

- (void) unsetWithResourcesAlternateData {
  __withResourcesAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithContent: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withContent_isset) {
    [outProtocol writeFieldBeginWithName: @"withContent" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withContent];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withResourcesData];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withResourcesRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withResourcesAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",withContent:"];
  [ms appendFormat: @"%i", __withContent];
  [ms appendString: @",withResourcesData:"];
  [ms appendFormat: @"%i", __withResourcesData];
  [ms appendString: @",withResourcesRecognition:"];
  [ms appendFormat: @"%i", __withResourcesRecognition];
  [ms appendString: @",withResourcesAlternateData:"];
  [ms appendFormat: @"%i", __withResourcesAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNote_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteContent_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetNoteContent_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteContent_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteContent_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteContent_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteContent_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteContent_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteContent_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteSearchText_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetNoteSearchText_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteSearchText_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteSearchText_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteSearchText_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) success;
- (void) setSuccess: (NSString *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteSearchText_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteSearchText_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteSearchText_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteTagNames_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetNoteTagNames_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteTagNames_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteTagNames_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteTagNames_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteTagNames_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size118;
          [inProtocol readListBeginReturningElementType: NULL size: &_size118];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size118];
          int _i119;
          for (_i119 = 0; _i119 < _size118; ++_i119)
          {
            NSString * _elem120 = [inProtocol readString];
            [fieldValue addObject: _elem120];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteTagNames_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__success count]];
        NSUInteger i122;
        for (i122 = 0; i122 < [__success count]; i122++)
        {
          [outProtocol writeString: [__success objectAtIndex: i122]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteTagNames_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNote * __note;

  BOOL __authenticationToken_isset;
  BOOL __note_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=note, setter=setNote:) EDAMNote * note;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMNote *) note;
- (void) setNote: (EDAMNote *) note;
- (BOOL) noteIsSet;

@end

@implementation EDAMcreateNote_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic note;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __note = [note retain];
  __note_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain];
    __note_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__note release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain] autorelease];
}

- (void) setNote: (EDAMNote *) note {
  [note retain];
  [__note release];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release];
  __note = nil;
  __note_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMCreateNote_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNote * __note;

  BOOL __authenticationToken_isset;
  BOOL __note_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=note, setter=setNote:) EDAMNote * note;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMNote *) note;
- (void) setNote: (EDAMNote *) note;
- (BOOL) noteIsSet;

@end

@implementation EDAMupdateNote_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic note;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __note = [note retain];
  __note_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain];
    __note_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__note release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain] autorelease];
}

- (void) setNote: (EDAMNote *) note {
  [note retain];
  [__note release];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release];
  __note = nil;
  __note_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateNote_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMdeleteNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMdeleteNote_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"deleteNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"deleteNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMDeleteNote_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMDeleteNote_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"DeleteNote_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"DeleteNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMexpungeNote_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNote_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeNote_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNote_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  NSArray * __noteGuids;

  BOOL __authenticationToken_isset;
  BOOL __noteGuids_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuids, setter=setNoteGuids:) NSArray * noteGuids;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuids: (NSArray *) noteGuids;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (NSArray *) noteGuids;
- (void) setNoteGuids: (NSArray *) noteGuids;
- (BOOL) noteGuidsIsSet;

@end

@implementation EDAMexpungeNotes_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic noteGuids;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuids: (NSArray *) noteGuids
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuids = [noteGuids retain];
  __noteGuids_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuids"])
  {
    __noteGuids = [[decoder decodeObjectForKey: @"noteGuids"] retain];
    __noteGuids_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuids_isset)
  {
    [encoder encodeObject: __noteGuids forKey: @"noteGuids"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuids release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSArray *) noteGuids {
  return [[__noteGuids retain] autorelease];
}

- (void) setNoteGuids: (NSArray *) noteGuids {
  [noteGuids retain];
  [__noteGuids release];
  __noteGuids = noteGuids;
  __noteGuids_isset = YES;
}

- (BOOL) noteGuidsIsSet {
  return __noteGuids_isset;
}

- (void) unsetNoteGuids {
  [__noteGuids release];
  __noteGuids = nil;
  __noteGuids_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size123;
          [inProtocol readListBeginReturningElementType: NULL size: &_size123];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size123];
          int _i124;
          for (_i124 = 0; _i124 < _size123; ++_i124)
          {
            NSString * _elem125 = [inProtocol readString];
            [fieldValue addObject: _elem125];
          }
          [inProtocol readListEnd];
          [self setNoteGuids: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuids_isset) {
    if (__noteGuids != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuids" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__noteGuids count]];
        NSUInteger i127;
        for (i127 = 0; i127 < [__noteGuids count]; i127++)
        {
          [outProtocol writeString: [__noteGuids objectAtIndex: i127]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuids:"];
  [ms appendFormat: @"%@", __noteGuids];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNotes_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMExpungeNotes_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNotes_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeInactiveNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMexpungeInactiveNotes_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeInactiveNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeInactiveNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeInactiveNotes_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMExpungeInactiveNotes_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeInactiveNotes_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeInactiveNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcopyNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  EDAMGuid __toNotebookGuid;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __toNotebookGuid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, retain, getter=toNotebookGuid, setter=setToNotebookGuid:) EDAMGuid toNotebookGuid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;
- (BOOL) noteGuidIsSet;

- (EDAMGuid) toNotebookGuid;
- (void) setToNotebookGuid: (EDAMGuid) toNotebookGuid;
- (BOOL) toNotebookGuidIsSet;

@end

@implementation EDAMcopyNote_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic noteGuid;
@dynamic toNotebookGuid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain];
  __noteGuid_isset = YES;
  __toNotebookGuid = [toNotebookGuid retain];
  __toNotebookGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"toNotebookGuid"])
  {
    __toNotebookGuid = [[decoder decodeObjectForKey: @"toNotebookGuid"] retain];
    __toNotebookGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__toNotebookGuid_isset)
  {
    [encoder encodeObject: __toNotebookGuid forKey: @"toNotebookGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuid release];
  [__toNotebookGuid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain] autorelease];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain];
  [__noteGuid release];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (NSString *) toNotebookGuid {
  return [[__toNotebookGuid retain] autorelease];
}

- (void) setToNotebookGuid: (NSString *) toNotebookGuid {
  [toNotebookGuid retain];
  [__toNotebookGuid release];
  __toNotebookGuid = toNotebookGuid;
  __toNotebookGuid_isset = YES;
}

- (BOOL) toNotebookGuidIsSet {
  return __toNotebookGuid_isset;
}

- (void) unsetToNotebookGuid {
  [__toNotebookGuid release];
  __toNotebookGuid = nil;
  __toNotebookGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setToNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"copyNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__toNotebookGuid_isset) {
    if (__toNotebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"toNotebookGuid" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __toNotebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"copyNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",toNotebookGuid:"];
  [ms appendFormat: @"\"%@\"", __toNotebookGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCopyNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMCopyNote_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CopyNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CopyNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistNoteVersions_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;
- (BOOL) noteGuidIsSet;

@end

@implementation EDAMlistNoteVersions_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic noteGuid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain];
  __noteGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain];
    __noteGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain] autorelease];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain];
  [__noteGuid release];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listNoteVersions_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listNoteVersions_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListNoteVersions_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMListNoteVersions_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size128;
          [inProtocol readListBeginReturningElementType: NULL size: &_size128];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size128];
          int _i129;
          for (_i129 = 0; _i129 < _size128; ++_i129)
          {
            EDAMNoteVersionId *_elem130 = [[EDAMNoteVersionId alloc] init];
            [_elem130 read: inProtocol];
            [fieldValue addObject: _elem130];
            [_elem130 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListNoteVersions_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        NSUInteger i132;
        for (i132 = 0; i132 < [__success count]; i132++)
        {
          [[__success objectAtIndex: i132] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListNoteVersions_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteVersion_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  int32_t __updateSequenceNum;
  BOOL __withResourcesData;
  BOOL __withResourcesRecognition;
  BOOL __withResourcesAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __updateSequenceNum_isset;
  BOOL __withResourcesData_isset;
  BOOL __withResourcesRecognition_isset;
  BOOL __withResourcesAlternateData_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, getter=updateSequenceNum, setter=setUpdateSequenceNum:) int32_t updateSequenceNum;
@property (nonatomic, getter=withResourcesData, setter=setWithResourcesData:) BOOL withResourcesData;
@property (nonatomic, getter=withResourcesRecognition, setter=setWithResourcesRecognition:) BOOL withResourcesRecognition;
@property (nonatomic, getter=withResourcesAlternateData, setter=setWithResourcesAlternateData:) BOOL withResourcesAlternateData;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;
- (BOOL) noteGuidIsSet;

- (int32_t) updateSequenceNum;
- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum;
- (BOOL) updateSequenceNumIsSet;

- (BOOL) withResourcesData;
- (void) setWithResourcesData: (BOOL) withResourcesData;
- (BOOL) withResourcesDataIsSet;

- (BOOL) withResourcesRecognition;
- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition;
- (BOOL) withResourcesRecognitionIsSet;

- (BOOL) withResourcesAlternateData;
- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData;
- (BOOL) withResourcesAlternateDataIsSet;

@end

@implementation EDAMgetNoteVersion_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic noteGuid;
@dynamic updateSequenceNum;
@dynamic withResourcesData;
@dynamic withResourcesRecognition;
@dynamic withResourcesAlternateData;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain];
  __noteGuid_isset = YES;
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateSequenceNum"])
  {
    __updateSequenceNum = [decoder decodeInt32ForKey: @"updateSequenceNum"];
    __updateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesData"])
  {
    __withResourcesData = [decoder decodeBoolForKey: @"withResourcesData"];
    __withResourcesData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesRecognition"])
  {
    __withResourcesRecognition = [decoder decodeBoolForKey: @"withResourcesRecognition"];
    __withResourcesRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesAlternateData"])
  {
    __withResourcesAlternateData = [decoder decodeBoolForKey: @"withResourcesAlternateData"];
    __withResourcesAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__updateSequenceNum_isset)
  {
    [encoder encodeInt32: __updateSequenceNum forKey: @"updateSequenceNum"];
  }
  if (__withResourcesData_isset)
  {
    [encoder encodeBool: __withResourcesData forKey: @"withResourcesData"];
  }
  if (__withResourcesRecognition_isset)
  {
    [encoder encodeBool: __withResourcesRecognition forKey: @"withResourcesRecognition"];
  }
  if (__withResourcesAlternateData_isset)
  {
    [encoder encodeBool: __withResourcesAlternateData forKey: @"withResourcesAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain] autorelease];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain];
  [__noteGuid release];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (int32_t) updateSequenceNum {
  return __updateSequenceNum;
}

- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum {
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
}

- (BOOL) updateSequenceNumIsSet {
  return __updateSequenceNum_isset;
}

- (void) unsetUpdateSequenceNum {
  __updateSequenceNum_isset = NO;
}

- (BOOL) withResourcesData {
  return __withResourcesData;
}

- (void) setWithResourcesData: (BOOL) withResourcesData {
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
}

- (BOOL) withResourcesDataIsSet {
  return __withResourcesData_isset;
}

- (void) unsetWithResourcesData {
  __withResourcesData_isset = NO;
}

- (BOOL) withResourcesRecognition {
  return __withResourcesRecognition;
}

- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition {
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
}

- (BOOL) withResourcesRecognitionIsSet {
  return __withResourcesRecognition_isset;
}

- (void) unsetWithResourcesRecognition {
  __withResourcesRecognition_isset = NO;
}

- (BOOL) withResourcesAlternateData {
  return __withResourcesAlternateData;
}

- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData {
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
}

- (BOOL) withResourcesAlternateDataIsSet {
  return __withResourcesAlternateData_isset;
}

- (void) unsetWithResourcesAlternateData {
  __withResourcesAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteVersion_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__updateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withResourcesData];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withResourcesRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withResourcesAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteVersion_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",updateSequenceNum:"];
  [ms appendFormat: @"%i", __updateSequenceNum];
  [ms appendString: @",withResourcesData:"];
  [ms appendFormat: @"%i", __withResourcesData];
  [ms appendString: @",withResourcesRecognition:"];
  [ms appendFormat: @"%i", __withResourcesRecognition];
  [ms appendString: @",withResourcesAlternateData:"];
  [ms appendFormat: @"%i", __withResourcesAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteVersion_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetNoteVersion_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteVersion_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteVersion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResource_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  BOOL __withData;
  BOOL __withRecognition;
  BOOL __withAttributes;
  BOOL __withAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __withData_isset;
  BOOL __withRecognition_isset;
  BOOL __withAttributes_isset;
  BOOL __withAlternateData_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, getter=withData, setter=setWithData:) BOOL withData;
@property (nonatomic, getter=withRecognition, setter=setWithRecognition:) BOOL withRecognition;
@property (nonatomic, getter=withAttributes, setter=setWithAttributes:) BOOL withAttributes;
@property (nonatomic, getter=withAlternateData, setter=setWithAlternateData:) BOOL withAlternateData;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

- (BOOL) withData;
- (void) setWithData: (BOOL) withData;
- (BOOL) withDataIsSet;

- (BOOL) withRecognition;
- (void) setWithRecognition: (BOOL) withRecognition;
- (BOOL) withRecognitionIsSet;

- (BOOL) withAttributes;
- (void) setWithAttributes: (BOOL) withAttributes;
- (BOOL) withAttributesIsSet;

- (BOOL) withAlternateData;
- (void) setWithAlternateData: (BOOL) withAlternateData;
- (BOOL) withAlternateDataIsSet;

@end

@implementation EDAMgetResource_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
@dynamic withData;
@dynamic withRecognition;
@dynamic withAttributes;
@dynamic withAlternateData;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __withData = withData;
  __withData_isset = YES;
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
  __withAttributes = withAttributes;
  __withAttributes_isset = YES;
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"withData"])
  {
    __withData = [decoder decodeBoolForKey: @"withData"];
    __withData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withRecognition"])
  {
    __withRecognition = [decoder decodeBoolForKey: @"withRecognition"];
    __withRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAttributes"])
  {
    __withAttributes = [decoder decodeBoolForKey: @"withAttributes"];
    __withAttributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAlternateData"])
  {
    __withAlternateData = [decoder decodeBoolForKey: @"withAlternateData"];
    __withAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__withData_isset)
  {
    [encoder encodeBool: __withData forKey: @"withData"];
  }
  if (__withRecognition_isset)
  {
    [encoder encodeBool: __withRecognition forKey: @"withRecognition"];
  }
  if (__withAttributes_isset)
  {
    [encoder encodeBool: __withAttributes forKey: @"withAttributes"];
  }
  if (__withAlternateData_isset)
  {
    [encoder encodeBool: __withAlternateData forKey: @"withAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (BOOL) withData {
  return __withData;
}

- (void) setWithData: (BOOL) withData {
  __withData = withData;
  __withData_isset = YES;
}

- (BOOL) withDataIsSet {
  return __withData_isset;
}

- (void) unsetWithData {
  __withData_isset = NO;
}

- (BOOL) withRecognition {
  return __withRecognition;
}

- (void) setWithRecognition: (BOOL) withRecognition {
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
}

- (BOOL) withRecognitionIsSet {
  return __withRecognition_isset;
}

- (void) unsetWithRecognition {
  __withRecognition_isset = NO;
}

- (BOOL) withAttributes {
  return __withAttributes;
}

- (void) setWithAttributes: (BOOL) withAttributes {
  __withAttributes = withAttributes;
  __withAttributes_isset = YES;
}

- (BOOL) withAttributesIsSet {
  return __withAttributes_isset;
}

- (void) unsetWithAttributes {
  __withAttributes_isset = NO;
}

- (BOOL) withAlternateData {
  return __withAlternateData;
}

- (void) setWithAlternateData: (BOOL) withAlternateData {
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
}

- (BOOL) withAlternateDataIsSet {
  return __withAlternateData_isset;
}

- (void) unsetWithAlternateData {
  __withAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAttributes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResource_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withData_isset) {
    [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withData];
    [outProtocol writeFieldEnd];
  }
  if (__withRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withAttributes_isset) {
    [outProtocol writeFieldBeginWithName: @"withAttributes" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withAttributes];
    [outProtocol writeFieldEnd];
  }
  if (__withAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResource_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",withData:"];
  [ms appendFormat: @"%i", __withData];
  [ms appendString: @",withRecognition:"];
  [ms appendFormat: @"%i", __withRecognition];
  [ms appendString: @",withAttributes:"];
  [ms appendFormat: @"%i", __withAttributes];
  [ms appendString: @",withAlternateData:"];
  [ms appendFormat: @"%i", __withAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResource_result : NSObject <NSCoding> {
  EDAMResource * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMResource * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMResource *) success;
- (void) setSuccess: (EDAMResource *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResource_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMResource *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMResource *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResource_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResource_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateResource_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMResource * __resource;

  BOOL __authenticationToken_isset;
  BOOL __resource_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=resource, setter=setResource:) EDAMResource * resource;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken resource: (EDAMResource *) resource;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMResource *) resource;
- (void) setResource: (EDAMResource *) resource;
- (BOOL) resourceIsSet;

@end

@implementation EDAMupdateResource_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic resource;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken resource: (EDAMResource *) resource
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __resource = [resource retain];
  __resource_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"resource"])
  {
    __resource = [[decoder decodeObjectForKey: @"resource"] retain];
    __resource_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__resource_isset)
  {
    [encoder encodeObject: __resource forKey: @"resource"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__resource release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMResource *) resource {
  return [[__resource retain] autorelease];
}

- (void) setResource: (EDAMResource *) resource {
  [resource retain];
  [__resource release];
  __resource = resource;
  __resource_isset = YES;
}

- (BOOL) resourceIsSet {
  return __resource_isset;
}

- (void) unsetResource {
  [__resource release];
  __resource = nil;
  __resource_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setResource: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateResource_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__resource_isset) {
    if (__resource != nil) {
      [outProtocol writeFieldBeginWithName: @"resource" type: TType_STRUCT fieldID: 2];
      [__resource write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateResource_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",resource:"];
  [ms appendFormat: @"%@", __resource];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateResource_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMUpdateResource_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateResource_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateResource_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceData_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceData_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSData *) success;
- (void) setSuccess: (NSData *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceData_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSData *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSData *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceByHash_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  NSData * __contentHash;
  BOOL __withData;
  BOOL __withRecognition;
  BOOL __withAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __contentHash_isset;
  BOOL __withData_isset;
  BOOL __withRecognition_isset;
  BOOL __withAlternateData_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, retain, getter=contentHash, setter=setContentHash:) NSData * contentHash;
@property (nonatomic, getter=withData, setter=setWithData:) BOOL withData;
@property (nonatomic, getter=withRecognition, setter=setWithRecognition:) BOOL withRecognition;
@property (nonatomic, getter=withAlternateData, setter=setWithAlternateData:) BOOL withAlternateData;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;
- (BOOL) noteGuidIsSet;

- (NSData *) contentHash;
- (void) setContentHash: (NSData *) contentHash;
- (BOOL) contentHashIsSet;

- (BOOL) withData;
- (void) setWithData: (BOOL) withData;
- (BOOL) withDataIsSet;

- (BOOL) withRecognition;
- (void) setWithRecognition: (BOOL) withRecognition;
- (BOOL) withRecognitionIsSet;

- (BOOL) withAlternateData;
- (void) setWithAlternateData: (BOOL) withAlternateData;
- (BOOL) withAlternateDataIsSet;

@end

@implementation EDAMgetResourceByHash_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic noteGuid;
@dynamic contentHash;
@dynamic withData;
@dynamic withRecognition;
@dynamic withAlternateData;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain];
  __noteGuid_isset = YES;
  __contentHash = [contentHash retain];
  __contentHash_isset = YES;
  __withData = withData;
  __withData_isset = YES;
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"contentHash"])
  {
    __contentHash = [[decoder decodeObjectForKey: @"contentHash"] retain];
    __contentHash_isset = YES;
  }
  if ([decoder containsValueForKey: @"withData"])
  {
    __withData = [decoder decodeBoolForKey: @"withData"];
    __withData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withRecognition"])
  {
    __withRecognition = [decoder decodeBoolForKey: @"withRecognition"];
    __withRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAlternateData"])
  {
    __withAlternateData = [decoder decodeBoolForKey: @"withAlternateData"];
    __withAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__contentHash_isset)
  {
    [encoder encodeObject: __contentHash forKey: @"contentHash"];
  }
  if (__withData_isset)
  {
    [encoder encodeBool: __withData forKey: @"withData"];
  }
  if (__withRecognition_isset)
  {
    [encoder encodeBool: __withRecognition forKey: @"withRecognition"];
  }
  if (__withAlternateData_isset)
  {
    [encoder encodeBool: __withAlternateData forKey: @"withAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuid release];
  [__contentHash release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain] autorelease];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain];
  [__noteGuid release];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (NSData *) contentHash {
  return [[__contentHash retain] autorelease];
}

- (void) setContentHash: (NSData *) contentHash {
  [contentHash retain];
  [__contentHash release];
  __contentHash = contentHash;
  __contentHash_isset = YES;
}

- (BOOL) contentHashIsSet {
  return __contentHash_isset;
}

- (void) unsetContentHash {
  [__contentHash release];
  __contentHash = nil;
  __contentHash_isset = NO;
}

- (BOOL) withData {
  return __withData;
}

- (void) setWithData: (BOOL) withData {
  __withData = withData;
  __withData_isset = YES;
}

- (BOOL) withDataIsSet {
  return __withData_isset;
}

- (void) unsetWithData {
  __withData_isset = NO;
}

- (BOOL) withRecognition {
  return __withRecognition;
}

- (void) setWithRecognition: (BOOL) withRecognition {
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
}

- (BOOL) withRecognitionIsSet {
  return __withRecognition_isset;
}

- (void) unsetWithRecognition {
  __withRecognition_isset = NO;
}

- (BOOL) withAlternateData {
  return __withAlternateData;
}

- (void) setWithAlternateData: (BOOL) withAlternateData {
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
}

- (BOOL) withAlternateDataIsSet {
  return __withAlternateData_isset;
}

- (void) unsetWithAlternateData {
  __withAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setContentHash: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceByHash_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__contentHash_isset) {
    if (__contentHash != nil) {
      [outProtocol writeFieldBeginWithName: @"contentHash" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __contentHash];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withData_isset) {
    [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withData];
    [outProtocol writeFieldEnd];
  }
  if (__withRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceByHash_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",contentHash:"];
  [ms appendFormat: @"\"%@\"", __contentHash];
  [ms appendString: @",withData:"];
  [ms appendFormat: @"%i", __withData];
  [ms appendString: @",withRecognition:"];
  [ms appendFormat: @"%i", __withRecognition];
  [ms appendString: @",withAlternateData:"];
  [ms appendFormat: @"%i", __withAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceByHash_result : NSObject <NSCoding> {
  EDAMResource * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMResource * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMResource *) success;
- (void) setSuccess: (EDAMResource *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceByHash_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMResource *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMResource *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceByHash_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceByHash_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceRecognition_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceRecognition_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceRecognition_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceRecognition_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceRecognition_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSData *) success;
- (void) setSuccess: (NSData *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceRecognition_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSData *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSData *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceRecognition_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceRecognition_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceAlternateData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceAlternateData_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceAlternateData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceAlternateData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceAlternateData_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSData *) success;
- (void) setSuccess: (NSData *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceAlternateData_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSData *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSData *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceAlternateData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceAlternateData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceAttributes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;
- (BOOL) guidIsSet;

@end

@implementation EDAMgetResourceAttributes_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic guid;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceAttributes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceAttributes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceAttributes_result : NSObject <NSCoding> {
  EDAMResourceAttributes * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMResourceAttributes * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMResourceAttributes *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMResourceAttributes *) success;
- (void) setSuccess: (EDAMResourceAttributes *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetResourceAttributes_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMResourceAttributes *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMResourceAttributes *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMResourceAttributes *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResourceAttributes *fieldValue = [[EDAMResourceAttributes alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceAttributes_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceAttributes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetAccountSize_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMgetAccountSize_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAccountSize_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAccountSize_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetAccountSize_result : NSObject <NSCoding> {
  int64_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int64_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (int64_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int64_t) success;
- (void) setSuccess: (int64_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetAccountSize_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (int64_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt64ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt64: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (int64_t) success {
  return __success;
}

- (void) setSuccess: (int64_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAccountSize_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I64 fieldID: 0];
    [outProtocol writeI64: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAccountSize_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%qi", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetAds_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMAdParameters * __adParameters;

  BOOL __authenticationToken_isset;
  BOOL __adParameters_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=adParameters, setter=setAdParameters:) EDAMAdParameters * adParameters;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMAdParameters *) adParameters;
- (void) setAdParameters: (EDAMAdParameters *) adParameters;
- (BOOL) adParametersIsSet;

@end

@implementation EDAMgetAds_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic adParameters;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __adParameters = [adParameters retain];
  __adParameters_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"adParameters"])
  {
    __adParameters = [[decoder decodeObjectForKey: @"adParameters"] retain];
    __adParameters_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__adParameters_isset)
  {
    [encoder encodeObject: __adParameters forKey: @"adParameters"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__adParameters release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMAdParameters *) adParameters {
  return [[__adParameters retain] autorelease];
}

- (void) setAdParameters: (EDAMAdParameters *) adParameters {
  [adParameters retain];
  [__adParameters release];
  __adParameters = adParameters;
  __adParameters_isset = YES;
}

- (BOOL) adParametersIsSet {
  return __adParameters_isset;
}

- (void) unsetAdParameters {
  [__adParameters release];
  __adParameters = nil;
  __adParameters_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMAdParameters *fieldValue = [[EDAMAdParameters alloc] init];
          [fieldValue read: inProtocol];
          [self setAdParameters: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAds_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__adParameters_isset) {
    if (__adParameters != nil) {
      [outProtocol writeFieldBeginWithName: @"adParameters" type: TType_STRUCT fieldID: 2];
      [__adParameters write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAds_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",adParameters:"];
  [ms appendFormat: @"%@", __adParameters];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetAds_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetAds_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size133;
          [inProtocol readListBeginReturningElementType: NULL size: &_size133];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size133];
          int _i134;
          for (_i134 = 0; _i134 < _size133; ++_i134)
          {
            EDAMAd *_elem135 = [[EDAMAd alloc] init];
            [_elem135 read: inProtocol];
            [fieldValue addObject: _elem135];
            [_elem135 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAds_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        NSUInteger i137;
        for (i137 = 0; i137 < [__success count]; i137++)
        {
          [[__success objectAtIndex: i137] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAds_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetRandomAd_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMAdParameters * __adParameters;

  BOOL __authenticationToken_isset;
  BOOL __adParameters_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=adParameters, setter=setAdParameters:) EDAMAdParameters * adParameters;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMAdParameters *) adParameters;
- (void) setAdParameters: (EDAMAdParameters *) adParameters;
- (BOOL) adParametersIsSet;

@end

@implementation EDAMgetRandomAd_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic adParameters;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __adParameters = [adParameters retain];
  __adParameters_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"adParameters"])
  {
    __adParameters = [[decoder decodeObjectForKey: @"adParameters"] retain];
    __adParameters_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__adParameters_isset)
  {
    [encoder encodeObject: __adParameters forKey: @"adParameters"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__adParameters release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMAdParameters *) adParameters {
  return [[__adParameters retain] autorelease];
}

- (void) setAdParameters: (EDAMAdParameters *) adParameters {
  [adParameters retain];
  [__adParameters release];
  __adParameters = adParameters;
  __adParameters_isset = YES;
}

- (BOOL) adParametersIsSet {
  return __adParameters_isset;
}

- (void) unsetAdParameters {
  [__adParameters release];
  __adParameters = nil;
  __adParameters_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMAdParameters *fieldValue = [[EDAMAdParameters alloc] init];
          [fieldValue read: inProtocol];
          [self setAdParameters: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getRandomAd_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__adParameters_isset) {
    if (__adParameters != nil) {
      [outProtocol writeFieldBeginWithName: @"adParameters" type: TType_STRUCT fieldID: 2];
      [__adParameters write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getRandomAd_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",adParameters:"];
  [ms appendFormat: @"%@", __adParameters];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetRandomAd_result : NSObject <NSCoding> {
  EDAMAd * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMAd * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMAd *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMAd *) success;
- (void) setSuccess: (EDAMAd *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetRandomAd_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMAd *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMAd *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMAd *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMAd *fieldValue = [[EDAMAd alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetRandomAd_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetRandomAd_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetPublicNotebook_args : NSObject <NSCoding> {
  EDAMUserID __userId;
  NSString * __publicUri;

  BOOL __userId_isset;
  BOOL __publicUri_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=userId, setter=setUserId:) EDAMUserID userId;
@property (nonatomic, retain, getter=publicUri, setter=setPublicUri:) NSString * publicUri;
#endif

- (id) initWithUserId: (EDAMUserID) userId publicUri: (NSString *) publicUri;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMUserID) userId;
- (void) setUserId: (EDAMUserID) userId;
- (BOOL) userIdIsSet;

- (NSString *) publicUri;
- (void) setPublicUri: (NSString *) publicUri;
- (BOOL) publicUriIsSet;

@end

@implementation EDAMgetPublicNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic userId;
@dynamic publicUri;
#endif

- (id) initWithUserId: (EDAMUserID) userId publicUri: (NSString *) publicUri
{
  self = [super init];
  __userId = userId;
  __userId_isset = YES;
  __publicUri = [publicUri retain];
  __publicUri_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userId"])
  {
    __userId = [decoder decodeInt32ForKey: @"userId"];
    __userId_isset = YES;
  }
  if ([decoder containsValueForKey: @"publicUri"])
  {
    __publicUri = [[decoder decodeObjectForKey: @"publicUri"] retain];
    __publicUri_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userId_isset)
  {
    [encoder encodeInt32: __userId forKey: @"userId"];
  }
  if (__publicUri_isset)
  {
    [encoder encodeObject: __publicUri forKey: @"publicUri"];
  }
}

- (void) dealloc
{
  [__publicUri release];
  [super dealloc];
}

- (int32_t) userId {
  return __userId;
}

- (void) setUserId: (int32_t) userId {
  __userId = userId;
  __userId_isset = YES;
}

- (BOOL) userIdIsSet {
  return __userId_isset;
}

- (void) unsetUserId {
  __userId_isset = NO;
}

- (NSString *) publicUri {
  return [[__publicUri retain] autorelease];
}

- (void) setPublicUri: (NSString *) publicUri {
  [publicUri retain];
  [__publicUri release];
  __publicUri = publicUri;
  __publicUri_isset = YES;
}

- (BOOL) publicUriIsSet {
  return __publicUri_isset;
}

- (void) unsetPublicUri {
  [__publicUri release];
  __publicUri = nil;
  __publicUri_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUserId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPublicUri: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getPublicNotebook_args"];
  if (__userId_isset) {
    [outProtocol writeFieldBeginWithName: @"userId" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __userId];
    [outProtocol writeFieldEnd];
  }
  if (__publicUri_isset) {
    if (__publicUri != nil) {
      [outProtocol writeFieldBeginWithName: @"publicUri" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __publicUri];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getPublicNotebook_args("];
  [ms appendString: @"userId:"];
  [ms appendFormat: @"%i", __userId];
  [ms appendString: @",publicUri:"];
  [ms appendFormat: @"\"%@\"", __publicUri];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetPublicNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#endif

- (id) initWithSuccess: (EDAMNotebook *) success systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;
- (BOOL) successIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

@end

@implementation EDAMGetPublicNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic systemException;
@dynamic notFoundException;
#endif

- (id) initWithSuccess: (EDAMNotebook *) success systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetPublicNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 1];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetPublicNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateSharedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSharedNotebook * __sharedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __sharedNotebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=sharedNotebook, setter=setSharedNotebook:) EDAMSharedNotebook * sharedNotebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMSharedNotebook *) sharedNotebook;
- (void) setSharedNotebook: (EDAMSharedNotebook *) sharedNotebook;
- (BOOL) sharedNotebookIsSet;

@end

@implementation EDAMcreateSharedNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic sharedNotebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __sharedNotebook = [sharedNotebook retain];
  __sharedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"sharedNotebook"])
  {
    __sharedNotebook = [[decoder decodeObjectForKey: @"sharedNotebook"] retain];
    __sharedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__sharedNotebook_isset)
  {
    [encoder encodeObject: __sharedNotebook forKey: @"sharedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__sharedNotebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSharedNotebook *) sharedNotebook {
  return [[__sharedNotebook retain] autorelease];
}

- (void) setSharedNotebook: (EDAMSharedNotebook *) sharedNotebook {
  [sharedNotebook retain];
  [__sharedNotebook release];
  __sharedNotebook = sharedNotebook;
  __sharedNotebook_isset = YES;
}

- (BOOL) sharedNotebookIsSet {
  return __sharedNotebook_isset;
}

- (void) unsetSharedNotebook {
  [__sharedNotebook release];
  __sharedNotebook = nil;
  __sharedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSharedNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createSharedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sharedNotebook_isset) {
    if (__sharedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"sharedNotebook" type: TType_STRUCT fieldID: 2];
      [__sharedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createSharedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",sharedNotebook:"];
  [ms appendFormat: @"%@", __sharedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateSharedNotebook_result : NSObject <NSCoding> {
  EDAMSharedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSharedNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMSharedNotebook *) success;
- (void) setSuccess: (EDAMSharedNotebook *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMCreateSharedNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSharedNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSharedNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateSharedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateSharedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistSharedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistSharedNotebooks_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listSharedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listSharedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListSharedNotebooks_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListSharedNotebooks_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size138;
          [inProtocol readListBeginReturningElementType: NULL size: &_size138];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size138];
          int _i139;
          for (_i139 = 0; _i139 < _size138; ++_i139)
          {
            EDAMSharedNotebook *_elem140 = [[EDAMSharedNotebook alloc] init];
            [_elem140 read: inProtocol];
            [fieldValue addObject: _elem140];
            [_elem140 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListSharedNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        NSUInteger i142;
        for (i142 = 0; i142 < [__success count]; i142++)
        {
          [[__success objectAtIndex: i142] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListSharedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeSharedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  NSArray * __sharedNotebookIds;

  BOOL __authenticationToken_isset;
  BOOL __sharedNotebookIds_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=sharedNotebookIds, setter=setSharedNotebookIds:) NSArray * sharedNotebookIds;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebookIds: (NSArray *) sharedNotebookIds;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (NSArray *) sharedNotebookIds;
- (void) setSharedNotebookIds: (NSArray *) sharedNotebookIds;
- (BOOL) sharedNotebookIdsIsSet;

@end

@implementation EDAMexpungeSharedNotebooks_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic sharedNotebookIds;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebookIds: (NSArray *) sharedNotebookIds
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __sharedNotebookIds = [sharedNotebookIds retain];
  __sharedNotebookIds_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"sharedNotebookIds"])
  {
    __sharedNotebookIds = [[decoder decodeObjectForKey: @"sharedNotebookIds"] retain];
    __sharedNotebookIds_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__sharedNotebookIds_isset)
  {
    [encoder encodeObject: __sharedNotebookIds forKey: @"sharedNotebookIds"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__sharedNotebookIds release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSArray *) sharedNotebookIds {
  return [[__sharedNotebookIds retain] autorelease];
}

- (void) setSharedNotebookIds: (NSArray *) sharedNotebookIds {
  [sharedNotebookIds retain];
  [__sharedNotebookIds release];
  __sharedNotebookIds = sharedNotebookIds;
  __sharedNotebookIds_isset = YES;
}

- (BOOL) sharedNotebookIdsIsSet {
  return __sharedNotebookIds_isset;
}

- (void) unsetSharedNotebookIds {
  [__sharedNotebookIds release];
  __sharedNotebookIds = nil;
  __sharedNotebookIds_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size143;
          [inProtocol readListBeginReturningElementType: NULL size: &_size143];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size143];
          int _i144;
          for (_i144 = 0; _i144 < _size143; ++_i144)
          {
            int64_t _elem145 = [inProtocol readI64];
            [fieldValue addObject: [NSNumber numberWithLongLong: _elem145]];
          }
          [inProtocol readListEnd];
          [self setSharedNotebookIds: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeSharedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sharedNotebookIds_isset) {
    if (__sharedNotebookIds != nil) {
      [outProtocol writeFieldBeginWithName: @"sharedNotebookIds" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_I64 size: [__sharedNotebookIds count]];
        NSUInteger i147;
        for (i147 = 0; i147 < [__sharedNotebookIds count]; i147++)
        {
          [outProtocol writeI64: [[__sharedNotebookIds objectAtIndex: i147] longLongValue]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeSharedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",sharedNotebookIds:"];
  [ms appendFormat: @"%@", __sharedNotebookIds];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeSharedNotebooks_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMExpungeSharedNotebooks_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeSharedNotebooks_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeSharedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;
- (BOOL) linkedNotebookIsSet;

@end

@implementation EDAMcreateLinkedNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic linkedNotebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain];
  __linkedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain];
    __linkedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__linkedNotebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain] autorelease];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain];
  [__linkedNotebook release];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateLinkedNotebook_result : NSObject <NSCoding> {
  EDAMLinkedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMLinkedNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMLinkedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMLinkedNotebook *) success;
- (void) setSuccess: (EDAMLinkedNotebook *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMCreateLinkedNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMLinkedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMLinkedNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMLinkedNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateLinkedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;
- (BOOL) linkedNotebookIsSet;

@end

@implementation EDAMupdateLinkedNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic linkedNotebook;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain];
  __linkedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain];
    __linkedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__linkedNotebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain] autorelease];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain];
  [__linkedNotebook release];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateLinkedNotebook_result : NSObject <NSCoding> {
  EDAMLinkedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMLinkedNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMLinkedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMLinkedNotebook *) success;
- (void) setSuccess: (EDAMLinkedNotebook *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMUpdateLinkedNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMLinkedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMLinkedNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMLinkedNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateLinkedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistLinkedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMlistLinkedNotebooks_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listLinkedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listLinkedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListLinkedNotebooks_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMListLinkedNotebooks_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size148;
          [inProtocol readListBeginReturningElementType: NULL size: &_size148];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size148];
          int _i149;
          for (_i149 = 0; _i149 < _size148; ++_i149)
          {
            EDAMLinkedNotebook *_elem150 = [[EDAMLinkedNotebook alloc] init];
            [_elem150 read: inProtocol];
            [fieldValue addObject: _elem150];
            [_elem150 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListLinkedNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        NSUInteger i152;
        for (i152 = 0; i152 < [__success count]; i152++)
        {
          [[__success objectAtIndex: i152] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListLinkedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  int64_t __linkedNotebookId;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebookId_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, getter=linkedNotebookId, setter=setLinkedNotebookId:) int64_t linkedNotebookId;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebookId: (int64_t) linkedNotebookId;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (int64_t) linkedNotebookId;
- (void) setLinkedNotebookId: (int64_t) linkedNotebookId;
- (BOOL) linkedNotebookIdIsSet;

@end

@implementation EDAMexpungeLinkedNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic linkedNotebookId;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebookId: (int64_t) linkedNotebookId
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __linkedNotebookId = linkedNotebookId;
  __linkedNotebookId_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebookId"])
  {
    __linkedNotebookId = [decoder decodeInt64ForKey: @"linkedNotebookId"];
    __linkedNotebookId_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebookId_isset)
  {
    [encoder encodeInt64: __linkedNotebookId forKey: @"linkedNotebookId"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (int64_t) linkedNotebookId {
  return __linkedNotebookId;
}

- (void) setLinkedNotebookId: (int64_t) linkedNotebookId {
  __linkedNotebookId = linkedNotebookId;
  __linkedNotebookId_isset = YES;
}

- (BOOL) linkedNotebookIdIsSet {
  return __linkedNotebookId_isset;
}

- (void) unsetLinkedNotebookId {
  __linkedNotebookId_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setLinkedNotebookId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebookId_isset) {
    [outProtocol writeFieldBeginWithName: @"linkedNotebookId" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __linkedNotebookId];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebookId:"];
  [ms appendFormat: @"%qi", __linkedNotebookId];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeLinkedNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (int32_t) success;
- (void) setSuccess: (int32_t) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMExpungeLinkedNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeLinkedNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMauthenticateToSharedNotebook_args : NSObject <NSCoding> {
  NSString * __shareKey;
  NSString * __authenticationToken;

  BOOL __shareKey_isset;
  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=shareKey, setter=setShareKey:) NSString * shareKey;
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithShareKey: (NSString *) shareKey authenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) shareKey;
- (void) setShareKey: (NSString *) shareKey;
- (BOOL) shareKeyIsSet;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMauthenticateToSharedNotebook_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic shareKey;
@dynamic authenticationToken;
#endif

- (id) initWithShareKey: (NSString *) shareKey authenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __shareKey = [shareKey retain];
  __shareKey_isset = YES;
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"shareKey"])
  {
    __shareKey = [[decoder decodeObjectForKey: @"shareKey"] retain];
    __shareKey_isset = YES;
  }
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__shareKey_isset)
  {
    [encoder encodeObject: __shareKey forKey: @"shareKey"];
  }
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__shareKey release];
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) shareKey {
  return [[__shareKey retain] autorelease];
}

- (void) setShareKey: (NSString *) shareKey {
  [shareKey retain];
  [__shareKey release];
  __shareKey = shareKey;
  __shareKey_isset = YES;
}

- (BOOL) shareKeyIsSet {
  return __shareKey_isset;
}

- (void) unsetShareKey {
  [__shareKey release];
  __shareKey = nil;
  __shareKey_isset = NO;
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setShareKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNotebook_args"];
  if (__shareKey_isset) {
    if (__shareKey != nil) {
      [outProtocol writeFieldBeginWithName: @"shareKey" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __shareKey];
      [outProtocol writeFieldEnd];
    }
  }
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"authenticateToSharedNotebook_args("];
  [ms appendString: @"shareKey:"];
  [ms appendFormat: @"\"%@\"", __shareKey];
  [ms appendString: @",authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMAuthenticateToSharedNotebook_result : NSObject <NSCoding> {
  EDAMAuthenticationResult * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMAuthenticationResult * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMAuthenticationResult *) success;
- (void) setSuccess: (EDAMAuthenticationResult *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMAuthenticateToSharedNotebook_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMAuthenticationResult *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMAuthenticationResult *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMAuthenticationResult *fieldValue = [[EDAMAuthenticationResult alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AuthenticateToSharedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AuthenticateToSharedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSharedNotebookByAuth_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

@end

@implementation EDAMgetSharedNotebookByAuth_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSharedNotebookByAuth_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSharedNotebookByAuth_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSharedNotebookByAuth_result : NSObject <NSCoding> {
  EDAMSharedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSharedNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMSharedNotebook *) success;
- (void) setSuccess: (EDAMSharedNotebook *) success;
- (BOOL) successIsSet;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMGetSharedNotebookByAuth_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic success;
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSharedNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSharedNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSharedNotebookByAuth_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSharedNotebookByAuth_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMemailNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteEmailParameters * __parameters;

  BOOL __authenticationToken_isset;
  BOOL __parameters_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=parameters, setter=setParameters:) EDAMNoteEmailParameters * parameters;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;
- (BOOL) authenticationTokenIsSet;

- (EDAMNoteEmailParameters *) parameters;
- (void) setParameters: (EDAMNoteEmailParameters *) parameters;
- (BOOL) parametersIsSet;

@end

@implementation EDAMemailNote_args

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic authenticationToken;
@dynamic parameters;
#endif

- (id) initWithAuthenticationToken: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __parameters = [parameters retain];
  __parameters_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"parameters"])
  {
    __parameters = [[decoder decodeObjectForKey: @"parameters"] retain];
    __parameters_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__parameters_isset)
  {
    [encoder encodeObject: __parameters forKey: @"parameters"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__parameters release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteEmailParameters *) parameters {
  return [[__parameters retain] autorelease];
}

- (void) setParameters: (EDAMNoteEmailParameters *) parameters {
  [parameters retain];
  [__parameters release];
  __parameters = parameters;
  __parameters_isset = YES;
}

- (BOOL) parametersIsSet {
  return __parameters_isset;
}

- (void) unsetParameters {
  [__parameters release];
  __parameters = nil;
  __parameters_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteEmailParameters *fieldValue = [[EDAMNoteEmailParameters alloc] init];
          [fieldValue read: inProtocol];
          [self setParameters: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"emailNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__parameters_isset) {
    if (__parameters != nil) {
      [outProtocol writeFieldBeginWithName: @"parameters" type: TType_STRUCT fieldID: 2];
      [__parameters write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"emailNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",parameters:"];
  [ms appendFormat: @"%@", __parameters];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMEmailNote_result : NSObject <NSCoding> {
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#endif

- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;
- (BOOL) userExceptionIsSet;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;
- (BOOL) notFoundExceptionIsSet;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;
- (BOOL) systemExceptionIsSet;

@end

@implementation EDAMEmailNote_result

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@dynamic userException;
@dynamic notFoundException;
@dynamic systemException;
#endif

- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"EmailNote_result"];

  if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"EmailNote_result("];
  [ms appendString: @"userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteStoreClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  if (self) {
      inProtocol = [anInProtocol retain];
      outProtocol = [anOutProtocol retain];
  }  
  return self;
}

- (void) dealloc
{
  [inProtocol release];
  [outProtocol release];
  [super dealloc];
}

- (void) send_getSyncState: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getSyncState" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSyncState_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncState *) recv_getSyncState
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSyncState_result * result = [[[EDAMGetSyncState_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSyncState failed: unknown result"];
}

- (EDAMSyncState *) getSyncState: (NSString *) authenticationToken
{
  [self send_getSyncState: authenticationToken];
  return [self recv_getSyncState];
}

- (void) send_getSyncChunk: (NSString *) authenticationToken : (int32_t) afterUSN : (int32_t) maxEntries : (BOOL) fullSyncOnly
{
  [outProtocol writeMessageBeginWithName: @"getSyncChunk" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSyncChunk_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: afterUSN];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: maxEntries];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: fullSyncOnly];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncChunk *) recv_getSyncChunk
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSyncChunk_result * result = [[[EDAMGetSyncChunk_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSyncChunk failed: unknown result"];
}

- (EDAMSyncChunk *) getSyncChunk: (NSString *) authenticationToken : (int32_t) afterUSN : (int32_t) maxEntries : (BOOL) fullSyncOnly
{
  [self send_getSyncChunk: authenticationToken : afterUSN : maxEntries : fullSyncOnly];
  return [self recv_getSyncChunk];
}

- (void) send_listNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListNotebooks_result * result = [[[EDAMListNotebooks_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listNotebooks failed: unknown result"];
}

- (NSArray *) listNotebooks: (NSString *) authenticationToken
{
  [self send_listNotebooks: authenticationToken];
  return [self recv_listNotebooks];
}

- (void) send_getNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNotebook_result * result = [[[EDAMGetNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNotebook failed: unknown result"];
}

- (EDAMNotebook *) getNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getNotebook: authenticationToken : guid];
  return [self recv_getNotebook];
}

- (void) send_getDefaultNotebook: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getDefaultNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getDefaultNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getDefaultNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetDefaultNotebook_result * result = [[[EDAMGetDefaultNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getDefaultNotebook failed: unknown result"];
}

- (EDAMNotebook *) getDefaultNotebook: (NSString *) authenticationToken
{
  [self send_getDefaultNotebook: authenticationToken];
  return [self recv_getDefaultNotebook];
}

- (void) send_createNotebook: (NSString *) authenticationToken : (EDAMNotebook *) notebook
{
  [outProtocol writeMessageBeginWithName: @"createNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
    [notebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_createNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateNotebook_result * result = [[[EDAMCreateNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createNotebook failed: unknown result"];
}

- (EDAMNotebook *) createNotebook: (NSString *) authenticationToken : (EDAMNotebook *) notebook
{
  [self send_createNotebook: authenticationToken : notebook];
  return [self recv_createNotebook];
}

- (void) send_updateNotebook: (NSString *) authenticationToken : (EDAMNotebook *) notebook
{
  [outProtocol writeMessageBeginWithName: @"updateNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
    [notebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateNotebook_result * result = [[[EDAMUpdateNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateNotebook failed: unknown result"];
}

- (int32_t) updateNotebook: (NSString *) authenticationToken : (EDAMNotebook *) notebook
{
  [self send_updateNotebook: authenticationToken : notebook];
  return [self recv_updateNotebook];
}

- (void) send_expungeNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNotebook_result * result = [[[EDAMExpungeNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNotebook failed: unknown result"];
}

- (int32_t) expungeNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeNotebook: authenticationToken : guid];
  return [self recv_expungeNotebook];
}

- (void) send_listTags: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listTags" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listTags_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listTags
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListTags_result * result = [[[EDAMListTags_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listTags failed: unknown result"];
}

- (NSArray *) listTags: (NSString *) authenticationToken
{
  [self send_listTags: authenticationToken];
  return [self recv_listTags];
}

- (void) send_listTagsByNotebook: (NSString *) authenticationToken : (EDAMGuid) notebookGuid
{
  [outProtocol writeMessageBeginWithName: @"listTagsByNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listTagsByNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebookGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: notebookGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listTagsByNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListTagsByNotebook_result * result = [[[EDAMListTagsByNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listTagsByNotebook failed: unknown result"];
}

- (NSArray *) listTagsByNotebook: (NSString *) authenticationToken : (EDAMGuid) notebookGuid
{
  [self send_listTagsByNotebook: authenticationToken : notebookGuid];
  return [self recv_listTagsByNotebook];
}

- (void) send_getTag: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMTag *) recv_getTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetTag_result * result = [[[EDAMGetTag_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getTag failed: unknown result"];
}

- (EDAMTag *) getTag: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getTag: authenticationToken : guid];
  return [self recv_getTag];
}

- (void) send_createTag: (NSString *) authenticationToken : (EDAMTag *) tag
{
  [outProtocol writeMessageBeginWithName: @"createTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (tag != nil)  {
    [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
    [tag write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMTag *) recv_createTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateTag_result * result = [[[EDAMCreateTag_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createTag failed: unknown result"];
}

- (EDAMTag *) createTag: (NSString *) authenticationToken : (EDAMTag *) tag
{
  [self send_createTag: authenticationToken : tag];
  return [self recv_createTag];
}

- (void) send_updateTag: (NSString *) authenticationToken : (EDAMTag *) tag
{
  [outProtocol writeMessageBeginWithName: @"updateTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (tag != nil)  {
    [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
    [tag write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateTag_result * result = [[[EDAMUpdateTag_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateTag failed: unknown result"];
}

- (int32_t) updateTag: (NSString *) authenticationToken : (EDAMTag *) tag
{
  [self send_updateTag: authenticationToken : tag];
  return [self recv_updateTag];
}

- (void) send_untagAll: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"untagAll" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"untagAll_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_untagAll
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUntagAll_result * result = [[[EDAMUntagAll_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  return;
}

- (void) untagAll: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_untagAll: authenticationToken : guid];
  [self recv_untagAll];
}

- (void) send_expungeTag: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeTag_result * result = [[[EDAMExpungeTag_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeTag failed: unknown result"];
}

- (int32_t) expungeTag: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeTag: authenticationToken : guid];
  return [self recv_expungeTag];
}

- (void) send_listSearches: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listSearches" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listSearches_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listSearches
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListSearches_result * result = [[[EDAMListSearches_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listSearches failed: unknown result"];
}

- (NSArray *) listSearches: (NSString *) authenticationToken
{
  [self send_listSearches: authenticationToken];
  return [self recv_listSearches];
}

- (void) send_getSearch: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSavedSearch *) recv_getSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSearch_result * result = [[[EDAMGetSearch_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSearch failed: unknown result"];
}

- (EDAMSavedSearch *) getSearch: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getSearch: authenticationToken : guid];
  return [self recv_getSearch];
}

- (void) send_createSearch: (NSString *) authenticationToken : (EDAMSavedSearch *) search
{
  [outProtocol writeMessageBeginWithName: @"createSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (search != nil)  {
    [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
    [search write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSavedSearch *) recv_createSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateSearch_result * result = [[[EDAMCreateSearch_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createSearch failed: unknown result"];
}

- (EDAMSavedSearch *) createSearch: (NSString *) authenticationToken : (EDAMSavedSearch *) search
{
  [self send_createSearch: authenticationToken : search];
  return [self recv_createSearch];
}

- (void) send_updateSearch: (NSString *) authenticationToken : (EDAMSavedSearch *) search
{
  [outProtocol writeMessageBeginWithName: @"updateSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (search != nil)  {
    [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
    [search write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateSearch_result * result = [[[EDAMUpdateSearch_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateSearch failed: unknown result"];
}

- (int32_t) updateSearch: (NSString *) authenticationToken : (EDAMSavedSearch *) search
{
  [self send_updateSearch: authenticationToken : search];
  return [self recv_updateSearch];
}

- (void) send_expungeSearch: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeSearch_result * result = [[[EDAMExpungeSearch_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeSearch failed: unknown result"];
}

- (int32_t) expungeSearch: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeSearch: authenticationToken : guid];
  return [self recv_expungeSearch];
}

- (void) send_findNotes: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (int32_t) offset : (int32_t) maxNotes
{
  [outProtocol writeMessageBeginWithName: @"findNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: offset];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
  [outProtocol writeI32: maxNotes];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNoteList *) recv_findNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNotes_result * result = [[[EDAMFindNotes_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNotes failed: unknown result"];
}

- (EDAMNoteList *) findNotes: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (int32_t) offset : (int32_t) maxNotes
{
  [self send_findNotes: authenticationToken : filter : offset : maxNotes];
  return [self recv_findNotes];
}

- (void) send_findNoteCounts: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (BOOL) withTrash
{
  [outProtocol writeMessageBeginWithName: @"findNoteCounts" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNoteCounts_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withTrash" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withTrash];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNoteCollectionCounts *) recv_findNoteCounts
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNoteCounts_result * result = [[[EDAMFindNoteCounts_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNoteCounts failed: unknown result"];
}

- (EDAMNoteCollectionCounts *) findNoteCounts: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (BOOL) withTrash
{
  [self send_findNoteCounts: authenticationToken : filter : withTrash];
  return [self recv_findNoteCounts];
}

- (void) send_getNote: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) withContent : (BOOL) withResourcesData : (BOOL) withResourcesRecognition : (BOOL) withResourcesAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withContent" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withContent];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withResourcesData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withResourcesRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withResourcesAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_getNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNote_result * result = [[[EDAMGetNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNote failed: unknown result"];
}

- (EDAMNote *) getNote: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) withContent : (BOOL) withResourcesData : (BOOL) withResourcesRecognition : (BOOL) withResourcesAlternateData
{
  [self send_getNote: authenticationToken : guid : withContent : withResourcesData : withResourcesRecognition : withResourcesAlternateData];
  return [self recv_getNote];
}

- (void) send_getNoteContent: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteContent" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteContent_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNoteContent
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteContent_result * result = [[[EDAMGetNoteContent_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteContent failed: unknown result"];
}

- (NSString *) getNoteContent: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getNoteContent: authenticationToken : guid];
  return [self recv_getNoteContent];
}

- (void) send_getNoteSearchText: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteSearchText" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteSearchText_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNoteSearchText
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteSearchText_result * result = [[[EDAMGetNoteSearchText_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteSearchText failed: unknown result"];
}

- (NSString *) getNoteSearchText: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getNoteSearchText: authenticationToken : guid];
  return [self recv_getNoteSearchText];
}

- (void) send_getNoteTagNames: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteTagNames" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteTagNames_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_getNoteTagNames
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteTagNames_result * result = [[[EDAMGetNoteTagNames_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteTagNames failed: unknown result"];
}

- (NSArray *) getNoteTagNames: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getNoteTagNames: authenticationToken : guid];
  return [self recv_getNoteTagNames];
}

- (void) send_createNote: (NSString *) authenticationToken : (EDAMNote *) note
{
  [outProtocol writeMessageBeginWithName: @"createNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (note != nil)  {
    [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
    [note write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_createNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateNote_result * result = [[[EDAMCreateNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createNote failed: unknown result"];
}

- (EDAMNote *) createNote: (NSString *) authenticationToken : (EDAMNote *) note
{
  [self send_createNote: authenticationToken : note];
  return [self recv_createNote];
}

- (void) send_updateNote: (NSString *) authenticationToken : (EDAMNote *) note
{
  [outProtocol writeMessageBeginWithName: @"updateNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (note != nil)  {
    [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
    [note write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_updateNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateNote_result * result = [[[EDAMUpdateNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateNote failed: unknown result"];
}

- (EDAMNote *) updateNote: (NSString *) authenticationToken : (EDAMNote *) note
{
  [self send_updateNote: authenticationToken : note];
  return [self recv_updateNote];
}

- (void) send_deleteNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"deleteNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"deleteNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_deleteNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMDeleteNote_result * result = [[[EDAMDeleteNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"deleteNote failed: unknown result"];
}

- (int32_t) deleteNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_deleteNote: authenticationToken : guid];
  return [self recv_deleteNote];
}

- (void) send_expungeNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNote_result * result = [[[EDAMExpungeNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNote failed: unknown result"];
}

- (int32_t) expungeNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeNote: authenticationToken : guid];
  return [self recv_expungeNote];
}

- (void) send_expungeNotes: (NSString *) authenticationToken : (NSArray *) noteGuids
{
  [outProtocol writeMessageBeginWithName: @"expungeNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuids != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuids" type: TType_LIST fieldID: 2];
    {
      [outProtocol writeListBeginWithElementType: TType_STRING size: [noteGuids count]];
      NSUInteger i154;
      for (i154 = 0; i154 < [noteGuids count]; i154++)
      {
        [outProtocol writeString: [noteGuids objectAtIndex: i154]];
      }
      [outProtocol writeListEnd];
    }
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNotes_result * result = [[[EDAMExpungeNotes_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNotes failed: unknown result"];
}

- (int32_t) expungeNotes: (NSString *) authenticationToken : (NSArray *) noteGuids
{
  [self send_expungeNotes: authenticationToken : noteGuids];
  return [self recv_expungeNotes];
}

- (void) send_expungeInactiveNotes: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"expungeInactiveNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeInactiveNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeInactiveNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeInactiveNotes_result * result = [[[EDAMExpungeInactiveNotes_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeInactiveNotes failed: unknown result"];
}

- (int32_t) expungeInactiveNotes: (NSString *) authenticationToken
{
  [self send_expungeInactiveNotes: authenticationToken];
  return [self recv_expungeInactiveNotes];
}

- (void) send_copyNote: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (EDAMGuid) toNotebookGuid
{
  [outProtocol writeMessageBeginWithName: @"copyNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"copyNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  if (toNotebookGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"toNotebookGuid" type: TType_STRING fieldID: 3];
    [outProtocol writeString: toNotebookGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_copyNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCopyNote_result * result = [[[EDAMCopyNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"copyNote failed: unknown result"];
}

- (EDAMNote *) copyNote: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (EDAMGuid) toNotebookGuid
{
  [self send_copyNote: authenticationToken : noteGuid : toNotebookGuid];
  return [self recv_copyNote];
}

- (void) send_listNoteVersions: (NSString *) authenticationToken : (EDAMGuid) noteGuid
{
  [outProtocol writeMessageBeginWithName: @"listNoteVersions" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listNoteVersions_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listNoteVersions
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListNoteVersions_result * result = [[[EDAMListNoteVersions_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listNoteVersions failed: unknown result"];
}

- (NSArray *) listNoteVersions: (NSString *) authenticationToken : (EDAMGuid) noteGuid
{
  [self send_listNoteVersions: authenticationToken : noteGuid];
  return [self recv_listNoteVersions];
}

- (void) send_getNoteVersion: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (int32_t) updateSequenceNum : (BOOL) withResourcesData : (BOOL) withResourcesRecognition : (BOOL) withResourcesAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getNoteVersion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteVersion_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: updateSequenceNum];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withResourcesData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withResourcesRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withResourcesAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_getNoteVersion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteVersion_result * result = [[[EDAMGetNoteVersion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteVersion failed: unknown result"];
}

- (EDAMNote *) getNoteVersion: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (int32_t) updateSequenceNum : (BOOL) withResourcesData : (BOOL) withResourcesRecognition : (BOOL) withResourcesAlternateData
{
  [self send_getNoteVersion: authenticationToken : noteGuid : updateSequenceNum : withResourcesData : withResourcesRecognition : withResourcesAlternateData];
  return [self recv_getNoteVersion];
}

- (void) send_getResource: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) withData : (BOOL) withRecognition : (BOOL) withAttributes : (BOOL) withAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getResource" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResource_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAttributes" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withAttributes];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResource *) recv_getResource
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResource_result * result = [[[EDAMGetResource_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResource failed: unknown result"];
}

- (EDAMResource *) getResource: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) withData : (BOOL) withRecognition : (BOOL) withAttributes : (BOOL) withAlternateData
{
  [self send_getResource: authenticationToken : guid : withData : withRecognition : withAttributes : withAlternateData];
  return [self recv_getResource];
}

- (void) send_updateResource: (NSString *) authenticationToken : (EDAMResource *) resource
{
  [outProtocol writeMessageBeginWithName: @"updateResource" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateResource_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (resource != nil)  {
    [outProtocol writeFieldBeginWithName: @"resource" type: TType_STRUCT fieldID: 2];
    [resource write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateResource
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateResource_result * result = [[[EDAMUpdateResource_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateResource failed: unknown result"];
}

- (int32_t) updateResource: (NSString *) authenticationToken : (EDAMResource *) resource
{
  [self send_updateResource: authenticationToken : resource];
  return [self recv_updateResource];
}

- (void) send_getResourceData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceData_result * result = [[[EDAMGetResourceData_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceData failed: unknown result"];
}

- (NSData *) getResourceData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceData: authenticationToken : guid];
  return [self recv_getResourceData];
}

- (void) send_getResourceByHash: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (NSData *) contentHash : (BOOL) withData : (BOOL) withRecognition : (BOOL) withAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getResourceByHash" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceByHash_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  if (contentHash != nil)  {
    [outProtocol writeFieldBeginWithName: @"contentHash" type: TType_STRING fieldID: 3];
    [outProtocol writeBinary: contentHash];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResource *) recv_getResourceByHash
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceByHash_result * result = [[[EDAMGetResourceByHash_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceByHash failed: unknown result"];
}

- (EDAMResource *) getResourceByHash: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (NSData *) contentHash : (BOOL) withData : (BOOL) withRecognition : (BOOL) withAlternateData
{
  [self send_getResourceByHash: authenticationToken : noteGuid : contentHash : withData : withRecognition : withAlternateData];
  return [self recv_getResourceByHash];
}

- (void) send_getResourceRecognition: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceRecognition" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceRecognition_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceRecognition
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceRecognition_result * result = [[[EDAMGetResourceRecognition_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceRecognition failed: unknown result"];
}

- (NSData *) getResourceRecognition: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceRecognition: authenticationToken : guid];
  return [self recv_getResourceRecognition];
}

- (void) send_getResourceAlternateData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceAlternateData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceAlternateData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceAlternateData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceAlternateData_result * result = [[[EDAMGetResourceAlternateData_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceAlternateData failed: unknown result"];
}

- (NSData *) getResourceAlternateData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceAlternateData: authenticationToken : guid];
  return [self recv_getResourceAlternateData];
}

- (void) send_getResourceAttributes: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceAttributes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceAttributes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResourceAttributes *) recv_getResourceAttributes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceAttributes_result * result = [[[EDAMGetResourceAttributes_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceAttributes failed: unknown result"];
}

- (EDAMResourceAttributes *) getResourceAttributes: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceAttributes: authenticationToken : guid];
  return [self recv_getResourceAttributes];
}

- (void) send_getAccountSize: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getAccountSize" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAccountSize_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int64_t) recv_getAccountSize
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetAccountSize_result * result = [[[EDAMGetAccountSize_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAccountSize failed: unknown result"];
}

- (int64_t) getAccountSize: (NSString *) authenticationToken
{
  [self send_getAccountSize: authenticationToken];
  return [self recv_getAccountSize];
}

- (void) send_getAds: (NSString *) authenticationToken : (EDAMAdParameters *) adParameters
{
  [outProtocol writeMessageBeginWithName: @"getAds" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAds_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (adParameters != nil)  {
    [outProtocol writeFieldBeginWithName: @"adParameters" type: TType_STRUCT fieldID: 2];
    [adParameters write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_getAds
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetAds_result * result = [[[EDAMGetAds_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAds failed: unknown result"];
}

- (NSArray *) getAds: (NSString *) authenticationToken : (EDAMAdParameters *) adParameters
{
  [self send_getAds: authenticationToken : adParameters];
  return [self recv_getAds];
}

- (void) send_getRandomAd: (NSString *) authenticationToken : (EDAMAdParameters *) adParameters
{
  [outProtocol writeMessageBeginWithName: @"getRandomAd" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getRandomAd_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (adParameters != nil)  {
    [outProtocol writeFieldBeginWithName: @"adParameters" type: TType_STRUCT fieldID: 2];
    [adParameters write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMAd *) recv_getRandomAd
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetRandomAd_result * result = [[[EDAMGetRandomAd_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getRandomAd failed: unknown result"];
}

- (EDAMAd *) getRandomAd: (NSString *) authenticationToken : (EDAMAdParameters *) adParameters
{
  [self send_getRandomAd: authenticationToken : adParameters];
  return [self recv_getRandomAd];
}

- (void) send_getPublicNotebook: (EDAMUserID) userId : (NSString *) publicUri
{
  [outProtocol writeMessageBeginWithName: @"getPublicNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getPublicNotebook_args"];
  [outProtocol writeFieldBeginWithName: @"userId" type: TType_I32 fieldID: 1];
  [outProtocol writeI32: userId];
  [outProtocol writeFieldEnd];
  if (publicUri != nil)  {
    [outProtocol writeFieldBeginWithName: @"publicUri" type: TType_STRING fieldID: 2];
    [outProtocol writeString: publicUri];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getPublicNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetPublicNotebook_result * result = [[[EDAMGetPublicNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getPublicNotebook failed: unknown result"];
}

- (EDAMNotebook *) getPublicNotebook: (EDAMUserID) userId : (NSString *) publicUri
{
  [self send_getPublicNotebook: userId : publicUri];
  return [self recv_getPublicNotebook];
}

- (void) send_createSharedNotebook: (NSString *) authenticationToken : (EDAMSharedNotebook *) sharedNotebook
{
  [outProtocol writeMessageBeginWithName: @"createSharedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createSharedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (sharedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"sharedNotebook" type: TType_STRUCT fieldID: 2];
    [sharedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSharedNotebook *) recv_createSharedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateSharedNotebook_result * result = [[[EDAMCreateSharedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createSharedNotebook failed: unknown result"];
}

- (EDAMSharedNotebook *) createSharedNotebook: (NSString *) authenticationToken : (EDAMSharedNotebook *) sharedNotebook
{
  [self send_createSharedNotebook: authenticationToken : sharedNotebook];
  return [self recv_createSharedNotebook];
}

- (void) send_listSharedNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listSharedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listSharedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listSharedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListSharedNotebooks_result * result = [[[EDAMListSharedNotebooks_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listSharedNotebooks failed: unknown result"];
}

- (NSArray *) listSharedNotebooks: (NSString *) authenticationToken
{
  [self send_listSharedNotebooks: authenticationToken];
  return [self recv_listSharedNotebooks];
}

- (void) send_expungeSharedNotebooks: (NSString *) authenticationToken : (NSArray *) sharedNotebookIds
{
  [outProtocol writeMessageBeginWithName: @"expungeSharedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeSharedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (sharedNotebookIds != nil)  {
    [outProtocol writeFieldBeginWithName: @"sharedNotebookIds" type: TType_LIST fieldID: 2];
    {
      [outProtocol writeListBeginWithElementType: TType_I64 size: [sharedNotebookIds count]];
      NSUInteger i156;
      for (i156 = 0; i156 < [sharedNotebookIds count]; i156++)
      {
        [outProtocol writeI64: [[sharedNotebookIds objectAtIndex: i156] longLongValue]];
      }
      [outProtocol writeListEnd];
    }
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeSharedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeSharedNotebooks_result * result = [[[EDAMExpungeSharedNotebooks_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeSharedNotebooks failed: unknown result"];
}

- (int32_t) expungeSharedNotebooks: (NSString *) authenticationToken : (NSArray *) sharedNotebookIds
{
  [self send_expungeSharedNotebooks: authenticationToken : sharedNotebookIds];
  return [self recv_expungeSharedNotebooks];
}

- (void) send_createLinkedNotebook: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [outProtocol writeMessageBeginWithName: @"createLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMLinkedNotebook *) recv_createLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateLinkedNotebook_result * result = [[[EDAMCreateLinkedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createLinkedNotebook failed: unknown result"];
}

- (EDAMLinkedNotebook *) createLinkedNotebook: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [self send_createLinkedNotebook: authenticationToken : linkedNotebook];
  return [self recv_createLinkedNotebook];
}

- (void) send_updateLinkedNotebook: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [outProtocol writeMessageBeginWithName: @"updateLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMLinkedNotebook *) recv_updateLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateLinkedNotebook_result * result = [[[EDAMUpdateLinkedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateLinkedNotebook failed: unknown result"];
}

- (EDAMLinkedNotebook *) updateLinkedNotebook: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [self send_updateLinkedNotebook: authenticationToken : linkedNotebook];
  return [self recv_updateLinkedNotebook];
}

- (void) send_listLinkedNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listLinkedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listLinkedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listLinkedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListLinkedNotebooks_result * result = [[[EDAMListLinkedNotebooks_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listLinkedNotebooks failed: unknown result"];
}

- (NSArray *) listLinkedNotebooks: (NSString *) authenticationToken
{
  [self send_listLinkedNotebooks: authenticationToken];
  return [self recv_listLinkedNotebooks];
}

- (void) send_expungeLinkedNotebook: (NSString *) authenticationToken : (int64_t) linkedNotebookId
{
  [outProtocol writeMessageBeginWithName: @"expungeLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"linkedNotebookId" type: TType_I64 fieldID: 2];
  [outProtocol writeI64: linkedNotebookId];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeLinkedNotebook_result * result = [[[EDAMExpungeLinkedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeLinkedNotebook failed: unknown result"];
}

- (int32_t) expungeLinkedNotebook: (NSString *) authenticationToken : (int64_t) linkedNotebookId
{
  [self send_expungeLinkedNotebook: authenticationToken : linkedNotebookId];
  return [self recv_expungeLinkedNotebook];
}

- (void) send_authenticateToSharedNotebook: (NSString *) shareKey : (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNotebook_args"];
  if (shareKey != nil)  {
    [outProtocol writeFieldBeginWithName: @"shareKey" type: TType_STRING fieldID: 1];
    [outProtocol writeString: shareKey];
    [outProtocol writeFieldEnd];
  }
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 2];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMAuthenticationResult *) recv_authenticateToSharedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMAuthenticateToSharedNotebook_result * result = [[[EDAMAuthenticateToSharedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"authenticateToSharedNotebook failed: unknown result"];
}

- (EDAMAuthenticationResult *) authenticateToSharedNotebook: (NSString *) shareKey : (NSString *) authenticationToken
{
  [self send_authenticateToSharedNotebook: shareKey : authenticationToken];
  return [self recv_authenticateToSharedNotebook];
}

- (void) send_getSharedNotebookByAuth: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getSharedNotebookByAuth" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSharedNotebookByAuth_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSharedNotebook *) recv_getSharedNotebookByAuth
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSharedNotebookByAuth_result * result = [[[EDAMGetSharedNotebookByAuth_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSharedNotebookByAuth failed: unknown result"];
}

- (EDAMSharedNotebook *) getSharedNotebookByAuth: (NSString *) authenticationToken
{
  [self send_getSharedNotebookByAuth: authenticationToken];
  return [self recv_getSharedNotebookByAuth];
}

- (void) send_emailNote: (NSString *) authenticationToken : (EDAMNoteEmailParameters *) parameters
{
  [outProtocol writeMessageBeginWithName: @"emailNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"emailNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (parameters != nil)  {
    [outProtocol writeFieldBeginWithName: @"parameters" type: TType_STRUCT fieldID: 2];
    [parameters write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_emailNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMEmailNote_result * result = [[[EDAMEmailNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  return;
}

- (void) emailNote: (NSString *) authenticationToken : (EDAMNoteEmailParameters *) parameters
{
  [self send_emailNote: authenticationToken : parameters];
  [self recv_emailNote];
}

@end

/**
 Private helper methods
 */
@interface EDAMNoteStoreProcessor ()
- (void) process_getSyncState_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getSyncChunk_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_listNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getDefaultNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_createNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_updateNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_expungeNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_listTags_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_listTagsByNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_createTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_updateTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_untagAll_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_expungeTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_listSearches_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_createSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_updateSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_expungeSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_findNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_findNoteCounts_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getNoteContent_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getNoteSearchText_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getNoteTagNames_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_createNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_updateNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_deleteNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_expungeNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_expungeNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_expungeInactiveNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_copyNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_listNoteVersions_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getNoteVersion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getResource_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_updateResource_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getResourceData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getResourceByHash_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getResourceRecognition_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getResourceAlternateData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getResourceAttributes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getAccountSize_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getAds_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getRandomAd_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getPublicNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_createSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_listSharedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_expungeSharedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_createLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_updateLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_listLinkedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_expungeLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_authenticateToSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_getSharedNotebookByAuth_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
- (void) process_emailNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol;
@end

@implementation EDAMNoteStoreProcessor

- (id) initWithNoteStore: (id <EDAMNoteStore>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain];
  mMethodMap = [[NSMutableDictionary dictionary] retain];
  {
    SEL s = @selector(process_getSyncState_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSyncState"];
  }
  {
    SEL s = @selector(process_getSyncChunk_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSyncChunk"];
  }
  {
    SEL s = @selector(process_listNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listNotebooks"];
  }
  {
    SEL s = @selector(process_getNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNotebook"];
  }
  {
    SEL s = @selector(process_getDefaultNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getDefaultNotebook"];
  }
  {
    SEL s = @selector(process_createNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createNotebook"];
  }
  {
    SEL s = @selector(process_updateNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateNotebook"];
  }
  {
    SEL s = @selector(process_expungeNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNotebook"];
  }
  {
    SEL s = @selector(process_listTags_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listTags"];
  }
  {
    SEL s = @selector(process_listTagsByNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listTagsByNotebook"];
  }
  {
    SEL s = @selector(process_getTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getTag"];
  }
  {
    SEL s = @selector(process_createTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createTag"];
  }
  {
    SEL s = @selector(process_updateTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateTag"];
  }
  {
    SEL s = @selector(process_untagAll_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"untagAll"];
  }
  {
    SEL s = @selector(process_expungeTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeTag"];
  }
  {
    SEL s = @selector(process_listSearches_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listSearches"];
  }
  {
    SEL s = @selector(process_getSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSearch"];
  }
  {
    SEL s = @selector(process_createSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createSearch"];
  }
  {
    SEL s = @selector(process_updateSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateSearch"];
  }
  {
    SEL s = @selector(process_expungeSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeSearch"];
  }
  {
    SEL s = @selector(process_findNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNotes"];
  }
  {
    SEL s = @selector(process_findNoteCounts_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNoteCounts"];
  }
  {
    SEL s = @selector(process_getNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNote"];
  }
  {
    SEL s = @selector(process_getNoteContent_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteContent"];
  }
  {
    SEL s = @selector(process_getNoteSearchText_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteSearchText"];
  }
  {
    SEL s = @selector(process_getNoteTagNames_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteTagNames"];
  }
  {
    SEL s = @selector(process_createNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createNote"];
  }
  {
    SEL s = @selector(process_updateNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateNote"];
  }
  {
    SEL s = @selector(process_deleteNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"deleteNote"];
  }
  {
    SEL s = @selector(process_expungeNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNote"];
  }
  {
    SEL s = @selector(process_expungeNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNotes"];
  }
  {
    SEL s = @selector(process_expungeInactiveNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeInactiveNotes"];
  }
  {
    SEL s = @selector(process_copyNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"copyNote"];
  }
  {
    SEL s = @selector(process_listNoteVersions_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listNoteVersions"];
  }
  {
    SEL s = @selector(process_getNoteVersion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteVersion"];
  }
  {
    SEL s = @selector(process_getResource_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResource"];
  }
  {
    SEL s = @selector(process_updateResource_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateResource"];
  }
  {
    SEL s = @selector(process_getResourceData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceData"];
  }
  {
    SEL s = @selector(process_getResourceByHash_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceByHash"];
  }
  {
    SEL s = @selector(process_getResourceRecognition_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceRecognition"];
  }
  {
    SEL s = @selector(process_getResourceAlternateData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceAlternateData"];
  }
  {
    SEL s = @selector(process_getResourceAttributes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceAttributes"];
  }
  {
    SEL s = @selector(process_getAccountSize_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAccountSize"];
  }
  {
    SEL s = @selector(process_getAds_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAds"];
  }
  {
    SEL s = @selector(process_getRandomAd_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getRandomAd"];
  }
  {
    SEL s = @selector(process_getPublicNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getPublicNotebook"];
  }
  {
    SEL s = @selector(process_createSharedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createSharedNotebook"];
  }
  {
    SEL s = @selector(process_listSharedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listSharedNotebooks"];
  }
  {
    SEL s = @selector(process_expungeSharedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeSharedNotebooks"];
  }
  {
    SEL s = @selector(process_createLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createLinkedNotebook"];
  }
  {
    SEL s = @selector(process_updateLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateLinkedNotebook"];
  }
  {
    SEL s = @selector(process_listLinkedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listLinkedNotebooks"];
  }
  {
    SEL s = @selector(process_expungeLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeLinkedNotebook"];
  }
  {
    SEL s = @selector(process_authenticateToSharedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"authenticateToSharedNotebook"];
  }
  {
    SEL s = @selector(process_getSharedNotebookByAuth_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSharedNotebookByAuth"];
  }
  {
    SEL s = @selector(process_emailNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"emailNote"];
  }
  return self;
}

- (id<EDAMNoteStore>) service
{
  return [[mService retain] autorelease];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_getSyncState_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSyncState_args * args = [[EDAMgetSyncState_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSyncState_result * result = [[EDAMGetSyncState_result alloc] init];
  [result setSuccess: [mService getSyncState: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getSyncState"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getSyncChunk_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSyncChunk_args * args = [[EDAMgetSyncChunk_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSyncChunk_result * result = [[EDAMGetSyncChunk_result alloc] init];
  [result setSuccess: [mService getSyncChunk: [args authenticationToken]: [args afterUSN]: [args maxEntries]: [args fullSyncOnly]]];
  [outProtocol writeMessageBeginWithName: @"getSyncChunk"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistNotebooks_args * args = [[EDAMlistNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListNotebooks_result * result = [[EDAMListNotebooks_result alloc] init];
  [result setSuccess: [mService listNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNotebook_args * args = [[EDAMgetNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNotebook_result * result = [[EDAMGetNotebook_result alloc] init];
  [result setSuccess: [mService getNotebook: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getDefaultNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetDefaultNotebook_args * args = [[EDAMgetDefaultNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetDefaultNotebook_result * result = [[EDAMGetDefaultNotebook_result alloc] init];
  [result setSuccess: [mService getDefaultNotebook: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getDefaultNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateNotebook_args * args = [[EDAMcreateNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateNotebook_result * result = [[EDAMCreateNotebook_result alloc] init];
  [result setSuccess: [mService createNotebook: [args authenticationToken]: [args notebook]]];
  [outProtocol writeMessageBeginWithName: @"createNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateNotebook_args * args = [[EDAMupdateNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateNotebook_result * result = [[EDAMUpdateNotebook_result alloc] init];
  [result setSuccess: [mService updateNotebook: [args authenticationToken]: [args notebook]]];
  [outProtocol writeMessageBeginWithName: @"updateNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNotebook_args * args = [[EDAMexpungeNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNotebook_result * result = [[EDAMExpungeNotebook_result alloc] init];
  [result setSuccess: [mService expungeNotebook: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listTags_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistTags_args * args = [[EDAMlistTags_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListTags_result * result = [[EDAMListTags_result alloc] init];
  [result setSuccess: [mService listTags: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listTags"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listTagsByNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistTagsByNotebook_args * args = [[EDAMlistTagsByNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListTagsByNotebook_result * result = [[EDAMListTagsByNotebook_result alloc] init];
  [result setSuccess: [mService listTagsByNotebook: [args authenticationToken]: [args notebookGuid]]];
  [outProtocol writeMessageBeginWithName: @"listTagsByNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetTag_args * args = [[EDAMgetTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetTag_result * result = [[EDAMGetTag_result alloc] init];
  [result setSuccess: [mService getTag: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateTag_args * args = [[EDAMcreateTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateTag_result * result = [[EDAMCreateTag_result alloc] init];
  [result setSuccess: [mService createTag: [args authenticationToken]: [args tag]]];
  [outProtocol writeMessageBeginWithName: @"createTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateTag_args * args = [[EDAMupdateTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateTag_result * result = [[EDAMUpdateTag_result alloc] init];
  [result setSuccess: [mService updateTag: [args authenticationToken]: [args tag]]];
  [outProtocol writeMessageBeginWithName: @"updateTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_untagAll_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMuntagAll_args * args = [[EDAMuntagAll_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUntagAll_result * result = [[EDAMUntagAll_result alloc] init];
  [mService untagAll: [args authenticationToken]: [args guid]];
  [outProtocol writeMessageBeginWithName: @"untagAll"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeTag_args * args = [[EDAMexpungeTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeTag_result * result = [[EDAMExpungeTag_result alloc] init];
  [result setSuccess: [mService expungeTag: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listSearches_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistSearches_args * args = [[EDAMlistSearches_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListSearches_result * result = [[EDAMListSearches_result alloc] init];
  [result setSuccess: [mService listSearches: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listSearches"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSearch_args * args = [[EDAMgetSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSearch_result * result = [[EDAMGetSearch_result alloc] init];
  [result setSuccess: [mService getSearch: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateSearch_args * args = [[EDAMcreateSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateSearch_result * result = [[EDAMCreateSearch_result alloc] init];
  [result setSuccess: [mService createSearch: [args authenticationToken]: [args search]]];
  [outProtocol writeMessageBeginWithName: @"createSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateSearch_args * args = [[EDAMupdateSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateSearch_result * result = [[EDAMUpdateSearch_result alloc] init];
  [result setSuccess: [mService updateSearch: [args authenticationToken]: [args search]]];
  [outProtocol writeMessageBeginWithName: @"updateSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeSearch_args * args = [[EDAMexpungeSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeSearch_result * result = [[EDAMExpungeSearch_result alloc] init];
  [result setSuccess: [mService expungeSearch: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_findNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNotes_args * args = [[EDAMfindNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNotes_result * result = [[EDAMFindNotes_result alloc] init];
  [result setSuccess: [mService findNotes: [args authenticationToken]: [args filter]: [args offset]: [args maxNotes]]];
  [outProtocol writeMessageBeginWithName: @"findNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_findNoteCounts_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNoteCounts_args * args = [[EDAMfindNoteCounts_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNoteCounts_result * result = [[EDAMFindNoteCounts_result alloc] init];
  [result setSuccess: [mService findNoteCounts: [args authenticationToken]: [args filter]: [args withTrash]]];
  [outProtocol writeMessageBeginWithName: @"findNoteCounts"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNote_args * args = [[EDAMgetNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNote_result * result = [[EDAMGetNote_result alloc] init];
  [result setSuccess: [mService getNote: [args authenticationToken]: [args guid]: [args withContent]: [args withResourcesData]: [args withResourcesRecognition]: [args withResourcesAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteContent_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteContent_args * args = [[EDAMgetNoteContent_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteContent_result * result = [[EDAMGetNoteContent_result alloc] init];
  [result setSuccess: [mService getNoteContent: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteContent"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteSearchText_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteSearchText_args * args = [[EDAMgetNoteSearchText_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteSearchText_result * result = [[EDAMGetNoteSearchText_result alloc] init];
  [result setSuccess: [mService getNoteSearchText: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteSearchText"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteTagNames_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteTagNames_args * args = [[EDAMgetNoteTagNames_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteTagNames_result * result = [[EDAMGetNoteTagNames_result alloc] init];
  [result setSuccess: [mService getNoteTagNames: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteTagNames"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateNote_args * args = [[EDAMcreateNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateNote_result * result = [[EDAMCreateNote_result alloc] init];
  [result setSuccess: [mService createNote: [args authenticationToken]: [args note]]];
  [outProtocol writeMessageBeginWithName: @"createNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateNote_args * args = [[EDAMupdateNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateNote_result * result = [[EDAMUpdateNote_result alloc] init];
  [result setSuccess: [mService updateNote: [args authenticationToken]: [args note]]];
  [outProtocol writeMessageBeginWithName: @"updateNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_deleteNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMdeleteNote_args * args = [[EDAMdeleteNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMDeleteNote_result * result = [[EDAMDeleteNote_result alloc] init];
  [result setSuccess: [mService deleteNote: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"deleteNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNote_args * args = [[EDAMexpungeNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNote_result * result = [[EDAMExpungeNote_result alloc] init];
  [result setSuccess: [mService expungeNote: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNotes_args * args = [[EDAMexpungeNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNotes_result * result = [[EDAMExpungeNotes_result alloc] init];
  [result setSuccess: [mService expungeNotes: [args authenticationToken]: [args noteGuids]]];
  [outProtocol writeMessageBeginWithName: @"expungeNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeInactiveNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeInactiveNotes_args * args = [[EDAMexpungeInactiveNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeInactiveNotes_result * result = [[EDAMExpungeInactiveNotes_result alloc] init];
  [result setSuccess: [mService expungeInactiveNotes: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"expungeInactiveNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_copyNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcopyNote_args * args = [[EDAMcopyNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCopyNote_result * result = [[EDAMCopyNote_result alloc] init];
  [result setSuccess: [mService copyNote: [args authenticationToken]: [args noteGuid]: [args toNotebookGuid]]];
  [outProtocol writeMessageBeginWithName: @"copyNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listNoteVersions_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistNoteVersions_args * args = [[EDAMlistNoteVersions_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListNoteVersions_result * result = [[EDAMListNoteVersions_result alloc] init];
  [result setSuccess: [mService listNoteVersions: [args authenticationToken]: [args noteGuid]]];
  [outProtocol writeMessageBeginWithName: @"listNoteVersions"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteVersion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteVersion_args * args = [[EDAMgetNoteVersion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteVersion_result * result = [[EDAMGetNoteVersion_result alloc] init];
  [result setSuccess: [mService getNoteVersion: [args authenticationToken]: [args noteGuid]: [args updateSequenceNum]: [args withResourcesData]: [args withResourcesRecognition]: [args withResourcesAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getNoteVersion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResource_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResource_args * args = [[EDAMgetResource_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResource_result * result = [[EDAMGetResource_result alloc] init];
  [result setSuccess: [mService getResource: [args authenticationToken]: [args guid]: [args withData]: [args withRecognition]: [args withAttributes]: [args withAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getResource"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateResource_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateResource_args * args = [[EDAMupdateResource_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateResource_result * result = [[EDAMUpdateResource_result alloc] init];
  [result setSuccess: [mService updateResource: [args authenticationToken]: [args resource]]];
  [outProtocol writeMessageBeginWithName: @"updateResource"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceData_args * args = [[EDAMgetResourceData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceData_result * result = [[EDAMGetResourceData_result alloc] init];
  [result setSuccess: [mService getResourceData: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceByHash_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceByHash_args * args = [[EDAMgetResourceByHash_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceByHash_result * result = [[EDAMGetResourceByHash_result alloc] init];
  [result setSuccess: [mService getResourceByHash: [args authenticationToken]: [args noteGuid]: [args contentHash]: [args withData]: [args withRecognition]: [args withAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getResourceByHash"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceRecognition_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceRecognition_args * args = [[EDAMgetResourceRecognition_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceRecognition_result * result = [[EDAMGetResourceRecognition_result alloc] init];
  [result setSuccess: [mService getResourceRecognition: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceRecognition"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceAlternateData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceAlternateData_args * args = [[EDAMgetResourceAlternateData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceAlternateData_result * result = [[EDAMGetResourceAlternateData_result alloc] init];
  [result setSuccess: [mService getResourceAlternateData: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceAlternateData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceAttributes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceAttributes_args * args = [[EDAMgetResourceAttributes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceAttributes_result * result = [[EDAMGetResourceAttributes_result alloc] init];
  [result setSuccess: [mService getResourceAttributes: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceAttributes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getAccountSize_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetAccountSize_args * args = [[EDAMgetAccountSize_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetAccountSize_result * result = [[EDAMGetAccountSize_result alloc] init];
  [result setSuccess: [mService getAccountSize: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getAccountSize"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getAds_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetAds_args * args = [[EDAMgetAds_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetAds_result * result = [[EDAMGetAds_result alloc] init];
  [result setSuccess: [mService getAds: [args authenticationToken]: [args adParameters]]];
  [outProtocol writeMessageBeginWithName: @"getAds"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getRandomAd_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetRandomAd_args * args = [[EDAMgetRandomAd_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetRandomAd_result * result = [[EDAMGetRandomAd_result alloc] init];
  [result setSuccess: [mService getRandomAd: [args authenticationToken]: [args adParameters]]];
  [outProtocol writeMessageBeginWithName: @"getRandomAd"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getPublicNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetPublicNotebook_args * args = [[EDAMgetPublicNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetPublicNotebook_result * result = [[EDAMGetPublicNotebook_result alloc] init];
  [result setSuccess: [mService getPublicNotebook: [args userId]: [args publicUri]]];
  [outProtocol writeMessageBeginWithName: @"getPublicNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateSharedNotebook_args * args = [[EDAMcreateSharedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateSharedNotebook_result * result = [[EDAMCreateSharedNotebook_result alloc] init];
  [result setSuccess: [mService createSharedNotebook: [args authenticationToken]: [args sharedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"createSharedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listSharedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistSharedNotebooks_args * args = [[EDAMlistSharedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListSharedNotebooks_result * result = [[EDAMListSharedNotebooks_result alloc] init];
  [result setSuccess: [mService listSharedNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listSharedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeSharedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeSharedNotebooks_args * args = [[EDAMexpungeSharedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeSharedNotebooks_result * result = [[EDAMExpungeSharedNotebooks_result alloc] init];
  [result setSuccess: [mService expungeSharedNotebooks: [args authenticationToken]: [args sharedNotebookIds]]];
  [outProtocol writeMessageBeginWithName: @"expungeSharedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateLinkedNotebook_args * args = [[EDAMcreateLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateLinkedNotebook_result * result = [[EDAMCreateLinkedNotebook_result alloc] init];
  [result setSuccess: [mService createLinkedNotebook: [args authenticationToken]: [args linkedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"createLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateLinkedNotebook_args * args = [[EDAMupdateLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateLinkedNotebook_result * result = [[EDAMUpdateLinkedNotebook_result alloc] init];
  [result setSuccess: [mService updateLinkedNotebook: [args authenticationToken]: [args linkedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"updateLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listLinkedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistLinkedNotebooks_args * args = [[EDAMlistLinkedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListLinkedNotebooks_result * result = [[EDAMListLinkedNotebooks_result alloc] init];
  [result setSuccess: [mService listLinkedNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listLinkedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeLinkedNotebook_args * args = [[EDAMexpungeLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeLinkedNotebook_result * result = [[EDAMExpungeLinkedNotebook_result alloc] init];
  [result setSuccess: [mService expungeLinkedNotebook: [args authenticationToken]: [args linkedNotebookId]]];
  [outProtocol writeMessageBeginWithName: @"expungeLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_authenticateToSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMauthenticateToSharedNotebook_args * args = [[EDAMauthenticateToSharedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMAuthenticateToSharedNotebook_result * result = [[EDAMAuthenticateToSharedNotebook_result alloc] init];
  [result setSuccess: [mService authenticateToSharedNotebook: [args shareKey]: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getSharedNotebookByAuth_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSharedNotebookByAuth_args * args = [[EDAMgetSharedNotebookByAuth_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSharedNotebookByAuth_result * result = [[EDAMGetSharedNotebookByAuth_result alloc] init];
  [result setSuccess: [mService getSharedNotebookByAuth: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getSharedNotebookByAuth"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_emailNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMemailNote_args * args = [[EDAMemailNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMEmailNote_result * result = [[EDAMEmailNote_result alloc] init];
  [mService emailNote: [args authenticationToken]: [args parameters]];
  [outProtocol writeMessageBeginWithName: @"emailNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) dealloc
{
  [mService release];
  [mMethodMap release];
  [super dealloc];
}

@end

