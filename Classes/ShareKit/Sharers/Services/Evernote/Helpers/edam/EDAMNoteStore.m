/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"

#import "EDAMUserStore.h"
#import "EDAMTypes.h"
#import "EDAMErrors.h"
#import "EDAMLimits.h"

#import "EDAMNoteStore.h"


@implementation EDAMNoteStoreConstants
+ (void) initialize {
}
@end

@implementation EDAMSyncState

- (id) initWithCurrentTime: (EDAMTimestamp) currentTime fullSyncBefore: (EDAMTimestamp) fullSyncBefore updateCount: (int32_t) updateCount uploaded: (int64_t) uploaded
{
  self = [super init];
  __currentTime = currentTime;
  __currentTime_isset = YES;
  __fullSyncBefore = fullSyncBefore;
  __fullSyncBefore_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  __uploaded = uploaded;
  __uploaded_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"currentTime"])
  {
    __currentTime = [decoder decodeInt64ForKey: @"currentTime"];
    __currentTime_isset = YES;
  }
  if ([decoder containsValueForKey: @"fullSyncBefore"])
  {
    __fullSyncBefore = [decoder decodeInt64ForKey: @"fullSyncBefore"];
    __fullSyncBefore_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  if ([decoder containsValueForKey: @"uploaded"])
  {
    __uploaded = [decoder decodeInt64ForKey: @"uploaded"];
    __uploaded_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__currentTime_isset)
  {
    [encoder encodeInt64: __currentTime forKey: @"currentTime"];
  }
  if (__fullSyncBefore_isset)
  {
    [encoder encodeInt64: __fullSyncBefore forKey: @"fullSyncBefore"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
  if (__uploaded_isset)
  {
    [encoder encodeInt64: __uploaded forKey: @"uploaded"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int64_t) currentTime {
  return __currentTime;
}

- (void) setCurrentTime: (int64_t) currentTime {
  __currentTime = currentTime;
  __currentTime_isset = YES;
}

- (BOOL) currentTimeIsSet {
  return __currentTime_isset;
}

- (void) unsetCurrentTime {
  __currentTime_isset = NO;
}

- (int64_t) fullSyncBefore {
  return __fullSyncBefore;
}

- (void) setFullSyncBefore: (int64_t) fullSyncBefore {
  __fullSyncBefore = fullSyncBefore;
  __fullSyncBefore_isset = YES;
}

- (BOOL) fullSyncBeforeIsSet {
  return __fullSyncBefore_isset;
}

- (void) unsetFullSyncBefore {
  __fullSyncBefore_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (int64_t) uploaded {
  return __uploaded;
}

- (void) setUploaded: (int64_t) uploaded {
  __uploaded = uploaded;
  __uploaded_isset = YES;
}

- (BOOL) uploadedIsSet {
  return __uploaded_isset;
}

- (void) unsetUploaded {
  __uploaded_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCurrentTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setFullSyncBefore: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setUploaded: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SyncState"];
  if (__currentTime_isset) {
    [outProtocol writeFieldBeginWithName: @"currentTime" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __currentTime];
    [outProtocol writeFieldEnd];
  }
  if (__fullSyncBefore_isset) {
    [outProtocol writeFieldBeginWithName: @"fullSyncBefore" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __fullSyncBefore];
    [outProtocol writeFieldEnd];
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  if (__uploaded_isset) {
    [outProtocol writeFieldBeginWithName: @"uploaded" type: TType_I64 fieldID: 4];
    [outProtocol writeI64: __uploaded];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SyncState("];
  [ms appendString: @"currentTime:"];
  [ms appendFormat: @"%qi", __currentTime];
  [ms appendString: @",fullSyncBefore:"];
  [ms appendFormat: @"%qi", __fullSyncBefore];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @",uploaded:"];
  [ms appendFormat: @"%qi", __uploaded];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMSyncChunk

- (id) initWithCurrentTime: (EDAMTimestamp) currentTime chunkHighUSN: (int32_t) chunkHighUSN updateCount: (int32_t) updateCount notes: (NSArray *) notes notebooks: (NSArray *) notebooks tags: (NSArray *) tags searches: (NSArray *) searches resources: (NSArray *) resources expungedNotes: (NSArray *) expungedNotes expungedNotebooks: (NSArray *) expungedNotebooks expungedTags: (NSArray *) expungedTags expungedSearches: (NSArray *) expungedSearches linkedNotebooks: (NSArray *) linkedNotebooks expungedLinkedNotebooks: (NSArray *) expungedLinkedNotebooks
{
  self = [super init];
  __currentTime = currentTime;
  __currentTime_isset = YES;
  __chunkHighUSN = chunkHighUSN;
  __chunkHighUSN_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  __notes = [notes retain];
  __notes_isset = YES;
  __notebooks = [notebooks retain];
  __notebooks_isset = YES;
  __tags = [tags retain];
  __tags_isset = YES;
  __searches = [searches retain];
  __searches_isset = YES;
  __resources = [resources retain];
  __resources_isset = YES;
  __expungedNotes = [expungedNotes retain];
  __expungedNotes_isset = YES;
  __expungedNotebooks = [expungedNotebooks retain];
  __expungedNotebooks_isset = YES;
  __expungedTags = [expungedTags retain];
  __expungedTags_isset = YES;
  __expungedSearches = [expungedSearches retain];
  __expungedSearches_isset = YES;
  __linkedNotebooks = [linkedNotebooks retain];
  __linkedNotebooks_isset = YES;
  __expungedLinkedNotebooks = [expungedLinkedNotebooks retain];
  __expungedLinkedNotebooks_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"currentTime"])
  {
    __currentTime = [decoder decodeInt64ForKey: @"currentTime"];
    __currentTime_isset = YES;
  }
  if ([decoder containsValueForKey: @"chunkHighUSN"])
  {
    __chunkHighUSN = [decoder decodeInt32ForKey: @"chunkHighUSN"];
    __chunkHighUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebooks"])
  {
    __notebooks = [[decoder decodeObjectForKey: @"notebooks"] retain];
    __notebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"tags"])
  {
    __tags = [[decoder decodeObjectForKey: @"tags"] retain];
    __tags_isset = YES;
  }
  if ([decoder containsValueForKey: @"searches"])
  {
    __searches = [[decoder decodeObjectForKey: @"searches"] retain];
    __searches_isset = YES;
  }
  if ([decoder containsValueForKey: @"resources"])
  {
    __resources = [[decoder decodeObjectForKey: @"resources"] retain];
    __resources_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedNotes"])
  {
    __expungedNotes = [[decoder decodeObjectForKey: @"expungedNotes"] retain];
    __expungedNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedNotebooks"])
  {
    __expungedNotebooks = [[decoder decodeObjectForKey: @"expungedNotebooks"] retain];
    __expungedNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedTags"])
  {
    __expungedTags = [[decoder decodeObjectForKey: @"expungedTags"] retain];
    __expungedTags_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedSearches"])
  {
    __expungedSearches = [[decoder decodeObjectForKey: @"expungedSearches"] retain];
    __expungedSearches_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebooks"])
  {
    __linkedNotebooks = [[decoder decodeObjectForKey: @"linkedNotebooks"] retain];
    __linkedNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"expungedLinkedNotebooks"])
  {
    __expungedLinkedNotebooks = [[decoder decodeObjectForKey: @"expungedLinkedNotebooks"] retain];
    __expungedLinkedNotebooks_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__currentTime_isset)
  {
    [encoder encodeInt64: __currentTime forKey: @"currentTime"];
  }
  if (__chunkHighUSN_isset)
  {
    [encoder encodeInt32: __chunkHighUSN forKey: @"chunkHighUSN"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__notebooks_isset)
  {
    [encoder encodeObject: __notebooks forKey: @"notebooks"];
  }
  if (__tags_isset)
  {
    [encoder encodeObject: __tags forKey: @"tags"];
  }
  if (__searches_isset)
  {
    [encoder encodeObject: __searches forKey: @"searches"];
  }
  if (__resources_isset)
  {
    [encoder encodeObject: __resources forKey: @"resources"];
  }
  if (__expungedNotes_isset)
  {
    [encoder encodeObject: __expungedNotes forKey: @"expungedNotes"];
  }
  if (__expungedNotebooks_isset)
  {
    [encoder encodeObject: __expungedNotebooks forKey: @"expungedNotebooks"];
  }
  if (__expungedTags_isset)
  {
    [encoder encodeObject: __expungedTags forKey: @"expungedTags"];
  }
  if (__expungedSearches_isset)
  {
    [encoder encodeObject: __expungedSearches forKey: @"expungedSearches"];
  }
  if (__linkedNotebooks_isset)
  {
    [encoder encodeObject: __linkedNotebooks forKey: @"linkedNotebooks"];
  }
  if (__expungedLinkedNotebooks_isset)
  {
    [encoder encodeObject: __expungedLinkedNotebooks forKey: @"expungedLinkedNotebooks"];
  }
}

- (void) dealloc
{
  [__notes release];
  [__notebooks release];
  [__tags release];
  [__searches release];
  [__resources release];
  [__expungedNotes release];
  [__expungedNotebooks release];
  [__expungedTags release];
  [__expungedSearches release];
  [__linkedNotebooks release];
  [__expungedLinkedNotebooks release];
  [super dealloc];
}

- (int64_t) currentTime {
  return __currentTime;
}

- (void) setCurrentTime: (int64_t) currentTime {
  __currentTime = currentTime;
  __currentTime_isset = YES;
}

- (BOOL) currentTimeIsSet {
  return __currentTime_isset;
}

- (void) unsetCurrentTime {
  __currentTime_isset = NO;
}

- (int32_t) chunkHighUSN {
  return __chunkHighUSN;
}

- (void) setChunkHighUSN: (int32_t) chunkHighUSN {
  __chunkHighUSN = chunkHighUSN;
  __chunkHighUSN_isset = YES;
}

- (BOOL) chunkHighUSNIsSet {
  return __chunkHighUSN_isset;
}

- (void) unsetChunkHighUSN {
  __chunkHighUSN_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (NSArray *) notes {
  return [[__notes retain] autorelease];
}

- (void) setNotes: (NSArray *) notes {
  [notes retain];
  [__notes release];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release];
  __notes = nil;
  __notes_isset = NO;
}

- (NSArray *) notebooks {
  return [[__notebooks retain] autorelease];
}

- (void) setNotebooks: (NSArray *) notebooks {
  [notebooks retain];
  [__notebooks release];
  __notebooks = notebooks;
  __notebooks_isset = YES;
}

- (BOOL) notebooksIsSet {
  return __notebooks_isset;
}

- (void) unsetNotebooks {
  [__notebooks release];
  __notebooks = nil;
  __notebooks_isset = NO;
}

- (NSArray *) tags {
  return [[__tags retain] autorelease];
}

- (void) setTags: (NSArray *) tags {
  [tags retain];
  [__tags release];
  __tags = tags;
  __tags_isset = YES;
}

- (BOOL) tagsIsSet {
  return __tags_isset;
}

- (void) unsetTags {
  [__tags release];
  __tags = nil;
  __tags_isset = NO;
}

- (NSArray *) searches {
  return [[__searches retain] autorelease];
}

- (void) setSearches: (NSArray *) searches {
  [searches retain];
  [__searches release];
  __searches = searches;
  __searches_isset = YES;
}

- (BOOL) searchesIsSet {
  return __searches_isset;
}

- (void) unsetSearches {
  [__searches release];
  __searches = nil;
  __searches_isset = NO;
}

- (NSArray *) resources {
  return [[__resources retain] autorelease];
}

- (void) setResources: (NSArray *) resources {
  [resources retain];
  [__resources release];
  __resources = resources;
  __resources_isset = YES;
}

- (BOOL) resourcesIsSet {
  return __resources_isset;
}

- (void) unsetResources {
  [__resources release];
  __resources = nil;
  __resources_isset = NO;
}

- (NSArray *) expungedNotes {
  return [[__expungedNotes retain] autorelease];
}

- (void) setExpungedNotes: (NSArray *) expungedNotes {
  [expungedNotes retain];
  [__expungedNotes release];
  __expungedNotes = expungedNotes;
  __expungedNotes_isset = YES;
}

- (BOOL) expungedNotesIsSet {
  return __expungedNotes_isset;
}

- (void) unsetExpungedNotes {
  [__expungedNotes release];
  __expungedNotes = nil;
  __expungedNotes_isset = NO;
}

- (NSArray *) expungedNotebooks {
  return [[__expungedNotebooks retain] autorelease];
}

- (void) setExpungedNotebooks: (NSArray *) expungedNotebooks {
  [expungedNotebooks retain];
  [__expungedNotebooks release];
  __expungedNotebooks = expungedNotebooks;
  __expungedNotebooks_isset = YES;
}

- (BOOL) expungedNotebooksIsSet {
  return __expungedNotebooks_isset;
}

- (void) unsetExpungedNotebooks {
  [__expungedNotebooks release];
  __expungedNotebooks = nil;
  __expungedNotebooks_isset = NO;
}

- (NSArray *) expungedTags {
  return [[__expungedTags retain] autorelease];
}

- (void) setExpungedTags: (NSArray *) expungedTags {
  [expungedTags retain];
  [__expungedTags release];
  __expungedTags = expungedTags;
  __expungedTags_isset = YES;
}

- (BOOL) expungedTagsIsSet {
  return __expungedTags_isset;
}

- (void) unsetExpungedTags {
  [__expungedTags release];
  __expungedTags = nil;
  __expungedTags_isset = NO;
}

- (NSArray *) expungedSearches {
  return [[__expungedSearches retain] autorelease];
}

- (void) setExpungedSearches: (NSArray *) expungedSearches {
  [expungedSearches retain];
  [__expungedSearches release];
  __expungedSearches = expungedSearches;
  __expungedSearches_isset = YES;
}

- (BOOL) expungedSearchesIsSet {
  return __expungedSearches_isset;
}

- (void) unsetExpungedSearches {
  [__expungedSearches release];
  __expungedSearches = nil;
  __expungedSearches_isset = NO;
}

- (NSArray *) linkedNotebooks {
  return [[__linkedNotebooks retain] autorelease];
}

- (void) setLinkedNotebooks: (NSArray *) linkedNotebooks {
  [linkedNotebooks retain];
  [__linkedNotebooks release];
  __linkedNotebooks = linkedNotebooks;
  __linkedNotebooks_isset = YES;
}

- (BOOL) linkedNotebooksIsSet {
  return __linkedNotebooks_isset;
}

- (void) unsetLinkedNotebooks {
  [__linkedNotebooks release];
  __linkedNotebooks = nil;
  __linkedNotebooks_isset = NO;
}

- (NSArray *) expungedLinkedNotebooks {
  return [[__expungedLinkedNotebooks retain] autorelease];
}

- (void) setExpungedLinkedNotebooks: (NSArray *) expungedLinkedNotebooks {
  [expungedLinkedNotebooks retain];
  [__expungedLinkedNotebooks release];
  __expungedLinkedNotebooks = expungedLinkedNotebooks;
  __expungedLinkedNotebooks_isset = YES;
}

- (BOOL) expungedLinkedNotebooksIsSet {
  return __expungedLinkedNotebooks_isset;
}

- (void) unsetExpungedLinkedNotebooks {
  [__expungedLinkedNotebooks release];
  __expungedLinkedNotebooks = nil;
  __expungedLinkedNotebooks_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCurrentTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setChunkHighUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size0;
          [inProtocol readListBeginReturningElementType: NULL size: &_size0];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size0];
          int _i1;
          for (_i1 = 0; _i1 < _size0; ++_i1)
          {
            EDAMNote *_elem2 = [[EDAMNote alloc] init];
            [_elem2 read: inProtocol];
            [fieldValue addObject: _elem2];
            [_elem2 release];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size3;
          [inProtocol readListBeginReturningElementType: NULL size: &_size3];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size3];
          int _i4;
          for (_i4 = 0; _i4 < _size3; ++_i4)
          {
            EDAMNotebook *_elem5 = [[EDAMNotebook alloc] init];
            [_elem5 read: inProtocol];
            [fieldValue addObject: _elem5];
            [_elem5 release];
          }
          [inProtocol readListEnd];
          [self setNotebooks: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_LIST) {
          int _size6;
          [inProtocol readListBeginReturningElementType: NULL size: &_size6];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size6];
          int _i7;
          for (_i7 = 0; _i7 < _size6; ++_i7)
          {
            EDAMTag *_elem8 = [[EDAMTag alloc] init];
            [_elem8 read: inProtocol];
            [fieldValue addObject: _elem8];
            [_elem8 release];
          }
          [inProtocol readListEnd];
          [self setTags: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_LIST) {
          int _size9;
          [inProtocol readListBeginReturningElementType: NULL size: &_size9];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size9];
          int _i10;
          for (_i10 = 0; _i10 < _size9; ++_i10)
          {
            EDAMSavedSearch *_elem11 = [[EDAMSavedSearch alloc] init];
            [_elem11 read: inProtocol];
            [fieldValue addObject: _elem11];
            [_elem11 release];
          }
          [inProtocol readListEnd];
          [self setSearches: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_LIST) {
          int _size12;
          [inProtocol readListBeginReturningElementType: NULL size: &_size12];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size12];
          int _i13;
          for (_i13 = 0; _i13 < _size12; ++_i13)
          {
            EDAMResource *_elem14 = [[EDAMResource alloc] init];
            [_elem14 read: inProtocol];
            [fieldValue addObject: _elem14];
            [_elem14 release];
          }
          [inProtocol readListEnd];
          [self setResources: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 9:
        if (fieldType == TType_LIST) {
          int _size15;
          [inProtocol readListBeginReturningElementType: NULL size: &_size15];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size15];
          int _i16;
          for (_i16 = 0; _i16 < _size15; ++_i16)
          {
            NSString * _elem17 = [inProtocol readString];
            [fieldValue addObject: _elem17];
          }
          [inProtocol readListEnd];
          [self setExpungedNotes: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_LIST) {
          int _size18;
          [inProtocol readListBeginReturningElementType: NULL size: &_size18];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size18];
          int _i19;
          for (_i19 = 0; _i19 < _size18; ++_i19)
          {
            NSString * _elem20 = [inProtocol readString];
            [fieldValue addObject: _elem20];
          }
          [inProtocol readListEnd];
          [self setExpungedNotebooks: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_LIST) {
          int _size21;
          [inProtocol readListBeginReturningElementType: NULL size: &_size21];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size21];
          int _i22;
          for (_i22 = 0; _i22 < _size21; ++_i22)
          {
            NSString * _elem23 = [inProtocol readString];
            [fieldValue addObject: _elem23];
          }
          [inProtocol readListEnd];
          [self setExpungedTags: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_LIST) {
          int _size24;
          [inProtocol readListBeginReturningElementType: NULL size: &_size24];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size24];
          int _i25;
          for (_i25 = 0; _i25 < _size24; ++_i25)
          {
            NSString * _elem26 = [inProtocol readString];
            [fieldValue addObject: _elem26];
          }
          [inProtocol readListEnd];
          [self setExpungedSearches: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 13:
        if (fieldType == TType_LIST) {
          int _size27;
          [inProtocol readListBeginReturningElementType: NULL size: &_size27];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size27];
          int _i28;
          for (_i28 = 0; _i28 < _size27; ++_i28)
          {
            EDAMLinkedNotebook *_elem29 = [[EDAMLinkedNotebook alloc] init];
            [_elem29 read: inProtocol];
            [fieldValue addObject: _elem29];
            [_elem29 release];
          }
          [inProtocol readListEnd];
          [self setLinkedNotebooks: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 14:
        if (fieldType == TType_LIST) {
          int _size30;
          [inProtocol readListBeginReturningElementType: NULL size: &_size30];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size30];
          int _i31;
          for (_i31 = 0; _i31 < _size30; ++_i31)
          {
            NSString * _elem32 = [inProtocol readString];
            [fieldValue addObject: _elem32];
          }
          [inProtocol readListEnd];
          [self setExpungedLinkedNotebooks: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SyncChunk"];
  if (__currentTime_isset) {
    [outProtocol writeFieldBeginWithName: @"currentTime" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __currentTime];
    [outProtocol writeFieldEnd];
  }
  if (__chunkHighUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"chunkHighUSN" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __chunkHighUSN];
    [outProtocol writeFieldEnd];
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        int i34;
        for (i34 = 0; i34 < [__notes count]; i34++)
        {
          [[__notes objectAtIndex: i34] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebooks_isset) {
    if (__notebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"notebooks" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notebooks count]];
        int i36;
        for (i36 = 0; i36 < [__notebooks count]; i36++)
        {
          [[__notebooks objectAtIndex: i36] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__tags_isset) {
    if (__tags != nil) {
      [outProtocol writeFieldBeginWithName: @"tags" type: TType_LIST fieldID: 6];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__tags count]];
        int i38;
        for (i38 = 0; i38 < [__tags count]; i38++)
        {
          [[__tags objectAtIndex: i38] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__searches_isset) {
    if (__searches != nil) {
      [outProtocol writeFieldBeginWithName: @"searches" type: TType_LIST fieldID: 7];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__searches count]];
        int i40;
        for (i40 = 0; i40 < [__searches count]; i40++)
        {
          [[__searches objectAtIndex: i40] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__resources_isset) {
    if (__resources != nil) {
      [outProtocol writeFieldBeginWithName: @"resources" type: TType_LIST fieldID: 8];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__resources count]];
        int i42;
        for (i42 = 0; i42 < [__resources count]; i42++)
        {
          [[__resources objectAtIndex: i42] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedNotes_isset) {
    if (__expungedNotes != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedNotes" type: TType_LIST fieldID: 9];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedNotes count]];
        int i44;
        for (i44 = 0; i44 < [__expungedNotes count]; i44++)
        {
          [outProtocol writeString: [__expungedNotes objectAtIndex: i44]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedNotebooks_isset) {
    if (__expungedNotebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedNotebooks" type: TType_LIST fieldID: 10];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedNotebooks count]];
        int i46;
        for (i46 = 0; i46 < [__expungedNotebooks count]; i46++)
        {
          [outProtocol writeString: [__expungedNotebooks objectAtIndex: i46]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedTags_isset) {
    if (__expungedTags != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedTags" type: TType_LIST fieldID: 11];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedTags count]];
        int i48;
        for (i48 = 0; i48 < [__expungedTags count]; i48++)
        {
          [outProtocol writeString: [__expungedTags objectAtIndex: i48]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedSearches_isset) {
    if (__expungedSearches != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedSearches" type: TType_LIST fieldID: 12];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedSearches count]];
        int i50;
        for (i50 = 0; i50 < [__expungedSearches count]; i50++)
        {
          [outProtocol writeString: [__expungedSearches objectAtIndex: i50]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebooks_isset) {
    if (__linkedNotebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebooks" type: TType_LIST fieldID: 13];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__linkedNotebooks count]];
        int i52;
        for (i52 = 0; i52 < [__linkedNotebooks count]; i52++)
        {
          [[__linkedNotebooks objectAtIndex: i52] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__expungedLinkedNotebooks_isset) {
    if (__expungedLinkedNotebooks != nil) {
      [outProtocol writeFieldBeginWithName: @"expungedLinkedNotebooks" type: TType_LIST fieldID: 14];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__expungedLinkedNotebooks count]];
        int i54;
        for (i54 = 0; i54 < [__expungedLinkedNotebooks count]; i54++)
        {
          [outProtocol writeString: [__expungedLinkedNotebooks objectAtIndex: i54]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SyncChunk("];
  [ms appendString: @"currentTime:"];
  [ms appendFormat: @"%qi", __currentTime];
  [ms appendString: @",chunkHighUSN:"];
  [ms appendFormat: @"%i", __chunkHighUSN];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @",notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",notebooks:"];
  [ms appendFormat: @"%@", __notebooks];
  [ms appendString: @",tags:"];
  [ms appendFormat: @"%@", __tags];
  [ms appendString: @",searches:"];
  [ms appendFormat: @"%@", __searches];
  [ms appendString: @",resources:"];
  [ms appendFormat: @"%@", __resources];
  [ms appendString: @",expungedNotes:"];
  [ms appendFormat: @"%@", __expungedNotes];
  [ms appendString: @",expungedNotebooks:"];
  [ms appendFormat: @"%@", __expungedNotebooks];
  [ms appendString: @",expungedTags:"];
  [ms appendFormat: @"%@", __expungedTags];
  [ms appendString: @",expungedSearches:"];
  [ms appendFormat: @"%@", __expungedSearches];
  [ms appendString: @",linkedNotebooks:"];
  [ms appendFormat: @"%@", __linkedNotebooks];
  [ms appendString: @",expungedLinkedNotebooks:"];
  [ms appendFormat: @"%@", __expungedLinkedNotebooks];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMSyncChunkFilter

- (id) initWithIncludeNotes: (BOOL) includeNotes includeNoteResources: (BOOL) includeNoteResources includeNoteAttributes: (BOOL) includeNoteAttributes includeNotebooks: (BOOL) includeNotebooks includeTags: (BOOL) includeTags includeSearches: (BOOL) includeSearches includeResources: (BOOL) includeResources includeLinkedNotebooks: (BOOL) includeLinkedNotebooks includeExpunged: (BOOL) includeExpunged includeNoteApplicationDataFullMap: (BOOL) includeNoteApplicationDataFullMap includeResourceApplicationDataFullMap: (BOOL) includeResourceApplicationDataFullMap includeNoteResourceApplicationDataFullMap: (BOOL) includeNoteResourceApplicationDataFullMap requireNoteContentClass: (NSString *) requireNoteContentClass
{
  self = [super init];
  __includeNotes = includeNotes;
  __includeNotes_isset = YES;
  __includeNoteResources = includeNoteResources;
  __includeNoteResources_isset = YES;
  __includeNoteAttributes = includeNoteAttributes;
  __includeNoteAttributes_isset = YES;
  __includeNotebooks = includeNotebooks;
  __includeNotebooks_isset = YES;
  __includeTags = includeTags;
  __includeTags_isset = YES;
  __includeSearches = includeSearches;
  __includeSearches_isset = YES;
  __includeResources = includeResources;
  __includeResources_isset = YES;
  __includeLinkedNotebooks = includeLinkedNotebooks;
  __includeLinkedNotebooks_isset = YES;
  __includeExpunged = includeExpunged;
  __includeExpunged_isset = YES;
  __includeNoteApplicationDataFullMap = includeNoteApplicationDataFullMap;
  __includeNoteApplicationDataFullMap_isset = YES;
  __includeResourceApplicationDataFullMap = includeResourceApplicationDataFullMap;
  __includeResourceApplicationDataFullMap_isset = YES;
  __includeNoteResourceApplicationDataFullMap = includeNoteResourceApplicationDataFullMap;
  __includeNoteResourceApplicationDataFullMap_isset = YES;
  __requireNoteContentClass = [requireNoteContentClass retain];
  __requireNoteContentClass_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"includeNotes"])
  {
    __includeNotes = [decoder decodeBoolForKey: @"includeNotes"];
    __includeNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNoteResources"])
  {
    __includeNoteResources = [decoder decodeBoolForKey: @"includeNoteResources"];
    __includeNoteResources_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNoteAttributes"])
  {
    __includeNoteAttributes = [decoder decodeBoolForKey: @"includeNoteAttributes"];
    __includeNoteAttributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNotebooks"])
  {
    __includeNotebooks = [decoder decodeBoolForKey: @"includeNotebooks"];
    __includeNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeTags"])
  {
    __includeTags = [decoder decodeBoolForKey: @"includeTags"];
    __includeTags_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeSearches"])
  {
    __includeSearches = [decoder decodeBoolForKey: @"includeSearches"];
    __includeSearches_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeResources"])
  {
    __includeResources = [decoder decodeBoolForKey: @"includeResources"];
    __includeResources_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeLinkedNotebooks"])
  {
    __includeLinkedNotebooks = [decoder decodeBoolForKey: @"includeLinkedNotebooks"];
    __includeLinkedNotebooks_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeExpunged"])
  {
    __includeExpunged = [decoder decodeBoolForKey: @"includeExpunged"];
    __includeExpunged_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNoteApplicationDataFullMap"])
  {
    __includeNoteApplicationDataFullMap = [decoder decodeBoolForKey: @"includeNoteApplicationDataFullMap"];
    __includeNoteApplicationDataFullMap_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeResourceApplicationDataFullMap"])
  {
    __includeResourceApplicationDataFullMap = [decoder decodeBoolForKey: @"includeResourceApplicationDataFullMap"];
    __includeResourceApplicationDataFullMap_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNoteResourceApplicationDataFullMap"])
  {
    __includeNoteResourceApplicationDataFullMap = [decoder decodeBoolForKey: @"includeNoteResourceApplicationDataFullMap"];
    __includeNoteResourceApplicationDataFullMap_isset = YES;
  }
  if ([decoder containsValueForKey: @"requireNoteContentClass"])
  {
    __requireNoteContentClass = [[decoder decodeObjectForKey: @"requireNoteContentClass"] retain];
    __requireNoteContentClass_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__includeNotes_isset)
  {
    [encoder encodeBool: __includeNotes forKey: @"includeNotes"];
  }
  if (__includeNoteResources_isset)
  {
    [encoder encodeBool: __includeNoteResources forKey: @"includeNoteResources"];
  }
  if (__includeNoteAttributes_isset)
  {
    [encoder encodeBool: __includeNoteAttributes forKey: @"includeNoteAttributes"];
  }
  if (__includeNotebooks_isset)
  {
    [encoder encodeBool: __includeNotebooks forKey: @"includeNotebooks"];
  }
  if (__includeTags_isset)
  {
    [encoder encodeBool: __includeTags forKey: @"includeTags"];
  }
  if (__includeSearches_isset)
  {
    [encoder encodeBool: __includeSearches forKey: @"includeSearches"];
  }
  if (__includeResources_isset)
  {
    [encoder encodeBool: __includeResources forKey: @"includeResources"];
  }
  if (__includeLinkedNotebooks_isset)
  {
    [encoder encodeBool: __includeLinkedNotebooks forKey: @"includeLinkedNotebooks"];
  }
  if (__includeExpunged_isset)
  {
    [encoder encodeBool: __includeExpunged forKey: @"includeExpunged"];
  }
  if (__includeNoteApplicationDataFullMap_isset)
  {
    [encoder encodeBool: __includeNoteApplicationDataFullMap forKey: @"includeNoteApplicationDataFullMap"];
  }
  if (__includeResourceApplicationDataFullMap_isset)
  {
    [encoder encodeBool: __includeResourceApplicationDataFullMap forKey: @"includeResourceApplicationDataFullMap"];
  }
  if (__includeNoteResourceApplicationDataFullMap_isset)
  {
    [encoder encodeBool: __includeNoteResourceApplicationDataFullMap forKey: @"includeNoteResourceApplicationDataFullMap"];
  }
  if (__requireNoteContentClass_isset)
  {
    [encoder encodeObject: __requireNoteContentClass forKey: @"requireNoteContentClass"];
  }
}

- (void) dealloc
{
  [__requireNoteContentClass release];
  [super dealloc];
}

- (BOOL) includeNotes {
  return __includeNotes;
}

- (void) setIncludeNotes: (BOOL) includeNotes {
  __includeNotes = includeNotes;
  __includeNotes_isset = YES;
}

- (BOOL) includeNotesIsSet {
  return __includeNotes_isset;
}

- (void) unsetIncludeNotes {
  __includeNotes_isset = NO;
}

- (BOOL) includeNoteResources {
  return __includeNoteResources;
}

- (void) setIncludeNoteResources: (BOOL) includeNoteResources {
  __includeNoteResources = includeNoteResources;
  __includeNoteResources_isset = YES;
}

- (BOOL) includeNoteResourcesIsSet {
  return __includeNoteResources_isset;
}

- (void) unsetIncludeNoteResources {
  __includeNoteResources_isset = NO;
}

- (BOOL) includeNoteAttributes {
  return __includeNoteAttributes;
}

- (void) setIncludeNoteAttributes: (BOOL) includeNoteAttributes {
  __includeNoteAttributes = includeNoteAttributes;
  __includeNoteAttributes_isset = YES;
}

- (BOOL) includeNoteAttributesIsSet {
  return __includeNoteAttributes_isset;
}

- (void) unsetIncludeNoteAttributes {
  __includeNoteAttributes_isset = NO;
}

- (BOOL) includeNotebooks {
  return __includeNotebooks;
}

- (void) setIncludeNotebooks: (BOOL) includeNotebooks {
  __includeNotebooks = includeNotebooks;
  __includeNotebooks_isset = YES;
}

- (BOOL) includeNotebooksIsSet {
  return __includeNotebooks_isset;
}

- (void) unsetIncludeNotebooks {
  __includeNotebooks_isset = NO;
}

- (BOOL) includeTags {
  return __includeTags;
}

- (void) setIncludeTags: (BOOL) includeTags {
  __includeTags = includeTags;
  __includeTags_isset = YES;
}

- (BOOL) includeTagsIsSet {
  return __includeTags_isset;
}

- (void) unsetIncludeTags {
  __includeTags_isset = NO;
}

- (BOOL) includeSearches {
  return __includeSearches;
}

- (void) setIncludeSearches: (BOOL) includeSearches {
  __includeSearches = includeSearches;
  __includeSearches_isset = YES;
}

- (BOOL) includeSearchesIsSet {
  return __includeSearches_isset;
}

- (void) unsetIncludeSearches {
  __includeSearches_isset = NO;
}

- (BOOL) includeResources {
  return __includeResources;
}

- (void) setIncludeResources: (BOOL) includeResources {
  __includeResources = includeResources;
  __includeResources_isset = YES;
}

- (BOOL) includeResourcesIsSet {
  return __includeResources_isset;
}

- (void) unsetIncludeResources {
  __includeResources_isset = NO;
}

- (BOOL) includeLinkedNotebooks {
  return __includeLinkedNotebooks;
}

- (void) setIncludeLinkedNotebooks: (BOOL) includeLinkedNotebooks {
  __includeLinkedNotebooks = includeLinkedNotebooks;
  __includeLinkedNotebooks_isset = YES;
}

- (BOOL) includeLinkedNotebooksIsSet {
  return __includeLinkedNotebooks_isset;
}

- (void) unsetIncludeLinkedNotebooks {
  __includeLinkedNotebooks_isset = NO;
}

- (BOOL) includeExpunged {
  return __includeExpunged;
}

- (void) setIncludeExpunged: (BOOL) includeExpunged {
  __includeExpunged = includeExpunged;
  __includeExpunged_isset = YES;
}

- (BOOL) includeExpungedIsSet {
  return __includeExpunged_isset;
}

- (void) unsetIncludeExpunged {
  __includeExpunged_isset = NO;
}

- (BOOL) includeNoteApplicationDataFullMap {
  return __includeNoteApplicationDataFullMap;
}

- (void) setIncludeNoteApplicationDataFullMap: (BOOL) includeNoteApplicationDataFullMap {
  __includeNoteApplicationDataFullMap = includeNoteApplicationDataFullMap;
  __includeNoteApplicationDataFullMap_isset = YES;
}

- (BOOL) includeNoteApplicationDataFullMapIsSet {
  return __includeNoteApplicationDataFullMap_isset;
}

- (void) unsetIncludeNoteApplicationDataFullMap {
  __includeNoteApplicationDataFullMap_isset = NO;
}

- (BOOL) includeResourceApplicationDataFullMap {
  return __includeResourceApplicationDataFullMap;
}

- (void) setIncludeResourceApplicationDataFullMap: (BOOL) includeResourceApplicationDataFullMap {
  __includeResourceApplicationDataFullMap = includeResourceApplicationDataFullMap;
  __includeResourceApplicationDataFullMap_isset = YES;
}

- (BOOL) includeResourceApplicationDataFullMapIsSet {
  return __includeResourceApplicationDataFullMap_isset;
}

- (void) unsetIncludeResourceApplicationDataFullMap {
  __includeResourceApplicationDataFullMap_isset = NO;
}

- (BOOL) includeNoteResourceApplicationDataFullMap {
  return __includeNoteResourceApplicationDataFullMap;
}

- (void) setIncludeNoteResourceApplicationDataFullMap: (BOOL) includeNoteResourceApplicationDataFullMap {
  __includeNoteResourceApplicationDataFullMap = includeNoteResourceApplicationDataFullMap;
  __includeNoteResourceApplicationDataFullMap_isset = YES;
}

- (BOOL) includeNoteResourceApplicationDataFullMapIsSet {
  return __includeNoteResourceApplicationDataFullMap_isset;
}

- (void) unsetIncludeNoteResourceApplicationDataFullMap {
  __includeNoteResourceApplicationDataFullMap_isset = NO;
}

- (NSString *) requireNoteContentClass {
  return [[__requireNoteContentClass retain] autorelease];
}

- (void) setRequireNoteContentClass: (NSString *) requireNoteContentClass {
  [requireNoteContentClass retain];
  [__requireNoteContentClass release];
  __requireNoteContentClass = requireNoteContentClass;
  __requireNoteContentClass_isset = YES;
}

- (BOOL) requireNoteContentClassIsSet {
  return __requireNoteContentClass_isset;
}

- (void) unsetRequireNoteContentClass {
  [__requireNoteContentClass release];
  __requireNoteContentClass = nil;
  __requireNoteContentClass_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNoteResources: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNoteAttributes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNotebooks: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeTags: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeSearches: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeResources: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 8:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeLinkedNotebooks: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 9:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeExpunged: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNoteApplicationDataFullMap: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeResourceApplicationDataFullMap: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 13:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNoteResourceApplicationDataFullMap: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setRequireNoteContentClass: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SyncChunkFilter"];
  if (__includeNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNotes" type: TType_BOOL fieldID: 1];
    [outProtocol writeBool: __includeNotes];
    [outProtocol writeFieldEnd];
  }
  if (__includeNoteResources_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNoteResources" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __includeNoteResources];
    [outProtocol writeFieldEnd];
  }
  if (__includeNoteAttributes_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNoteAttributes" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __includeNoteAttributes];
    [outProtocol writeFieldEnd];
  }
  if (__includeNotebooks_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNotebooks" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __includeNotebooks];
    [outProtocol writeFieldEnd];
  }
  if (__includeTags_isset) {
    [outProtocol writeFieldBeginWithName: @"includeTags" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __includeTags];
    [outProtocol writeFieldEnd];
  }
  if (__includeSearches_isset) {
    [outProtocol writeFieldBeginWithName: @"includeSearches" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __includeSearches];
    [outProtocol writeFieldEnd];
  }
  if (__includeResources_isset) {
    [outProtocol writeFieldBeginWithName: @"includeResources" type: TType_BOOL fieldID: 7];
    [outProtocol writeBool: __includeResources];
    [outProtocol writeFieldEnd];
  }
  if (__includeLinkedNotebooks_isset) {
    [outProtocol writeFieldBeginWithName: @"includeLinkedNotebooks" type: TType_BOOL fieldID: 8];
    [outProtocol writeBool: __includeLinkedNotebooks];
    [outProtocol writeFieldEnd];
  }
  if (__includeExpunged_isset) {
    [outProtocol writeFieldBeginWithName: @"includeExpunged" type: TType_BOOL fieldID: 9];
    [outProtocol writeBool: __includeExpunged];
    [outProtocol writeFieldEnd];
  }
  if (__includeNoteApplicationDataFullMap_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNoteApplicationDataFullMap" type: TType_BOOL fieldID: 10];
    [outProtocol writeBool: __includeNoteApplicationDataFullMap];
    [outProtocol writeFieldEnd];
  }
  if (__includeResourceApplicationDataFullMap_isset) {
    [outProtocol writeFieldBeginWithName: @"includeResourceApplicationDataFullMap" type: TType_BOOL fieldID: 12];
    [outProtocol writeBool: __includeResourceApplicationDataFullMap];
    [outProtocol writeFieldEnd];
  }
  if (__includeNoteResourceApplicationDataFullMap_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNoteResourceApplicationDataFullMap" type: TType_BOOL fieldID: 13];
    [outProtocol writeBool: __includeNoteResourceApplicationDataFullMap];
    [outProtocol writeFieldEnd];
  }
  if (__requireNoteContentClass_isset) {
    if (__requireNoteContentClass != nil) {
      [outProtocol writeFieldBeginWithName: @"requireNoteContentClass" type: TType_STRING fieldID: 11];
      [outProtocol writeString: __requireNoteContentClass];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SyncChunkFilter("];
  [ms appendString: @"includeNotes:"];
  [ms appendFormat: @"%i", __includeNotes];
  [ms appendString: @",includeNoteResources:"];
  [ms appendFormat: @"%i", __includeNoteResources];
  [ms appendString: @",includeNoteAttributes:"];
  [ms appendFormat: @"%i", __includeNoteAttributes];
  [ms appendString: @",includeNotebooks:"];
  [ms appendFormat: @"%i", __includeNotebooks];
  [ms appendString: @",includeTags:"];
  [ms appendFormat: @"%i", __includeTags];
  [ms appendString: @",includeSearches:"];
  [ms appendFormat: @"%i", __includeSearches];
  [ms appendString: @",includeResources:"];
  [ms appendFormat: @"%i", __includeResources];
  [ms appendString: @",includeLinkedNotebooks:"];
  [ms appendFormat: @"%i", __includeLinkedNotebooks];
  [ms appendString: @",includeExpunged:"];
  [ms appendFormat: @"%i", __includeExpunged];
  [ms appendString: @",includeNoteApplicationDataFullMap:"];
  [ms appendFormat: @"%i", __includeNoteApplicationDataFullMap];
  [ms appendString: @",includeResourceApplicationDataFullMap:"];
  [ms appendFormat: @"%i", __includeResourceApplicationDataFullMap];
  [ms appendString: @",includeNoteResourceApplicationDataFullMap:"];
  [ms appendFormat: @"%i", __includeNoteResourceApplicationDataFullMap];
  [ms appendString: @",requireNoteContentClass:"];
  [ms appendFormat: @"\"%@\"", __requireNoteContentClass];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteFilter

- (id) initWithOrder: (int32_t) order ascending: (BOOL) ascending words: (NSString *) words notebookGuid: (EDAMGuid) notebookGuid tagGuids: (NSArray *) tagGuids timeZone: (NSString *) timeZone inactive: (BOOL) inactive
{
  self = [super init];
  __order = order;
  __order_isset = YES;
  __ascending = ascending;
  __ascending_isset = YES;
  __words = [words retain];
  __words_isset = YES;
  __notebookGuid = [notebookGuid retain];
  __notebookGuid_isset = YES;
  __tagGuids = [tagGuids retain];
  __tagGuids_isset = YES;
  __timeZone = [timeZone retain];
  __timeZone_isset = YES;
  __inactive = inactive;
  __inactive_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"order"])
  {
    __order = [decoder decodeInt32ForKey: @"order"];
    __order_isset = YES;
  }
  if ([decoder containsValueForKey: @"ascending"])
  {
    __ascending = [decoder decodeBoolForKey: @"ascending"];
    __ascending_isset = YES;
  }
  if ([decoder containsValueForKey: @"words"])
  {
    __words = [[decoder decodeObjectForKey: @"words"] retain];
    __words_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain];
    __notebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"tagGuids"])
  {
    __tagGuids = [[decoder decodeObjectForKey: @"tagGuids"] retain];
    __tagGuids_isset = YES;
  }
  if ([decoder containsValueForKey: @"timeZone"])
  {
    __timeZone = [[decoder decodeObjectForKey: @"timeZone"] retain];
    __timeZone_isset = YES;
  }
  if ([decoder containsValueForKey: @"inactive"])
  {
    __inactive = [decoder decodeBoolForKey: @"inactive"];
    __inactive_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__order_isset)
  {
    [encoder encodeInt32: __order forKey: @"order"];
  }
  if (__ascending_isset)
  {
    [encoder encodeBool: __ascending forKey: @"ascending"];
  }
  if (__words_isset)
  {
    [encoder encodeObject: __words forKey: @"words"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
  if (__tagGuids_isset)
  {
    [encoder encodeObject: __tagGuids forKey: @"tagGuids"];
  }
  if (__timeZone_isset)
  {
    [encoder encodeObject: __timeZone forKey: @"timeZone"];
  }
  if (__inactive_isset)
  {
    [encoder encodeBool: __inactive forKey: @"inactive"];
  }
}

- (void) dealloc
{
  [__words release];
  [__notebookGuid release];
  [__tagGuids release];
  [__timeZone release];
  [super dealloc];
}

- (int32_t) order {
  return __order;
}

- (void) setOrder: (int32_t) order {
  __order = order;
  __order_isset = YES;
}

- (BOOL) orderIsSet {
  return __order_isset;
}

- (void) unsetOrder {
  __order_isset = NO;
}

- (BOOL) ascending {
  return __ascending;
}

- (void) setAscending: (BOOL) ascending {
  __ascending = ascending;
  __ascending_isset = YES;
}

- (BOOL) ascendingIsSet {
  return __ascending_isset;
}

- (void) unsetAscending {
  __ascending_isset = NO;
}

- (NSString *) words {
  return [[__words retain] autorelease];
}

- (void) setWords: (NSString *) words {
  [words retain];
  [__words release];
  __words = words;
  __words_isset = YES;
}

- (BOOL) wordsIsSet {
  return __words_isset;
}

- (void) unsetWords {
  [__words release];
  __words = nil;
  __words_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain] autorelease];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain];
  [__notebookGuid release];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (NSArray *) tagGuids {
  return [[__tagGuids retain] autorelease];
}

- (void) setTagGuids: (NSArray *) tagGuids {
  [tagGuids retain];
  [__tagGuids release];
  __tagGuids = tagGuids;
  __tagGuids_isset = YES;
}

- (BOOL) tagGuidsIsSet {
  return __tagGuids_isset;
}

- (void) unsetTagGuids {
  [__tagGuids release];
  __tagGuids = nil;
  __tagGuids_isset = NO;
}

- (NSString *) timeZone {
  return [[__timeZone retain] autorelease];
}

- (void) setTimeZone: (NSString *) timeZone {
  [timeZone retain];
  [__timeZone release];
  __timeZone = timeZone;
  __timeZone_isset = YES;
}

- (BOOL) timeZoneIsSet {
  return __timeZone_isset;
}

- (void) unsetTimeZone {
  [__timeZone release];
  __timeZone = nil;
  __timeZone_isset = NO;
}

- (BOOL) inactive {
  return __inactive;
}

- (void) setInactive: (BOOL) inactive {
  __inactive = inactive;
  __inactive_isset = YES;
}

- (BOOL) inactiveIsSet {
  return __inactive_isset;
}

- (void) unsetInactive {
  __inactive_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOrder: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setAscending: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setWords: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size55;
          [inProtocol readListBeginReturningElementType: NULL size: &_size55];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size55];
          int _i56;
          for (_i56 = 0; _i56 < _size55; ++_i56)
          {
            NSString * _elem57 = [inProtocol readString];
            [fieldValue addObject: _elem57];
          }
          [inProtocol readListEnd];
          [self setTagGuids: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTimeZone: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setInactive: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteFilter"];
  if (__order_isset) {
    [outProtocol writeFieldBeginWithName: @"order" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __order];
    [outProtocol writeFieldEnd];
  }
  if (__ascending_isset) {
    [outProtocol writeFieldBeginWithName: @"ascending" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __ascending];
    [outProtocol writeFieldEnd];
  }
  if (__words_isset) {
    if (__words != nil) {
      [outProtocol writeFieldBeginWithName: @"words" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __words];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tagGuids_isset) {
    if (__tagGuids != nil) {
      [outProtocol writeFieldBeginWithName: @"tagGuids" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__tagGuids count]];
        int i59;
        for (i59 = 0; i59 < [__tagGuids count]; i59++)
        {
          [outProtocol writeString: [__tagGuids objectAtIndex: i59]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__timeZone_isset) {
    if (__timeZone != nil) {
      [outProtocol writeFieldBeginWithName: @"timeZone" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __timeZone];
      [outProtocol writeFieldEnd];
    }
  }
  if (__inactive_isset) {
    [outProtocol writeFieldBeginWithName: @"inactive" type: TType_BOOL fieldID: 7];
    [outProtocol writeBool: __inactive];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteFilter("];
  [ms appendString: @"order:"];
  [ms appendFormat: @"%i", __order];
  [ms appendString: @",ascending:"];
  [ms appendFormat: @"%i", __ascending];
  [ms appendString: @",words:"];
  [ms appendFormat: @"\"%@\"", __words];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @",tagGuids:"];
  [ms appendFormat: @"%@", __tagGuids];
  [ms appendString: @",timeZone:"];
  [ms appendFormat: @"\"%@\"", __timeZone];
  [ms appendString: @",inactive:"];
  [ms appendFormat: @"%i", __inactive];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteList

- (id) initWithStartIndex: (int32_t) startIndex totalNotes: (int32_t) totalNotes notes: (NSArray *) notes stoppedWords: (NSArray *) stoppedWords searchedWords: (NSArray *) searchedWords updateCount: (int32_t) updateCount
{
  self = [super init];
  __startIndex = startIndex;
  __startIndex_isset = YES;
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
  __notes = [notes retain];
  __notes_isset = YES;
  __stoppedWords = [stoppedWords retain];
  __stoppedWords_isset = YES;
  __searchedWords = [searchedWords retain];
  __searchedWords_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"startIndex"])
  {
    __startIndex = [decoder decodeInt32ForKey: @"startIndex"];
    __startIndex_isset = YES;
  }
  if ([decoder containsValueForKey: @"totalNotes"])
  {
    __totalNotes = [decoder decodeInt32ForKey: @"totalNotes"];
    __totalNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"stoppedWords"])
  {
    __stoppedWords = [[decoder decodeObjectForKey: @"stoppedWords"] retain];
    __stoppedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"searchedWords"])
  {
    __searchedWords = [[decoder decodeObjectForKey: @"searchedWords"] retain];
    __searchedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__startIndex_isset)
  {
    [encoder encodeInt32: __startIndex forKey: @"startIndex"];
  }
  if (__totalNotes_isset)
  {
    [encoder encodeInt32: __totalNotes forKey: @"totalNotes"];
  }
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__stoppedWords_isset)
  {
    [encoder encodeObject: __stoppedWords forKey: @"stoppedWords"];
  }
  if (__searchedWords_isset)
  {
    [encoder encodeObject: __searchedWords forKey: @"searchedWords"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
}

- (void) dealloc
{
  [__notes release];
  [__stoppedWords release];
  [__searchedWords release];
  [super dealloc];
}

- (int32_t) startIndex {
  return __startIndex;
}

- (void) setStartIndex: (int32_t) startIndex {
  __startIndex = startIndex;
  __startIndex_isset = YES;
}

- (BOOL) startIndexIsSet {
  return __startIndex_isset;
}

- (void) unsetStartIndex {
  __startIndex_isset = NO;
}

- (int32_t) totalNotes {
  return __totalNotes;
}

- (void) setTotalNotes: (int32_t) totalNotes {
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
}

- (BOOL) totalNotesIsSet {
  return __totalNotes_isset;
}

- (void) unsetTotalNotes {
  __totalNotes_isset = NO;
}

- (NSArray *) notes {
  return [[__notes retain] autorelease];
}

- (void) setNotes: (NSArray *) notes {
  [notes retain];
  [__notes release];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release];
  __notes = nil;
  __notes_isset = NO;
}

- (NSArray *) stoppedWords {
  return [[__stoppedWords retain] autorelease];
}

- (void) setStoppedWords: (NSArray *) stoppedWords {
  [stoppedWords retain];
  [__stoppedWords release];
  __stoppedWords = stoppedWords;
  __stoppedWords_isset = YES;
}

- (BOOL) stoppedWordsIsSet {
  return __stoppedWords_isset;
}

- (void) unsetStoppedWords {
  [__stoppedWords release];
  __stoppedWords = nil;
  __stoppedWords_isset = NO;
}

- (NSArray *) searchedWords {
  return [[__searchedWords retain] autorelease];
}

- (void) setSearchedWords: (NSArray *) searchedWords {
  [searchedWords retain];
  [__searchedWords release];
  __searchedWords = searchedWords;
  __searchedWords_isset = YES;
}

- (BOOL) searchedWordsIsSet {
  return __searchedWords_isset;
}

- (void) unsetSearchedWords {
  [__searchedWords release];
  __searchedWords = nil;
  __searchedWords_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setStartIndex: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTotalNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size60;
          [inProtocol readListBeginReturningElementType: NULL size: &_size60];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size60];
          int _i61;
          for (_i61 = 0; _i61 < _size60; ++_i61)
          {
            EDAMNote *_elem62 = [[EDAMNote alloc] init];
            [_elem62 read: inProtocol];
            [fieldValue addObject: _elem62];
            [_elem62 release];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size63;
          [inProtocol readListBeginReturningElementType: NULL size: &_size63];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size63];
          int _i64;
          for (_i64 = 0; _i64 < _size63; ++_i64)
          {
            NSString * _elem65 = [inProtocol readString];
            [fieldValue addObject: _elem65];
          }
          [inProtocol readListEnd];
          [self setStoppedWords: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size66;
          [inProtocol readListBeginReturningElementType: NULL size: &_size66];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size66];
          int _i67;
          for (_i67 = 0; _i67 < _size66; ++_i67)
          {
            NSString * _elem68 = [inProtocol readString];
            [fieldValue addObject: _elem68];
          }
          [inProtocol readListEnd];
          [self setSearchedWords: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteList"];
  if (__startIndex_isset) {
    [outProtocol writeFieldBeginWithName: @"startIndex" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __startIndex];
    [outProtocol writeFieldEnd];
  }
  if (__totalNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"totalNotes" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __totalNotes];
    [outProtocol writeFieldEnd];
  }
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        int i70;
        for (i70 = 0; i70 < [__notes count]; i70++)
        {
          [[__notes objectAtIndex: i70] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__stoppedWords_isset) {
    if (__stoppedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"stoppedWords" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__stoppedWords count]];
        int i72;
        for (i72 = 0; i72 < [__stoppedWords count]; i72++)
        {
          [outProtocol writeString: [__stoppedWords objectAtIndex: i72]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__searchedWords_isset) {
    if (__searchedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"searchedWords" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__searchedWords count]];
        int i74;
        for (i74 = 0; i74 < [__searchedWords count]; i74++)
        {
          [outProtocol writeString: [__searchedWords objectAtIndex: i74]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 6];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteList("];
  [ms appendString: @"startIndex:"];
  [ms appendFormat: @"%i", __startIndex];
  [ms appendString: @",totalNotes:"];
  [ms appendFormat: @"%i", __totalNotes];
  [ms appendString: @",notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",stoppedWords:"];
  [ms appendFormat: @"%@", __stoppedWords];
  [ms appendString: @",searchedWords:"];
  [ms appendFormat: @"%@", __searchedWords];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteMetadata

- (id) initWithGuid: (EDAMGuid) guid title: (NSString *) title contentLength: (int32_t) contentLength created: (EDAMTimestamp) created updated: (EDAMTimestamp) updated updateSequenceNum: (int32_t) updateSequenceNum notebookGuid: (NSString *) notebookGuid tagGuids: (NSArray *) tagGuids attributes: (EDAMNoteAttributes *) attributes largestResourceMime: (NSString *) largestResourceMime largestResourceSize: (int32_t) largestResourceSize
{
  self = [super init];
  __guid = [guid retain];
  __guid_isset = YES;
  __title = [title retain];
  __title_isset = YES;
  __contentLength = contentLength;
  __contentLength_isset = YES;
  __created = created;
  __created_isset = YES;
  __updated = updated;
  __updated_isset = YES;
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
  __notebookGuid = [notebookGuid retain];
  __notebookGuid_isset = YES;
  __tagGuids = [tagGuids retain];
  __tagGuids_isset = YES;
  __attributes = [attributes retain];
  __attributes_isset = YES;
  __largestResourceMime = [largestResourceMime retain];
  __largestResourceMime_isset = YES;
  __largestResourceSize = largestResourceSize;
  __largestResourceSize_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"title"])
  {
    __title = [[decoder decodeObjectForKey: @"title"] retain];
    __title_isset = YES;
  }
  if ([decoder containsValueForKey: @"contentLength"])
  {
    __contentLength = [decoder decodeInt32ForKey: @"contentLength"];
    __contentLength_isset = YES;
  }
  if ([decoder containsValueForKey: @"created"])
  {
    __created = [decoder decodeInt64ForKey: @"created"];
    __created_isset = YES;
  }
  if ([decoder containsValueForKey: @"updated"])
  {
    __updated = [decoder decodeInt64ForKey: @"updated"];
    __updated_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateSequenceNum"])
  {
    __updateSequenceNum = [decoder decodeInt32ForKey: @"updateSequenceNum"];
    __updateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain];
    __notebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"tagGuids"])
  {
    __tagGuids = [[decoder decodeObjectForKey: @"tagGuids"] retain];
    __tagGuids_isset = YES;
  }
  if ([decoder containsValueForKey: @"attributes"])
  {
    __attributes = [[decoder decodeObjectForKey: @"attributes"] retain];
    __attributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"largestResourceMime"])
  {
    __largestResourceMime = [[decoder decodeObjectForKey: @"largestResourceMime"] retain];
    __largestResourceMime_isset = YES;
  }
  if ([decoder containsValueForKey: @"largestResourceSize"])
  {
    __largestResourceSize = [decoder decodeInt32ForKey: @"largestResourceSize"];
    __largestResourceSize_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__title_isset)
  {
    [encoder encodeObject: __title forKey: @"title"];
  }
  if (__contentLength_isset)
  {
    [encoder encodeInt32: __contentLength forKey: @"contentLength"];
  }
  if (__created_isset)
  {
    [encoder encodeInt64: __created forKey: @"created"];
  }
  if (__updated_isset)
  {
    [encoder encodeInt64: __updated forKey: @"updated"];
  }
  if (__updateSequenceNum_isset)
  {
    [encoder encodeInt32: __updateSequenceNum forKey: @"updateSequenceNum"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
  if (__tagGuids_isset)
  {
    [encoder encodeObject: __tagGuids forKey: @"tagGuids"];
  }
  if (__attributes_isset)
  {
    [encoder encodeObject: __attributes forKey: @"attributes"];
  }
  if (__largestResourceMime_isset)
  {
    [encoder encodeObject: __largestResourceMime forKey: @"largestResourceMime"];
  }
  if (__largestResourceSize_isset)
  {
    [encoder encodeInt32: __largestResourceSize forKey: @"largestResourceSize"];
  }
}

- (void) dealloc
{
  [__guid release];
  [__title release];
  [__notebookGuid release];
  [__tagGuids release];
  [__attributes release];
  [__largestResourceMime release];
  [super dealloc];
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) title {
  return [[__title retain] autorelease];
}

- (void) setTitle: (NSString *) title {
  [title retain];
  [__title release];
  __title = title;
  __title_isset = YES;
}

- (BOOL) titleIsSet {
  return __title_isset;
}

- (void) unsetTitle {
  [__title release];
  __title = nil;
  __title_isset = NO;
}

- (int32_t) contentLength {
  return __contentLength;
}

- (void) setContentLength: (int32_t) contentLength {
  __contentLength = contentLength;
  __contentLength_isset = YES;
}

- (BOOL) contentLengthIsSet {
  return __contentLength_isset;
}

- (void) unsetContentLength {
  __contentLength_isset = NO;
}

- (int64_t) created {
  return __created;
}

- (void) setCreated: (int64_t) created {
  __created = created;
  __created_isset = YES;
}

- (BOOL) createdIsSet {
  return __created_isset;
}

- (void) unsetCreated {
  __created_isset = NO;
}

- (int64_t) updated {
  return __updated;
}

- (void) setUpdated: (int64_t) updated {
  __updated = updated;
  __updated_isset = YES;
}

- (BOOL) updatedIsSet {
  return __updated_isset;
}

- (void) unsetUpdated {
  __updated_isset = NO;
}

- (int32_t) updateSequenceNum {
  return __updateSequenceNum;
}

- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum {
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
}

- (BOOL) updateSequenceNumIsSet {
  return __updateSequenceNum_isset;
}

- (void) unsetUpdateSequenceNum {
  __updateSequenceNum_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain] autorelease];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain];
  [__notebookGuid release];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (NSArray *) tagGuids {
  return [[__tagGuids retain] autorelease];
}

- (void) setTagGuids: (NSArray *) tagGuids {
  [tagGuids retain];
  [__tagGuids release];
  __tagGuids = tagGuids;
  __tagGuids_isset = YES;
}

- (BOOL) tagGuidsIsSet {
  return __tagGuids_isset;
}

- (void) unsetTagGuids {
  [__tagGuids release];
  __tagGuids = nil;
  __tagGuids_isset = NO;
}

- (EDAMNoteAttributes *) attributes {
  return [[__attributes retain] autorelease];
}

- (void) setAttributes: (EDAMNoteAttributes *) attributes {
  [attributes retain];
  [__attributes release];
  __attributes = attributes;
  __attributes_isset = YES;
}

- (BOOL) attributesIsSet {
  return __attributes_isset;
}

- (void) unsetAttributes {
  [__attributes release];
  __attributes = nil;
  __attributes_isset = NO;
}

- (NSString *) largestResourceMime {
  return [[__largestResourceMime retain] autorelease];
}

- (void) setLargestResourceMime: (NSString *) largestResourceMime {
  [largestResourceMime retain];
  [__largestResourceMime release];
  __largestResourceMime = largestResourceMime;
  __largestResourceMime_isset = YES;
}

- (BOOL) largestResourceMimeIsSet {
  return __largestResourceMime_isset;
}

- (void) unsetLargestResourceMime {
  [__largestResourceMime release];
  __largestResourceMime = nil;
  __largestResourceMime_isset = NO;
}

- (int32_t) largestResourceSize {
  return __largestResourceSize;
}

- (void) setLargestResourceSize: (int32_t) largestResourceSize {
  __largestResourceSize = largestResourceSize;
  __largestResourceSize_isset = YES;
}

- (BOOL) largestResourceSizeIsSet {
  return __largestResourceSize_isset;
}

- (void) unsetLargestResourceSize {
  __largestResourceSize_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setContentLength: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setCreated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setUpdated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_LIST) {
          int _size75;
          [inProtocol readListBeginReturningElementType: NULL size: &_size75];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size75];
          int _i76;
          for (_i76 = 0; _i76 < _size75; ++_i76)
          {
            NSString * _elem77 = [inProtocol readString];
            [fieldValue addObject: _elem77];
          }
          [inProtocol readListEnd];
          [self setTagGuids: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 14:
        if (fieldType == TType_STRUCT) {
          EDAMNoteAttributes *fieldValue = [[EDAMNoteAttributes alloc] init];
          [fieldValue read: inProtocol];
          [self setAttributes: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 20:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setLargestResourceMime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 21:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setLargestResourceSize: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteMetadata"];
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__title_isset) {
    if (__title != nil) {
      [outProtocol writeFieldBeginWithName: @"title" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __title];
      [outProtocol writeFieldEnd];
    }
  }
  if (__contentLength_isset) {
    [outProtocol writeFieldBeginWithName: @"contentLength" type: TType_I32 fieldID: 5];
    [outProtocol writeI32: __contentLength];
    [outProtocol writeFieldEnd];
  }
  if (__created_isset) {
    [outProtocol writeFieldBeginWithName: @"created" type: TType_I64 fieldID: 6];
    [outProtocol writeI64: __created];
    [outProtocol writeFieldEnd];
  }
  if (__updated_isset) {
    [outProtocol writeFieldBeginWithName: @"updated" type: TType_I64 fieldID: 7];
    [outProtocol writeI64: __updated];
    [outProtocol writeFieldEnd];
  }
  if (__updateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 10];
    [outProtocol writeI32: __updateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 11];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tagGuids_isset) {
    if (__tagGuids != nil) {
      [outProtocol writeFieldBeginWithName: @"tagGuids" type: TType_LIST fieldID: 12];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__tagGuids count]];
        int i79;
        for (i79 = 0; i79 < [__tagGuids count]; i79++)
        {
          [outProtocol writeString: [__tagGuids objectAtIndex: i79]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__attributes_isset) {
    if (__attributes != nil) {
      [outProtocol writeFieldBeginWithName: @"attributes" type: TType_STRUCT fieldID: 14];
      [__attributes write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__largestResourceMime_isset) {
    if (__largestResourceMime != nil) {
      [outProtocol writeFieldBeginWithName: @"largestResourceMime" type: TType_STRING fieldID: 20];
      [outProtocol writeString: __largestResourceMime];
      [outProtocol writeFieldEnd];
    }
  }
  if (__largestResourceSize_isset) {
    [outProtocol writeFieldBeginWithName: @"largestResourceSize" type: TType_I32 fieldID: 21];
    [outProtocol writeI32: __largestResourceSize];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteMetadata("];
  [ms appendString: @"guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",title:"];
  [ms appendFormat: @"\"%@\"", __title];
  [ms appendString: @",contentLength:"];
  [ms appendFormat: @"%i", __contentLength];
  [ms appendString: @",created:"];
  [ms appendFormat: @"%qi", __created];
  [ms appendString: @",updated:"];
  [ms appendFormat: @"%qi", __updated];
  [ms appendString: @",updateSequenceNum:"];
  [ms appendFormat: @"%i", __updateSequenceNum];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @",tagGuids:"];
  [ms appendFormat: @"%@", __tagGuids];
  [ms appendString: @",attributes:"];
  [ms appendFormat: @"%@", __attributes];
  [ms appendString: @",largestResourceMime:"];
  [ms appendFormat: @"\"%@\"", __largestResourceMime];
  [ms appendString: @",largestResourceSize:"];
  [ms appendFormat: @"%i", __largestResourceSize];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNotesMetadataList

- (id) initWithStartIndex: (int32_t) startIndex totalNotes: (int32_t) totalNotes notes: (NSArray *) notes stoppedWords: (NSArray *) stoppedWords searchedWords: (NSArray *) searchedWords updateCount: (int32_t) updateCount
{
  self = [super init];
  __startIndex = startIndex;
  __startIndex_isset = YES;
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
  __notes = [notes retain];
  __notes_isset = YES;
  __stoppedWords = [stoppedWords retain];
  __stoppedWords_isset = YES;
  __searchedWords = [searchedWords retain];
  __searchedWords_isset = YES;
  __updateCount = updateCount;
  __updateCount_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"startIndex"])
  {
    __startIndex = [decoder decodeInt32ForKey: @"startIndex"];
    __startIndex_isset = YES;
  }
  if ([decoder containsValueForKey: @"totalNotes"])
  {
    __totalNotes = [decoder decodeInt32ForKey: @"totalNotes"];
    __totalNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"notes"])
  {
    __notes = [[decoder decodeObjectForKey: @"notes"] retain];
    __notes_isset = YES;
  }
  if ([decoder containsValueForKey: @"stoppedWords"])
  {
    __stoppedWords = [[decoder decodeObjectForKey: @"stoppedWords"] retain];
    __stoppedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"searchedWords"])
  {
    __searchedWords = [[decoder decodeObjectForKey: @"searchedWords"] retain];
    __searchedWords_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateCount"])
  {
    __updateCount = [decoder decodeInt32ForKey: @"updateCount"];
    __updateCount_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__startIndex_isset)
  {
    [encoder encodeInt32: __startIndex forKey: @"startIndex"];
  }
  if (__totalNotes_isset)
  {
    [encoder encodeInt32: __totalNotes forKey: @"totalNotes"];
  }
  if (__notes_isset)
  {
    [encoder encodeObject: __notes forKey: @"notes"];
  }
  if (__stoppedWords_isset)
  {
    [encoder encodeObject: __stoppedWords forKey: @"stoppedWords"];
  }
  if (__searchedWords_isset)
  {
    [encoder encodeObject: __searchedWords forKey: @"searchedWords"];
  }
  if (__updateCount_isset)
  {
    [encoder encodeInt32: __updateCount forKey: @"updateCount"];
  }
}

- (void) dealloc
{
  [__notes release];
  [__stoppedWords release];
  [__searchedWords release];
  [super dealloc];
}

- (int32_t) startIndex {
  return __startIndex;
}

- (void) setStartIndex: (int32_t) startIndex {
  __startIndex = startIndex;
  __startIndex_isset = YES;
}

- (BOOL) startIndexIsSet {
  return __startIndex_isset;
}

- (void) unsetStartIndex {
  __startIndex_isset = NO;
}

- (int32_t) totalNotes {
  return __totalNotes;
}

- (void) setTotalNotes: (int32_t) totalNotes {
  __totalNotes = totalNotes;
  __totalNotes_isset = YES;
}

- (BOOL) totalNotesIsSet {
  return __totalNotes_isset;
}

- (void) unsetTotalNotes {
  __totalNotes_isset = NO;
}

- (NSArray *) notes {
  return [[__notes retain] autorelease];
}

- (void) setNotes: (NSArray *) notes {
  [notes retain];
  [__notes release];
  __notes = notes;
  __notes_isset = YES;
}

- (BOOL) notesIsSet {
  return __notes_isset;
}

- (void) unsetNotes {
  [__notes release];
  __notes = nil;
  __notes_isset = NO;
}

- (NSArray *) stoppedWords {
  return [[__stoppedWords retain] autorelease];
}

- (void) setStoppedWords: (NSArray *) stoppedWords {
  [stoppedWords retain];
  [__stoppedWords release];
  __stoppedWords = stoppedWords;
  __stoppedWords_isset = YES;
}

- (BOOL) stoppedWordsIsSet {
  return __stoppedWords_isset;
}

- (void) unsetStoppedWords {
  [__stoppedWords release];
  __stoppedWords = nil;
  __stoppedWords_isset = NO;
}

- (NSArray *) searchedWords {
  return [[__searchedWords retain] autorelease];
}

- (void) setSearchedWords: (NSArray *) searchedWords {
  [searchedWords retain];
  [__searchedWords release];
  __searchedWords = searchedWords;
  __searchedWords_isset = YES;
}

- (BOOL) searchedWordsIsSet {
  return __searchedWords_isset;
}

- (void) unsetSearchedWords {
  [__searchedWords release];
  __searchedWords = nil;
  __searchedWords_isset = NO;
}

- (int32_t) updateCount {
  return __updateCount;
}

- (void) setUpdateCount: (int32_t) updateCount {
  __updateCount = updateCount;
  __updateCount_isset = YES;
}

- (BOOL) updateCountIsSet {
  return __updateCount_isset;
}

- (void) unsetUpdateCount {
  __updateCount_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setStartIndex: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTotalNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size80;
          [inProtocol readListBeginReturningElementType: NULL size: &_size80];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size80];
          int _i81;
          for (_i81 = 0; _i81 < _size80; ++_i81)
          {
            EDAMNoteMetadata *_elem82 = [[EDAMNoteMetadata alloc] init];
            [_elem82 read: inProtocol];
            [fieldValue addObject: _elem82];
            [_elem82 release];
          }
          [inProtocol readListEnd];
          [self setNotes: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size83;
          [inProtocol readListBeginReturningElementType: NULL size: &_size83];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size83];
          int _i84;
          for (_i84 = 0; _i84 < _size83; ++_i84)
          {
            NSString * _elem85 = [inProtocol readString];
            [fieldValue addObject: _elem85];
          }
          [inProtocol readListEnd];
          [self setStoppedWords: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_LIST) {
          int _size86;
          [inProtocol readListBeginReturningElementType: NULL size: &_size86];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size86];
          int _i87;
          for (_i87 = 0; _i87 < _size86; ++_i87)
          {
            NSString * _elem88 = [inProtocol readString];
            [fieldValue addObject: _elem88];
          }
          [inProtocol readListEnd];
          [self setSearchedWords: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NotesMetadataList"];
  if (__startIndex_isset) {
    [outProtocol writeFieldBeginWithName: @"startIndex" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __startIndex];
    [outProtocol writeFieldEnd];
  }
  if (__totalNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"totalNotes" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __totalNotes];
    [outProtocol writeFieldEnd];
  }
  if (__notes_isset) {
    if (__notes != nil) {
      [outProtocol writeFieldBeginWithName: @"notes" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__notes count]];
        int i90;
        for (i90 = 0; i90 < [__notes count]; i90++)
        {
          [[__notes objectAtIndex: i90] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__stoppedWords_isset) {
    if (__stoppedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"stoppedWords" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__stoppedWords count]];
        int i92;
        for (i92 = 0; i92 < [__stoppedWords count]; i92++)
        {
          [outProtocol writeString: [__stoppedWords objectAtIndex: i92]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__searchedWords_isset) {
    if (__searchedWords != nil) {
      [outProtocol writeFieldBeginWithName: @"searchedWords" type: TType_LIST fieldID: 5];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__searchedWords count]];
        int i94;
        for (i94 = 0; i94 < [__searchedWords count]; i94++)
        {
          [outProtocol writeString: [__searchedWords objectAtIndex: i94]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__updateCount_isset) {
    [outProtocol writeFieldBeginWithName: @"updateCount" type: TType_I32 fieldID: 6];
    [outProtocol writeI32: __updateCount];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NotesMetadataList("];
  [ms appendString: @"startIndex:"];
  [ms appendFormat: @"%i", __startIndex];
  [ms appendString: @",totalNotes:"];
  [ms appendFormat: @"%i", __totalNotes];
  [ms appendString: @",notes:"];
  [ms appendFormat: @"%@", __notes];
  [ms appendString: @",stoppedWords:"];
  [ms appendFormat: @"%@", __stoppedWords];
  [ms appendString: @",searchedWords:"];
  [ms appendFormat: @"%@", __searchedWords];
  [ms appendString: @",updateCount:"];
  [ms appendFormat: @"%i", __updateCount];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNotesMetadataResultSpec

- (id) initWithIncludeTitle: (BOOL) includeTitle includeContentLength: (BOOL) includeContentLength includeCreated: (BOOL) includeCreated includeUpdated: (BOOL) includeUpdated includeUpdateSequenceNum: (BOOL) includeUpdateSequenceNum includeNotebookGuid: (BOOL) includeNotebookGuid includeTagGuids: (BOOL) includeTagGuids includeAttributes: (BOOL) includeAttributes includeLargestResourceMime: (BOOL) includeLargestResourceMime includeLargestResourceSize: (BOOL) includeLargestResourceSize
{
  self = [super init];
  __includeTitle = includeTitle;
  __includeTitle_isset = YES;
  __includeContentLength = includeContentLength;
  __includeContentLength_isset = YES;
  __includeCreated = includeCreated;
  __includeCreated_isset = YES;
  __includeUpdated = includeUpdated;
  __includeUpdated_isset = YES;
  __includeUpdateSequenceNum = includeUpdateSequenceNum;
  __includeUpdateSequenceNum_isset = YES;
  __includeNotebookGuid = includeNotebookGuid;
  __includeNotebookGuid_isset = YES;
  __includeTagGuids = includeTagGuids;
  __includeTagGuids_isset = YES;
  __includeAttributes = includeAttributes;
  __includeAttributes_isset = YES;
  __includeLargestResourceMime = includeLargestResourceMime;
  __includeLargestResourceMime_isset = YES;
  __includeLargestResourceSize = includeLargestResourceSize;
  __includeLargestResourceSize_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"includeTitle"])
  {
    __includeTitle = [decoder decodeBoolForKey: @"includeTitle"];
    __includeTitle_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeContentLength"])
  {
    __includeContentLength = [decoder decodeBoolForKey: @"includeContentLength"];
    __includeContentLength_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeCreated"])
  {
    __includeCreated = [decoder decodeBoolForKey: @"includeCreated"];
    __includeCreated_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeUpdated"])
  {
    __includeUpdated = [decoder decodeBoolForKey: @"includeUpdated"];
    __includeUpdated_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeUpdateSequenceNum"])
  {
    __includeUpdateSequenceNum = [decoder decodeBoolForKey: @"includeUpdateSequenceNum"];
    __includeUpdateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeNotebookGuid"])
  {
    __includeNotebookGuid = [decoder decodeBoolForKey: @"includeNotebookGuid"];
    __includeNotebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeTagGuids"])
  {
    __includeTagGuids = [decoder decodeBoolForKey: @"includeTagGuids"];
    __includeTagGuids_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeAttributes"])
  {
    __includeAttributes = [decoder decodeBoolForKey: @"includeAttributes"];
    __includeAttributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeLargestResourceMime"])
  {
    __includeLargestResourceMime = [decoder decodeBoolForKey: @"includeLargestResourceMime"];
    __includeLargestResourceMime_isset = YES;
  }
  if ([decoder containsValueForKey: @"includeLargestResourceSize"])
  {
    __includeLargestResourceSize = [decoder decodeBoolForKey: @"includeLargestResourceSize"];
    __includeLargestResourceSize_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__includeTitle_isset)
  {
    [encoder encodeBool: __includeTitle forKey: @"includeTitle"];
  }
  if (__includeContentLength_isset)
  {
    [encoder encodeBool: __includeContentLength forKey: @"includeContentLength"];
  }
  if (__includeCreated_isset)
  {
    [encoder encodeBool: __includeCreated forKey: @"includeCreated"];
  }
  if (__includeUpdated_isset)
  {
    [encoder encodeBool: __includeUpdated forKey: @"includeUpdated"];
  }
  if (__includeUpdateSequenceNum_isset)
  {
    [encoder encodeBool: __includeUpdateSequenceNum forKey: @"includeUpdateSequenceNum"];
  }
  if (__includeNotebookGuid_isset)
  {
    [encoder encodeBool: __includeNotebookGuid forKey: @"includeNotebookGuid"];
  }
  if (__includeTagGuids_isset)
  {
    [encoder encodeBool: __includeTagGuids forKey: @"includeTagGuids"];
  }
  if (__includeAttributes_isset)
  {
    [encoder encodeBool: __includeAttributes forKey: @"includeAttributes"];
  }
  if (__includeLargestResourceMime_isset)
  {
    [encoder encodeBool: __includeLargestResourceMime forKey: @"includeLargestResourceMime"];
  }
  if (__includeLargestResourceSize_isset)
  {
    [encoder encodeBool: __includeLargestResourceSize forKey: @"includeLargestResourceSize"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (BOOL) includeTitle {
  return __includeTitle;
}

- (void) setIncludeTitle: (BOOL) includeTitle {
  __includeTitle = includeTitle;
  __includeTitle_isset = YES;
}

- (BOOL) includeTitleIsSet {
  return __includeTitle_isset;
}

- (void) unsetIncludeTitle {
  __includeTitle_isset = NO;
}

- (BOOL) includeContentLength {
  return __includeContentLength;
}

- (void) setIncludeContentLength: (BOOL) includeContentLength {
  __includeContentLength = includeContentLength;
  __includeContentLength_isset = YES;
}

- (BOOL) includeContentLengthIsSet {
  return __includeContentLength_isset;
}

- (void) unsetIncludeContentLength {
  __includeContentLength_isset = NO;
}

- (BOOL) includeCreated {
  return __includeCreated;
}

- (void) setIncludeCreated: (BOOL) includeCreated {
  __includeCreated = includeCreated;
  __includeCreated_isset = YES;
}

- (BOOL) includeCreatedIsSet {
  return __includeCreated_isset;
}

- (void) unsetIncludeCreated {
  __includeCreated_isset = NO;
}

- (BOOL) includeUpdated {
  return __includeUpdated;
}

- (void) setIncludeUpdated: (BOOL) includeUpdated {
  __includeUpdated = includeUpdated;
  __includeUpdated_isset = YES;
}

- (BOOL) includeUpdatedIsSet {
  return __includeUpdated_isset;
}

- (void) unsetIncludeUpdated {
  __includeUpdated_isset = NO;
}

- (BOOL) includeUpdateSequenceNum {
  return __includeUpdateSequenceNum;
}

- (void) setIncludeUpdateSequenceNum: (BOOL) includeUpdateSequenceNum {
  __includeUpdateSequenceNum = includeUpdateSequenceNum;
  __includeUpdateSequenceNum_isset = YES;
}

- (BOOL) includeUpdateSequenceNumIsSet {
  return __includeUpdateSequenceNum_isset;
}

- (void) unsetIncludeUpdateSequenceNum {
  __includeUpdateSequenceNum_isset = NO;
}

- (BOOL) includeNotebookGuid {
  return __includeNotebookGuid;
}

- (void) setIncludeNotebookGuid: (BOOL) includeNotebookGuid {
  __includeNotebookGuid = includeNotebookGuid;
  __includeNotebookGuid_isset = YES;
}

- (BOOL) includeNotebookGuidIsSet {
  return __includeNotebookGuid_isset;
}

- (void) unsetIncludeNotebookGuid {
  __includeNotebookGuid_isset = NO;
}

- (BOOL) includeTagGuids {
  return __includeTagGuids;
}

- (void) setIncludeTagGuids: (BOOL) includeTagGuids {
  __includeTagGuids = includeTagGuids;
  __includeTagGuids_isset = YES;
}

- (BOOL) includeTagGuidsIsSet {
  return __includeTagGuids_isset;
}

- (void) unsetIncludeTagGuids {
  __includeTagGuids_isset = NO;
}

- (BOOL) includeAttributes {
  return __includeAttributes;
}

- (void) setIncludeAttributes: (BOOL) includeAttributes {
  __includeAttributes = includeAttributes;
  __includeAttributes_isset = YES;
}

- (BOOL) includeAttributesIsSet {
  return __includeAttributes_isset;
}

- (void) unsetIncludeAttributes {
  __includeAttributes_isset = NO;
}

- (BOOL) includeLargestResourceMime {
  return __includeLargestResourceMime;
}

- (void) setIncludeLargestResourceMime: (BOOL) includeLargestResourceMime {
  __includeLargestResourceMime = includeLargestResourceMime;
  __includeLargestResourceMime_isset = YES;
}

- (BOOL) includeLargestResourceMimeIsSet {
  return __includeLargestResourceMime_isset;
}

- (void) unsetIncludeLargestResourceMime {
  __includeLargestResourceMime_isset = NO;
}

- (BOOL) includeLargestResourceSize {
  return __includeLargestResourceSize;
}

- (void) setIncludeLargestResourceSize: (BOOL) includeLargestResourceSize {
  __includeLargestResourceSize = includeLargestResourceSize;
  __includeLargestResourceSize_isset = YES;
}

- (BOOL) includeLargestResourceSizeIsSet {
  return __includeLargestResourceSize_isset;
}

- (void) unsetIncludeLargestResourceSize {
  __includeLargestResourceSize_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 2:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeContentLength: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeCreated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 7:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeUpdated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 10:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 11:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 12:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeTagGuids: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 14:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeAttributes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 20:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeLargestResourceMime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 21:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setIncludeLargestResourceSize: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NotesMetadataResultSpec"];
  if (__includeTitle_isset) {
    [outProtocol writeFieldBeginWithName: @"includeTitle" type: TType_BOOL fieldID: 2];
    [outProtocol writeBool: __includeTitle];
    [outProtocol writeFieldEnd];
  }
  if (__includeContentLength_isset) {
    [outProtocol writeFieldBeginWithName: @"includeContentLength" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __includeContentLength];
    [outProtocol writeFieldEnd];
  }
  if (__includeCreated_isset) {
    [outProtocol writeFieldBeginWithName: @"includeCreated" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __includeCreated];
    [outProtocol writeFieldEnd];
  }
  if (__includeUpdated_isset) {
    [outProtocol writeFieldBeginWithName: @"includeUpdated" type: TType_BOOL fieldID: 7];
    [outProtocol writeBool: __includeUpdated];
    [outProtocol writeFieldEnd];
  }
  if (__includeUpdateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"includeUpdateSequenceNum" type: TType_BOOL fieldID: 10];
    [outProtocol writeBool: __includeUpdateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__includeNotebookGuid_isset) {
    [outProtocol writeFieldBeginWithName: @"includeNotebookGuid" type: TType_BOOL fieldID: 11];
    [outProtocol writeBool: __includeNotebookGuid];
    [outProtocol writeFieldEnd];
  }
  if (__includeTagGuids_isset) {
    [outProtocol writeFieldBeginWithName: @"includeTagGuids" type: TType_BOOL fieldID: 12];
    [outProtocol writeBool: __includeTagGuids];
    [outProtocol writeFieldEnd];
  }
  if (__includeAttributes_isset) {
    [outProtocol writeFieldBeginWithName: @"includeAttributes" type: TType_BOOL fieldID: 14];
    [outProtocol writeBool: __includeAttributes];
    [outProtocol writeFieldEnd];
  }
  if (__includeLargestResourceMime_isset) {
    [outProtocol writeFieldBeginWithName: @"includeLargestResourceMime" type: TType_BOOL fieldID: 20];
    [outProtocol writeBool: __includeLargestResourceMime];
    [outProtocol writeFieldEnd];
  }
  if (__includeLargestResourceSize_isset) {
    [outProtocol writeFieldBeginWithName: @"includeLargestResourceSize" type: TType_BOOL fieldID: 21];
    [outProtocol writeBool: __includeLargestResourceSize];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NotesMetadataResultSpec("];
  [ms appendString: @"includeTitle:"];
  [ms appendFormat: @"%i", __includeTitle];
  [ms appendString: @",includeContentLength:"];
  [ms appendFormat: @"%i", __includeContentLength];
  [ms appendString: @",includeCreated:"];
  [ms appendFormat: @"%i", __includeCreated];
  [ms appendString: @",includeUpdated:"];
  [ms appendFormat: @"%i", __includeUpdated];
  [ms appendString: @",includeUpdateSequenceNum:"];
  [ms appendFormat: @"%i", __includeUpdateSequenceNum];
  [ms appendString: @",includeNotebookGuid:"];
  [ms appendFormat: @"%i", __includeNotebookGuid];
  [ms appendString: @",includeTagGuids:"];
  [ms appendFormat: @"%i", __includeTagGuids];
  [ms appendString: @",includeAttributes:"];
  [ms appendFormat: @"%i", __includeAttributes];
  [ms appendString: @",includeLargestResourceMime:"];
  [ms appendFormat: @"%i", __includeLargestResourceMime];
  [ms appendString: @",includeLargestResourceSize:"];
  [ms appendFormat: @"%i", __includeLargestResourceSize];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteCollectionCounts

- (id) initWithNotebookCounts: (NSDictionary *) notebookCounts tagCounts: (NSDictionary *) tagCounts trashCount: (int32_t) trashCount
{
  self = [super init];
  __notebookCounts = [notebookCounts retain];
  __notebookCounts_isset = YES;
  __tagCounts = [tagCounts retain];
  __tagCounts_isset = YES;
  __trashCount = trashCount;
  __trashCount_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"notebookCounts"])
  {
    __notebookCounts = [[decoder decodeObjectForKey: @"notebookCounts"] retain];
    __notebookCounts_isset = YES;
  }
  if ([decoder containsValueForKey: @"tagCounts"])
  {
    __tagCounts = [[decoder decodeObjectForKey: @"tagCounts"] retain];
    __tagCounts_isset = YES;
  }
  if ([decoder containsValueForKey: @"trashCount"])
  {
    __trashCount = [decoder decodeInt32ForKey: @"trashCount"];
    __trashCount_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__notebookCounts_isset)
  {
    [encoder encodeObject: __notebookCounts forKey: @"notebookCounts"];
  }
  if (__tagCounts_isset)
  {
    [encoder encodeObject: __tagCounts forKey: @"tagCounts"];
  }
  if (__trashCount_isset)
  {
    [encoder encodeInt32: __trashCount forKey: @"trashCount"];
  }
}

- (void) dealloc
{
  [__notebookCounts release];
  [__tagCounts release];
  [super dealloc];
}

- (NSDictionary *) notebookCounts {
  return [[__notebookCounts retain] autorelease];
}

- (void) setNotebookCounts: (NSDictionary *) notebookCounts {
  [notebookCounts retain];
  [__notebookCounts release];
  __notebookCounts = notebookCounts;
  __notebookCounts_isset = YES;
}

- (BOOL) notebookCountsIsSet {
  return __notebookCounts_isset;
}

- (void) unsetNotebookCounts {
  [__notebookCounts release];
  __notebookCounts = nil;
  __notebookCounts_isset = NO;
}

- (NSDictionary *) tagCounts {
  return [[__tagCounts retain] autorelease];
}

- (void) setTagCounts: (NSDictionary *) tagCounts {
  [tagCounts retain];
  [__tagCounts release];
  __tagCounts = tagCounts;
  __tagCounts_isset = YES;
}

- (BOOL) tagCountsIsSet {
  return __tagCounts_isset;
}

- (void) unsetTagCounts {
  [__tagCounts release];
  __tagCounts = nil;
  __tagCounts_isset = NO;
}

- (int32_t) trashCount {
  return __trashCount;
}

- (void) setTrashCount: (int32_t) trashCount {
  __trashCount = trashCount;
  __trashCount_isset = YES;
}

- (BOOL) trashCountIsSet {
  return __trashCount_isset;
}

- (void) unsetTrashCount {
  __trashCount_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_MAP) {
          int _size95;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size95];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size95];
          int _i96;
          for (_i96 = 0; _i96 < _size95; ++_i96)
          {
            NSString * _key97 = [inProtocol readString];
            int32_t _val98 = [inProtocol readI32];
            [fieldValue setObject: [NSNumber numberWithLong: _val98] forKey: _key97];
          }
          [inProtocol readMapEnd];
          [self setNotebookCounts: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_MAP) {
          int _size99;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size99];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size99];
          int _i100;
          for (_i100 = 0; _i100 < _size99; ++_i100)
          {
            NSString * _key101 = [inProtocol readString];
            int32_t _val102 = [inProtocol readI32];
            [fieldValue setObject: [NSNumber numberWithLong: _val102] forKey: _key101];
          }
          [inProtocol readMapEnd];
          [self setTagCounts: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setTrashCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteCollectionCounts"];
  if (__notebookCounts_isset) {
    if (__notebookCounts != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookCounts" type: TType_MAP fieldID: 1];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_I32 size: [__notebookCounts count]];
        NSEnumerator * _iter103 = [__notebookCounts keyEnumerator];
        id key104;
        while ((key104 = [_iter103 nextObject]))
        {
          [outProtocol writeString: key104];
          [outProtocol writeI32: [[__notebookCounts objectForKey: key104] longValue]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__tagCounts_isset) {
    if (__tagCounts != nil) {
      [outProtocol writeFieldBeginWithName: @"tagCounts" type: TType_MAP fieldID: 2];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_I32 size: [__tagCounts count]];
        NSEnumerator * _iter105 = [__tagCounts keyEnumerator];
        id key106;
        while ((key106 = [_iter105 nextObject]))
        {
          [outProtocol writeString: key106];
          [outProtocol writeI32: [[__tagCounts objectForKey: key106] longValue]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__trashCount_isset) {
    [outProtocol writeFieldBeginWithName: @"trashCount" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __trashCount];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteCollectionCounts("];
  [ms appendString: @"notebookCounts:"];
  [ms appendFormat: @"%@", __notebookCounts];
  [ms appendString: @",tagCounts:"];
  [ms appendFormat: @"%@", __tagCounts];
  [ms appendString: @",trashCount:"];
  [ms appendFormat: @"%i", __trashCount];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMAdImpressions

- (id) initWithAdId: (int32_t) adId impressionCount: (int32_t) impressionCount impressionTime: (int32_t) impressionTime
{
  self = [super init];
  __adId = adId;
  __adId_isset = YES;
  __impressionCount = impressionCount;
  __impressionCount_isset = YES;
  __impressionTime = impressionTime;
  __impressionTime_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"adId"])
  {
    __adId = [decoder decodeInt32ForKey: @"adId"];
    __adId_isset = YES;
  }
  if ([decoder containsValueForKey: @"impressionCount"])
  {
    __impressionCount = [decoder decodeInt32ForKey: @"impressionCount"];
    __impressionCount_isset = YES;
  }
  if ([decoder containsValueForKey: @"impressionTime"])
  {
    __impressionTime = [decoder decodeInt32ForKey: @"impressionTime"];
    __impressionTime_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__adId_isset)
  {
    [encoder encodeInt32: __adId forKey: @"adId"];
  }
  if (__impressionCount_isset)
  {
    [encoder encodeInt32: __impressionCount forKey: @"impressionCount"];
  }
  if (__impressionTime_isset)
  {
    [encoder encodeInt32: __impressionTime forKey: @"impressionTime"];
  }
}

- (void) dealloc
{
  [super dealloc];
}

- (int32_t) adId {
  return __adId;
}

- (void) setAdId: (int32_t) adId {
  __adId = adId;
  __adId_isset = YES;
}

- (BOOL) adIdIsSet {
  return __adId_isset;
}

- (void) unsetAdId {
  __adId_isset = NO;
}

- (int32_t) impressionCount {
  return __impressionCount;
}

- (void) setImpressionCount: (int32_t) impressionCount {
  __impressionCount = impressionCount;
  __impressionCount_isset = YES;
}

- (BOOL) impressionCountIsSet {
  return __impressionCount_isset;
}

- (void) unsetImpressionCount {
  __impressionCount_isset = NO;
}

- (int32_t) impressionTime {
  return __impressionTime;
}

- (void) setImpressionTime: (int32_t) impressionTime {
  __impressionTime = impressionTime;
  __impressionTime_isset = YES;
}

- (BOOL) impressionTimeIsSet {
  return __impressionTime_isset;
}

- (void) unsetImpressionTime {
  __impressionTime_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAdId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setImpressionCount: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setImpressionTime: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AdImpressions"];
  if (__adId_isset) {
    [outProtocol writeFieldBeginWithName: @"adId" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __adId];
    [outProtocol writeFieldEnd];
  }
  if (__impressionCount_isset) {
    [outProtocol writeFieldBeginWithName: @"impressionCount" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __impressionCount];
    [outProtocol writeFieldEnd];
  }
  if (__impressionTime_isset) {
    [outProtocol writeFieldBeginWithName: @"impressionTime" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __impressionTime];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AdImpressions("];
  [ms appendString: @"adId:"];
  [ms appendFormat: @"%i", __adId];
  [ms appendString: @",impressionCount:"];
  [ms appendFormat: @"%i", __impressionCount];
  [ms appendString: @",impressionTime:"];
  [ms appendFormat: @"%i", __impressionTime];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMAdParameters

- (id) initWithClientLanguage: (NSString *) clientLanguage impressions: (NSArray *) impressions supportHtml: (BOOL) supportHtml clientProperties: (NSDictionary *) clientProperties
{
  self = [super init];
  __clientLanguage = [clientLanguage retain];
  __clientLanguage_isset = YES;
  __impressions = [impressions retain];
  __impressions_isset = YES;
  __supportHtml = supportHtml;
  __supportHtml_isset = YES;
  __clientProperties = [clientProperties retain];
  __clientProperties_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"clientLanguage"])
  {
    __clientLanguage = [[decoder decodeObjectForKey: @"clientLanguage"] retain];
    __clientLanguage_isset = YES;
  }
  if ([decoder containsValueForKey: @"impressions"])
  {
    __impressions = [[decoder decodeObjectForKey: @"impressions"] retain];
    __impressions_isset = YES;
  }
  if ([decoder containsValueForKey: @"supportHtml"])
  {
    __supportHtml = [decoder decodeBoolForKey: @"supportHtml"];
    __supportHtml_isset = YES;
  }
  if ([decoder containsValueForKey: @"clientProperties"])
  {
    __clientProperties = [[decoder decodeObjectForKey: @"clientProperties"] retain];
    __clientProperties_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__clientLanguage_isset)
  {
    [encoder encodeObject: __clientLanguage forKey: @"clientLanguage"];
  }
  if (__impressions_isset)
  {
    [encoder encodeObject: __impressions forKey: @"impressions"];
  }
  if (__supportHtml_isset)
  {
    [encoder encodeBool: __supportHtml forKey: @"supportHtml"];
  }
  if (__clientProperties_isset)
  {
    [encoder encodeObject: __clientProperties forKey: @"clientProperties"];
  }
}

- (void) dealloc
{
  [__clientLanguage release];
  [__impressions release];
  [__clientProperties release];
  [super dealloc];
}

- (NSString *) clientLanguage {
  return [[__clientLanguage retain] autorelease];
}

- (void) setClientLanguage: (NSString *) clientLanguage {
  [clientLanguage retain];
  [__clientLanguage release];
  __clientLanguage = clientLanguage;
  __clientLanguage_isset = YES;
}

- (BOOL) clientLanguageIsSet {
  return __clientLanguage_isset;
}

- (void) unsetClientLanguage {
  [__clientLanguage release];
  __clientLanguage = nil;
  __clientLanguage_isset = NO;
}

- (NSArray *) impressions {
  return [[__impressions retain] autorelease];
}

- (void) setImpressions: (NSArray *) impressions {
  [impressions retain];
  [__impressions release];
  __impressions = impressions;
  __impressions_isset = YES;
}

- (BOOL) impressionsIsSet {
  return __impressions_isset;
}

- (void) unsetImpressions {
  [__impressions release];
  __impressions = nil;
  __impressions_isset = NO;
}

- (BOOL) supportHtml {
  return __supportHtml;
}

- (void) setSupportHtml: (BOOL) supportHtml {
  __supportHtml = supportHtml;
  __supportHtml_isset = YES;
}

- (BOOL) supportHtmlIsSet {
  return __supportHtml_isset;
}

- (void) unsetSupportHtml {
  __supportHtml_isset = NO;
}

- (NSDictionary *) clientProperties {
  return [[__clientProperties retain] autorelease];
}

- (void) setClientProperties: (NSDictionary *) clientProperties {
  [clientProperties retain];
  [__clientProperties release];
  __clientProperties = clientProperties;
  __clientProperties_isset = YES;
}

- (BOOL) clientPropertiesIsSet {
  return __clientProperties_isset;
}

- (void) unsetClientProperties {
  [__clientProperties release];
  __clientProperties = nil;
  __clientProperties_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setClientLanguage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size107;
          [inProtocol readListBeginReturningElementType: NULL size: &_size107];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size107];
          int _i108;
          for (_i108 = 0; _i108 < _size107; ++_i108)
          {
            EDAMAdImpressions *_elem109 = [[EDAMAdImpressions alloc] init];
            [_elem109 read: inProtocol];
            [fieldValue addObject: _elem109];
            [_elem109 release];
          }
          [inProtocol readListEnd];
          [self setImpressions: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setSupportHtml: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_MAP) {
          int _size110;
          [inProtocol readMapBeginReturningKeyType: NULL valueType: NULL size: &_size110];
          NSMutableDictionary * fieldValue = [[NSMutableDictionary alloc] initWithCapacity: _size110];
          int _i111;
          for (_i111 = 0; _i111 < _size110; ++_i111)
          {
            NSString * _key112 = [inProtocol readString];
            NSString * _val113 = [inProtocol readString];
            [fieldValue setObject: _val113 forKey: _key112];
          }
          [inProtocol readMapEnd];
          [self setClientProperties: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AdParameters"];
  if (__clientLanguage_isset) {
    if (__clientLanguage != nil) {
      [outProtocol writeFieldBeginWithName: @"clientLanguage" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __clientLanguage];
      [outProtocol writeFieldEnd];
    }
  }
  if (__impressions_isset) {
    if (__impressions != nil) {
      [outProtocol writeFieldBeginWithName: @"impressions" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__impressions count]];
        int i115;
        for (i115 = 0; i115 < [__impressions count]; i115++)
        {
          [[__impressions objectAtIndex: i115] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__supportHtml_isset) {
    [outProtocol writeFieldBeginWithName: @"supportHtml" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __supportHtml];
    [outProtocol writeFieldEnd];
  }
  if (__clientProperties_isset) {
    if (__clientProperties != nil) {
      [outProtocol writeFieldBeginWithName: @"clientProperties" type: TType_MAP fieldID: 6];
      {
        [outProtocol writeMapBeginWithKeyType: TType_STRING valueType: TType_STRING size: [__clientProperties count]];
        NSEnumerator * _iter116 = [__clientProperties keyEnumerator];
        id key117;
        while ((key117 = [_iter116 nextObject]))
        {
          [outProtocol writeString: key117];
          [outProtocol writeString: [__clientProperties objectForKey: key117]];
        }
        [outProtocol writeMapEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AdParameters("];
  [ms appendString: @"clientLanguage:"];
  [ms appendFormat: @"\"%@\"", __clientLanguage];
  [ms appendString: @",impressions:"];
  [ms appendFormat: @"%@", __impressions];
  [ms appendString: @",supportHtml:"];
  [ms appendFormat: @"%i", __supportHtml];
  [ms appendString: @",clientProperties:"];
  [ms appendFormat: @"%@", __clientProperties];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteEmailParameters

- (id) initWithGuid: (NSString *) guid note: (EDAMNote *) note toAddresses: (NSArray *) toAddresses ccAddresses: (NSArray *) ccAddresses subject: (NSString *) subject message: (NSString *) message
{
  self = [super init];
  __guid = [guid retain];
  __guid_isset = YES;
  __note = [note retain];
  __note_isset = YES;
  __toAddresses = [toAddresses retain];
  __toAddresses_isset = YES;
  __ccAddresses = [ccAddresses retain];
  __ccAddresses_isset = YES;
  __subject = [subject retain];
  __subject_isset = YES;
  __message = [message retain];
  __message_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain];
    __note_isset = YES;
  }
  if ([decoder containsValueForKey: @"toAddresses"])
  {
    __toAddresses = [[decoder decodeObjectForKey: @"toAddresses"] retain];
    __toAddresses_isset = YES;
  }
  if ([decoder containsValueForKey: @"ccAddresses"])
  {
    __ccAddresses = [[decoder decodeObjectForKey: @"ccAddresses"] retain];
    __ccAddresses_isset = YES;
  }
  if ([decoder containsValueForKey: @"subject"])
  {
    __subject = [[decoder decodeObjectForKey: @"subject"] retain];
    __subject_isset = YES;
  }
  if ([decoder containsValueForKey: @"message"])
  {
    __message = [[decoder decodeObjectForKey: @"message"] retain];
    __message_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
  if (__toAddresses_isset)
  {
    [encoder encodeObject: __toAddresses forKey: @"toAddresses"];
  }
  if (__ccAddresses_isset)
  {
    [encoder encodeObject: __ccAddresses forKey: @"ccAddresses"];
  }
  if (__subject_isset)
  {
    [encoder encodeObject: __subject forKey: @"subject"];
  }
  if (__message_isset)
  {
    [encoder encodeObject: __message forKey: @"message"];
  }
}

- (void) dealloc
{
  [__guid release];
  [__note release];
  [__toAddresses release];
  [__ccAddresses release];
  [__subject release];
  [__message release];
  [super dealloc];
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain] autorelease];
}

- (void) setNote: (EDAMNote *) note {
  [note retain];
  [__note release];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release];
  __note = nil;
  __note_isset = NO;
}

- (NSArray *) toAddresses {
  return [[__toAddresses retain] autorelease];
}

- (void) setToAddresses: (NSArray *) toAddresses {
  [toAddresses retain];
  [__toAddresses release];
  __toAddresses = toAddresses;
  __toAddresses_isset = YES;
}

- (BOOL) toAddressesIsSet {
  return __toAddresses_isset;
}

- (void) unsetToAddresses {
  [__toAddresses release];
  __toAddresses = nil;
  __toAddresses_isset = NO;
}

- (NSArray *) ccAddresses {
  return [[__ccAddresses retain] autorelease];
}

- (void) setCcAddresses: (NSArray *) ccAddresses {
  [ccAddresses retain];
  [__ccAddresses release];
  __ccAddresses = ccAddresses;
  __ccAddresses_isset = YES;
}

- (BOOL) ccAddressesIsSet {
  return __ccAddresses_isset;
}

- (void) unsetCcAddresses {
  [__ccAddresses release];
  __ccAddresses = nil;
  __ccAddresses_isset = NO;
}

- (NSString *) subject {
  return [[__subject retain] autorelease];
}

- (void) setSubject: (NSString *) subject {
  [subject retain];
  [__subject release];
  __subject = subject;
  __subject_isset = YES;
}

- (BOOL) subjectIsSet {
  return __subject_isset;
}

- (void) unsetSubject {
  [__subject release];
  __subject = nil;
  __subject_isset = NO;
}

- (NSString *) message {
  return [[__message retain] autorelease];
}

- (void) setMessage: (NSString *) message {
  [message retain];
  [__message release];
  __message = message;
  __message_isset = YES;
}

- (BOOL) messageIsSet {
  return __message_isset;
}

- (void) unsetMessage {
  [__message release];
  __message = nil;
  __message_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_LIST) {
          int _size118;
          [inProtocol readListBeginReturningElementType: NULL size: &_size118];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size118];
          int _i119;
          for (_i119 = 0; _i119 < _size118; ++_i119)
          {
            NSString * _elem120 = [inProtocol readString];
            [fieldValue addObject: _elem120];
          }
          [inProtocol readListEnd];
          [self setToAddresses: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size121;
          [inProtocol readListBeginReturningElementType: NULL size: &_size121];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size121];
          int _i122;
          for (_i122 = 0; _i122 < _size121; ++_i122)
          {
            NSString * _elem123 = [inProtocol readString];
            [fieldValue addObject: _elem123];
          }
          [inProtocol readListEnd];
          [self setCcAddresses: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSubject: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessage: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteEmailParameters"];
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__toAddresses_isset) {
    if (__toAddresses != nil) {
      [outProtocol writeFieldBeginWithName: @"toAddresses" type: TType_LIST fieldID: 3];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__toAddresses count]];
        int i125;
        for (i125 = 0; i125 < [__toAddresses count]; i125++)
        {
          [outProtocol writeString: [__toAddresses objectAtIndex: i125]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__ccAddresses_isset) {
    if (__ccAddresses != nil) {
      [outProtocol writeFieldBeginWithName: @"ccAddresses" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__ccAddresses count]];
        int i127;
        for (i127 = 0; i127 < [__ccAddresses count]; i127++)
        {
          [outProtocol writeString: [__ccAddresses objectAtIndex: i127]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  if (__subject_isset) {
    if (__subject != nil) {
      [outProtocol writeFieldBeginWithName: @"subject" type: TType_STRING fieldID: 5];
      [outProtocol writeString: __subject];
      [outProtocol writeFieldEnd];
    }
  }
  if (__message_isset) {
    if (__message != nil) {
      [outProtocol writeFieldBeginWithName: @"message" type: TType_STRING fieldID: 6];
      [outProtocol writeString: __message];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteEmailParameters("];
  [ms appendString: @"guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @",toAddresses:"];
  [ms appendFormat: @"%@", __toAddresses];
  [ms appendString: @",ccAddresses:"];
  [ms appendFormat: @"%@", __ccAddresses];
  [ms appendString: @",subject:"];
  [ms appendFormat: @"\"%@\"", __subject];
  [ms appendString: @",message:"];
  [ms appendFormat: @"\"%@\"", __message];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteVersionId

- (id) initWithUpdateSequenceNum: (int32_t) updateSequenceNum updated: (EDAMTimestamp) updated saved: (EDAMTimestamp) saved title: (NSString *) title
{
  self = [super init];
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
  __updated = updated;
  __updated_isset = YES;
  __saved = saved;
  __saved_isset = YES;
  __title = [title retain];
  __title_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"updateSequenceNum"])
  {
    __updateSequenceNum = [decoder decodeInt32ForKey: @"updateSequenceNum"];
    __updateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"updated"])
  {
    __updated = [decoder decodeInt64ForKey: @"updated"];
    __updated_isset = YES;
  }
  if ([decoder containsValueForKey: @"saved"])
  {
    __saved = [decoder decodeInt64ForKey: @"saved"];
    __saved_isset = YES;
  }
  if ([decoder containsValueForKey: @"title"])
  {
    __title = [[decoder decodeObjectForKey: @"title"] retain];
    __title_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__updateSequenceNum_isset)
  {
    [encoder encodeInt32: __updateSequenceNum forKey: @"updateSequenceNum"];
  }
  if (__updated_isset)
  {
    [encoder encodeInt64: __updated forKey: @"updated"];
  }
  if (__saved_isset)
  {
    [encoder encodeInt64: __saved forKey: @"saved"];
  }
  if (__title_isset)
  {
    [encoder encodeObject: __title forKey: @"title"];
  }
}

- (void) dealloc
{
  [__title release];
  [super dealloc];
}

- (int32_t) updateSequenceNum {
  return __updateSequenceNum;
}

- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum {
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
}

- (BOOL) updateSequenceNumIsSet {
  return __updateSequenceNum_isset;
}

- (void) unsetUpdateSequenceNum {
  __updateSequenceNum_isset = NO;
}

- (int64_t) updated {
  return __updated;
}

- (void) setUpdated: (int64_t) updated {
  __updated = updated;
  __updated_isset = YES;
}

- (BOOL) updatedIsSet {
  return __updated_isset;
}

- (void) unsetUpdated {
  __updated_isset = NO;
}

- (int64_t) saved {
  return __saved;
}

- (void) setSaved: (int64_t) saved {
  __saved = saved;
  __saved_isset = YES;
}

- (BOOL) savedIsSet {
  return __saved_isset;
}

- (void) unsetSaved {
  __saved_isset = NO;
}

- (NSString *) title {
  return [[__title retain] autorelease];
}

- (void) setTitle: (NSString *) title {
  [title retain];
  [__title release];
  __title = title;
  __title_isset = YES;
}

- (BOOL) titleIsSet {
  return __title_isset;
}

- (void) unsetTitle {
  [__title release];
  __title = nil;
  __title_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setUpdated: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setSaved: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setTitle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"NoteVersionId"];
  if (__updateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __updateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__updated_isset) {
    [outProtocol writeFieldBeginWithName: @"updated" type: TType_I64 fieldID: 2];
    [outProtocol writeI64: __updated];
    [outProtocol writeFieldEnd];
  }
  if (__saved_isset) {
    [outProtocol writeFieldBeginWithName: @"saved" type: TType_I64 fieldID: 3];
    [outProtocol writeI64: __saved];
    [outProtocol writeFieldEnd];
  }
  if (__title_isset) {
    if (__title != nil) {
      [outProtocol writeFieldBeginWithName: @"title" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __title];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"NoteVersionId("];
  [ms appendString: @"updateSequenceNum:"];
  [ms appendFormat: @"%i", __updateSequenceNum];
  [ms appendString: @",updated:"];
  [ms appendFormat: @"%qi", __updated];
  [ms appendString: @",saved:"];
  [ms appendFormat: @"%qi", __saved];
  [ms appendString: @",title:"];
  [ms appendFormat: @"\"%@\"", __title];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSyncState_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMgetSyncState_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSyncState_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSyncState_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSyncState_result : NSObject <NSCoding> {
  EDAMSyncState * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSyncState * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMSyncState *) success;
- (void) setSuccess: (EDAMSyncState *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMGetSyncState_result

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSyncState *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSyncState *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncState *fieldValue = [[EDAMSyncState alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSyncState_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSyncState_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSyncChunk_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  int32_t __afterUSN;
  int32_t __maxEntries;
  BOOL __fullSyncOnly;

  BOOL __authenticationToken_isset;
  BOOL __afterUSN_isset;
  BOOL __maxEntries_isset;
  BOOL __fullSyncOnly_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, getter=afterUSN, setter=setAfterUSN:) int32_t afterUSN;
@property (nonatomic, getter=maxEntries, setter=setMaxEntries:) int32_t maxEntries;
@property (nonatomic, getter=fullSyncOnly, setter=setFullSyncOnly:) BOOL fullSyncOnly;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (int32_t) afterUSN;
- (void) setAfterUSN: (int32_t) afterUSN;

- (int32_t) maxEntries;
- (void) setMaxEntries: (int32_t) maxEntries;

- (BOOL) fullSyncOnly;
- (void) setFullSyncOnly: (BOOL) fullSyncOnly;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) afterUSNIsSet;
- (BOOL) maxEntriesIsSet;
- (BOOL) fullSyncOnlyIsSet;
@end

@implementation EDAMgetSyncChunk_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"afterUSN"])
  {
    __afterUSN = [decoder decodeInt32ForKey: @"afterUSN"];
    __afterUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxEntries"])
  {
    __maxEntries = [decoder decodeInt32ForKey: @"maxEntries"];
    __maxEntries_isset = YES;
  }
  if ([decoder containsValueForKey: @"fullSyncOnly"])
  {
    __fullSyncOnly = [decoder decodeBoolForKey: @"fullSyncOnly"];
    __fullSyncOnly_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__afterUSN_isset)
  {
    [encoder encodeInt32: __afterUSN forKey: @"afterUSN"];
  }
  if (__maxEntries_isset)
  {
    [encoder encodeInt32: __maxEntries forKey: @"maxEntries"];
  }
  if (__fullSyncOnly_isset)
  {
    [encoder encodeBool: __fullSyncOnly forKey: @"fullSyncOnly"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (int32_t) afterUSN {
  return __afterUSN;
}

- (void) setAfterUSN: (int32_t) afterUSN {
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
}

- (BOOL) afterUSNIsSet {
  return __afterUSN_isset;
}

- (void) unsetAfterUSN {
  __afterUSN_isset = NO;
}

- (int32_t) maxEntries {
  return __maxEntries;
}

- (void) setMaxEntries: (int32_t) maxEntries {
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
}

- (BOOL) maxEntriesIsSet {
  return __maxEntries_isset;
}

- (void) unsetMaxEntries {
  __maxEntries_isset = NO;
}

- (BOOL) fullSyncOnly {
  return __fullSyncOnly;
}

- (void) setFullSyncOnly: (BOOL) fullSyncOnly {
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
}

- (BOOL) fullSyncOnlyIsSet {
  return __fullSyncOnly_isset;
}

- (void) unsetFullSyncOnly {
  __fullSyncOnly_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAfterUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxEntries: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setFullSyncOnly: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSyncChunk_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__afterUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __afterUSN];
    [outProtocol writeFieldEnd];
  }
  if (__maxEntries_isset) {
    [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __maxEntries];
    [outProtocol writeFieldEnd];
  }
  if (__fullSyncOnly_isset) {
    [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __fullSyncOnly];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSyncChunk_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",afterUSN:"];
  [ms appendFormat: @"%i", __afterUSN];
  [ms appendString: @",maxEntries:"];
  [ms appendFormat: @"%i", __maxEntries];
  [ms appendString: @",fullSyncOnly:"];
  [ms appendFormat: @"%i", __fullSyncOnly];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSyncChunk_result : NSObject <NSCoding> {
  EDAMSyncChunk * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSyncChunk * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMSyncChunk *) success;
- (void) setSuccess: (EDAMSyncChunk *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMGetSyncChunk_result

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSyncChunk *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSyncChunk *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunk *fieldValue = [[EDAMSyncChunk alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSyncChunk_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSyncChunk_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetFilteredSyncChunk_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  int32_t __afterUSN;
  int32_t __maxEntries;
  EDAMSyncChunkFilter * __filter;

  BOOL __authenticationToken_isset;
  BOOL __afterUSN_isset;
  BOOL __maxEntries_isset;
  BOOL __filter_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries filter: (EDAMSyncChunkFilter *) filter;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, getter=afterUSN, setter=setAfterUSN:) int32_t afterUSN;
@property (nonatomic, getter=maxEntries, setter=setMaxEntries:) int32_t maxEntries;
@property (nonatomic, retain, getter=filter, setter=setFilter:) EDAMSyncChunkFilter * filter;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (int32_t) afterUSN;
- (void) setAfterUSN: (int32_t) afterUSN;

- (int32_t) maxEntries;
- (void) setMaxEntries: (int32_t) maxEntries;

- (EDAMSyncChunkFilter *) filter;
- (void) setFilter: (EDAMSyncChunkFilter *) filter;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) afterUSNIsSet;
- (BOOL) maxEntriesIsSet;
- (BOOL) filterIsSet;
@end

@implementation EDAMgetFilteredSyncChunk_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries filter: (EDAMSyncChunkFilter *) filter
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
  __filter = [filter retain];
  __filter_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"afterUSN"])
  {
    __afterUSN = [decoder decodeInt32ForKey: @"afterUSN"];
    __afterUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxEntries"])
  {
    __maxEntries = [decoder decodeInt32ForKey: @"maxEntries"];
    __maxEntries_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain];
    __filter_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__afterUSN_isset)
  {
    [encoder encodeInt32: __afterUSN forKey: @"afterUSN"];
  }
  if (__maxEntries_isset)
  {
    [encoder encodeInt32: __maxEntries forKey: @"maxEntries"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__filter release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (int32_t) afterUSN {
  return __afterUSN;
}

- (void) setAfterUSN: (int32_t) afterUSN {
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
}

- (BOOL) afterUSNIsSet {
  return __afterUSN_isset;
}

- (void) unsetAfterUSN {
  __afterUSN_isset = NO;
}

- (int32_t) maxEntries {
  return __maxEntries;
}

- (void) setMaxEntries: (int32_t) maxEntries {
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
}

- (BOOL) maxEntriesIsSet {
  return __maxEntries_isset;
}

- (void) unsetMaxEntries {
  __maxEntries_isset = NO;
}

- (EDAMSyncChunkFilter *) filter {
  return [[__filter retain] autorelease];
}

- (void) setFilter: (EDAMSyncChunkFilter *) filter {
  [filter retain];
  [__filter release];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release];
  __filter = nil;
  __filter_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAfterUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxEntries: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunkFilter *fieldValue = [[EDAMSyncChunkFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getFilteredSyncChunk_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__afterUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
    [outProtocol writeI32: __afterUSN];
    [outProtocol writeFieldEnd];
  }
  if (__maxEntries_isset) {
    [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __maxEntries];
    [outProtocol writeFieldEnd];
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 4];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getFilteredSyncChunk_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",afterUSN:"];
  [ms appendFormat: @"%i", __afterUSN];
  [ms appendString: @",maxEntries:"];
  [ms appendFormat: @"%i", __maxEntries];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetFilteredSyncChunk_result : NSObject <NSCoding> {
  EDAMSyncChunk * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSyncChunk * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMSyncChunk *) success;
- (void) setSuccess: (EDAMSyncChunk *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMGetFilteredSyncChunk_result

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSyncChunk *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSyncChunk *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunk *fieldValue = [[EDAMSyncChunk alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetFilteredSyncChunk_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetFilteredSyncChunk_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetLinkedNotebookSyncState_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) linkedNotebookIsSet;
@end

@implementation EDAMgetLinkedNotebookSyncState_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain];
  __linkedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain];
    __linkedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__linkedNotebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain] autorelease];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain];
  [__linkedNotebook release];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getLinkedNotebookSyncState_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getLinkedNotebookSyncState_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetLinkedNotebookSyncState_result : NSObject <NSCoding> {
  EDAMSyncState * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSyncState * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMSyncState *) success;
- (void) setSuccess: (EDAMSyncState *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetLinkedNotebookSyncState_result

- (id) initWithSuccess: (EDAMSyncState *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMSyncState *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSyncState *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncState *fieldValue = [[EDAMSyncState alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetLinkedNotebookSyncState_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetLinkedNotebookSyncState_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetLinkedNotebookSyncChunk_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;
  int32_t __afterUSN;
  int32_t __maxEntries;
  BOOL __fullSyncOnly;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
  BOOL __afterUSN_isset;
  BOOL __maxEntries_isset;
  BOOL __fullSyncOnly_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
@property (nonatomic, getter=afterUSN, setter=setAfterUSN:) int32_t afterUSN;
@property (nonatomic, getter=maxEntries, setter=setMaxEntries:) int32_t maxEntries;
@property (nonatomic, getter=fullSyncOnly, setter=setFullSyncOnly:) BOOL fullSyncOnly;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (int32_t) afterUSN;
- (void) setAfterUSN: (int32_t) afterUSN;

- (int32_t) maxEntries;
- (void) setMaxEntries: (int32_t) maxEntries;

- (BOOL) fullSyncOnly;
- (void) setFullSyncOnly: (BOOL) fullSyncOnly;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) linkedNotebookIsSet;
- (BOOL) afterUSNIsSet;
- (BOOL) maxEntriesIsSet;
- (BOOL) fullSyncOnlyIsSet;
@end

@implementation EDAMgetLinkedNotebookSyncChunk_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook afterUSN: (int32_t) afterUSN maxEntries: (int32_t) maxEntries fullSyncOnly: (BOOL) fullSyncOnly
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain];
  __linkedNotebook_isset = YES;
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain];
    __linkedNotebook_isset = YES;
  }
  if ([decoder containsValueForKey: @"afterUSN"])
  {
    __afterUSN = [decoder decodeInt32ForKey: @"afterUSN"];
    __afterUSN_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxEntries"])
  {
    __maxEntries = [decoder decodeInt32ForKey: @"maxEntries"];
    __maxEntries_isset = YES;
  }
  if ([decoder containsValueForKey: @"fullSyncOnly"])
  {
    __fullSyncOnly = [decoder decodeBoolForKey: @"fullSyncOnly"];
    __fullSyncOnly_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
  if (__afterUSN_isset)
  {
    [encoder encodeInt32: __afterUSN forKey: @"afterUSN"];
  }
  if (__maxEntries_isset)
  {
    [encoder encodeInt32: __maxEntries forKey: @"maxEntries"];
  }
  if (__fullSyncOnly_isset)
  {
    [encoder encodeBool: __fullSyncOnly forKey: @"fullSyncOnly"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__linkedNotebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain] autorelease];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain];
  [__linkedNotebook release];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (int32_t) afterUSN {
  return __afterUSN;
}

- (void) setAfterUSN: (int32_t) afterUSN {
  __afterUSN = afterUSN;
  __afterUSN_isset = YES;
}

- (BOOL) afterUSNIsSet {
  return __afterUSN_isset;
}

- (void) unsetAfterUSN {
  __afterUSN_isset = NO;
}

- (int32_t) maxEntries {
  return __maxEntries;
}

- (void) setMaxEntries: (int32_t) maxEntries {
  __maxEntries = maxEntries;
  __maxEntries_isset = YES;
}

- (BOOL) maxEntriesIsSet {
  return __maxEntries_isset;
}

- (void) unsetMaxEntries {
  __maxEntries_isset = NO;
}

- (BOOL) fullSyncOnly {
  return __fullSyncOnly;
}

- (void) setFullSyncOnly: (BOOL) fullSyncOnly {
  __fullSyncOnly = fullSyncOnly;
  __fullSyncOnly_isset = YES;
}

- (BOOL) fullSyncOnlyIsSet {
  return __fullSyncOnly_isset;
}

- (void) unsetFullSyncOnly {
  __fullSyncOnly_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setAfterUSN: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxEntries: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setFullSyncOnly: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getLinkedNotebookSyncChunk_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__afterUSN_isset) {
    [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __afterUSN];
    [outProtocol writeFieldEnd];
  }
  if (__maxEntries_isset) {
    [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __maxEntries];
    [outProtocol writeFieldEnd];
  }
  if (__fullSyncOnly_isset) {
    [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __fullSyncOnly];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getLinkedNotebookSyncChunk_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @",afterUSN:"];
  [ms appendFormat: @"%i", __afterUSN];
  [ms appendString: @",maxEntries:"];
  [ms appendFormat: @"%i", __maxEntries];
  [ms appendString: @",fullSyncOnly:"];
  [ms appendFormat: @"%i", __fullSyncOnly];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetLinkedNotebookSyncChunk_result : NSObject <NSCoding> {
  EDAMSyncChunk * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSyncChunk * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMSyncChunk *) success;
- (void) setSuccess: (EDAMSyncChunk *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetLinkedNotebookSyncChunk_result

- (id) initWithSuccess: (EDAMSyncChunk *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMSyncChunk *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSyncChunk *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSyncChunk *fieldValue = [[EDAMSyncChunk alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetLinkedNotebookSyncChunk_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetLinkedNotebookSyncChunk_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMlistNotebooks_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListNotebooks_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMListNotebooks_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size128;
          [inProtocol readListBeginReturningElementType: NULL size: &_size128];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size128];
          int _i129;
          for (_i129 = 0; _i129 < _size128; ++_i129)
          {
            EDAMNotebook *_elem130 = [[EDAMNotebook alloc] init];
            [_elem130 read: inProtocol];
            [fieldValue addObject: _elem130];
            [_elem130 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i132;
        for (i132 = 0; i132 < [__success count]; i132++)
        {
          [[__success objectAtIndex: i132] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetNotebook_result

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetDefaultNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMgetDefaultNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getDefaultNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getDefaultNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetDefaultNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMGetDefaultNotebook_result

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetDefaultNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetDefaultNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNotebook * __notebook;

  BOOL __authenticationToken_isset;
  BOOL __notebook_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=notebook, setter=setNotebook:) EDAMNotebook * notebook;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNotebook *) notebook;
- (void) setNotebook: (EDAMNotebook *) notebook;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) notebookIsSet;
@end

@implementation EDAMcreateNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __notebook = [notebook retain];
  __notebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebook"])
  {
    __notebook = [[decoder decodeObjectForKey: @"notebook"] retain];
    __notebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebook_isset)
  {
    [encoder encodeObject: __notebook forKey: @"notebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__notebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNotebook *) notebook {
  return [[__notebook retain] autorelease];
}

- (void) setNotebook: (EDAMNotebook *) notebook {
  [notebook retain];
  [__notebook release];
  __notebook = notebook;
  __notebook_isset = YES;
}

- (BOOL) notebookIsSet {
  return __notebook_isset;
}

- (void) unsetNotebook {
  [__notebook release];
  __notebook = nil;
  __notebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebook_isset) {
    if (__notebook != nil) {
      [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
      [__notebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebook:"];
  [ms appendFormat: @"%@", __notebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMCreateNotebook_result

- (id) initWithSuccess: (EDAMNotebook *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNotebook * __notebook;

  BOOL __authenticationToken_isset;
  BOOL __notebook_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=notebook, setter=setNotebook:) EDAMNotebook * notebook;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNotebook *) notebook;
- (void) setNotebook: (EDAMNotebook *) notebook;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) notebookIsSet;
@end

@implementation EDAMupdateNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebook: (EDAMNotebook *) notebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __notebook = [notebook retain];
  __notebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebook"])
  {
    __notebook = [[decoder decodeObjectForKey: @"notebook"] retain];
    __notebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebook_isset)
  {
    [encoder encodeObject: __notebook forKey: @"notebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__notebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNotebook *) notebook {
  return [[__notebook retain] autorelease];
}

- (void) setNotebook: (EDAMNotebook *) notebook {
  [notebook retain];
  [__notebook release];
  __notebook = notebook;
  __notebook_isset = YES;
}

- (BOOL) notebookIsSet {
  return __notebook_isset;
}

- (void) unsetNotebook {
  [__notebook release];
  __notebook = nil;
  __notebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebook_isset) {
    if (__notebook != nil) {
      [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
      [__notebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebook:"];
  [ms appendFormat: @"%@", __notebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMUpdateNotebook_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMexpungeNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMExpungeNotebook_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistTags_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMlistTags_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listTags_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listTags_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListTags_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMListTags_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size133;
          [inProtocol readListBeginReturningElementType: NULL size: &_size133];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size133];
          int _i134;
          for (_i134 = 0; _i134 < _size133; ++_i134)
          {
            EDAMTag *_elem135 = [[EDAMTag alloc] init];
            [_elem135 read: inProtocol];
            [fieldValue addObject: _elem135];
            [_elem135 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListTags_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i137;
        for (i137 = 0; i137 < [__success count]; i137++)
        {
          [[__success objectAtIndex: i137] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListTags_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistTagsByNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __notebookGuid;

  BOOL __authenticationToken_isset;
  BOOL __notebookGuid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=notebookGuid, setter=setNotebookGuid:) EDAMGuid notebookGuid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) notebookGuid;
- (void) setNotebookGuid: (EDAMGuid) notebookGuid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) notebookGuidIsSet;
@end

@implementation EDAMlistTagsByNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __notebookGuid = [notebookGuid retain];
  __notebookGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain];
    __notebookGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__notebookGuid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain] autorelease];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain];
  [__notebookGuid release];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listTagsByNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listTagsByNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListTagsByNotebook_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMListTagsByNotebook_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size138;
          [inProtocol readListBeginReturningElementType: NULL size: &_size138];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size138];
          int _i139;
          for (_i139 = 0; _i139 < _size138; ++_i139)
          {
            EDAMTag *_elem140 = [[EDAMTag alloc] init];
            [_elem140 read: inProtocol];
            [fieldValue addObject: _elem140];
            [_elem140 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListTagsByNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i142;
        for (i142 = 0; i142 < [__success count]; i142++)
        {
          [[__success objectAtIndex: i142] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListTagsByNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetTag_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetTag_result : NSObject <NSCoding> {
  EDAMTag * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMTag * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMTag *) success;
- (void) setSuccess: (EDAMTag *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetTag_result

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMTag *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMTag *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetTag_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMTag * __tag;

  BOOL __authenticationToken_isset;
  BOOL __tag_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=tag, setter=setTag:) EDAMTag * tag;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMTag *) tag;
- (void) setTag: (EDAMTag *) tag;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) tagIsSet;
@end

@implementation EDAMcreateTag_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __tag = [tag retain];
  __tag_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"tag"])
  {
    __tag = [[decoder decodeObjectForKey: @"tag"] retain];
    __tag_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__tag_isset)
  {
    [encoder encodeObject: __tag forKey: @"tag"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__tag release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMTag *) tag {
  return [[__tag retain] autorelease];
}

- (void) setTag: (EDAMTag *) tag {
  [tag retain];
  [__tag release];
  __tag = tag;
  __tag_isset = YES;
}

- (BOOL) tagIsSet {
  return __tag_isset;
}

- (void) unsetTag {
  [__tag release];
  __tag = nil;
  __tag_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setTag: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tag_isset) {
    if (__tag != nil) {
      [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
      [__tag write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",tag:"];
  [ms appendFormat: @"%@", __tag];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateTag_result : NSObject <NSCoding> {
  EDAMTag * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMTag * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMTag *) success;
- (void) setSuccess: (EDAMTag *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMCreateTag_result

- (id) initWithSuccess: (EDAMTag *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMTag *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMTag *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateTag_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMTag * __tag;

  BOOL __authenticationToken_isset;
  BOOL __tag_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=tag, setter=setTag:) EDAMTag * tag;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMTag *) tag;
- (void) setTag: (EDAMTag *) tag;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) tagIsSet;
@end

@implementation EDAMupdateTag_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken tag: (EDAMTag *) tag
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __tag = [tag retain];
  __tag_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"tag"])
  {
    __tag = [[decoder decodeObjectForKey: @"tag"] retain];
    __tag_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__tag_isset)
  {
    [encoder encodeObject: __tag forKey: @"tag"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__tag release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMTag *) tag {
  return [[__tag retain] autorelease];
}

- (void) setTag: (EDAMTag *) tag {
  [tag retain];
  [__tag release];
  __tag = tag;
  __tag_isset = YES;
}

- (BOOL) tagIsSet {
  return __tag_isset;
}

- (void) unsetTag {
  [__tag release];
  __tag = nil;
  __tag_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMTag *fieldValue = [[EDAMTag alloc] init];
          [fieldValue read: inProtocol];
          [self setTag: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__tag_isset) {
    if (__tag != nil) {
      [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
      [__tag write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",tag:"];
  [ms appendFormat: @"%@", __tag];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateTag_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMUpdateTag_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateTag_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMuntagAll_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMuntagAll_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"untagAll_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"untagAll_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUntagAll_result : NSObject <NSCoding> {
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithUserException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMUntagAll_result

- (id) initWithUserException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UntagAll_result"];

  if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UntagAll_result("];
  [ms appendString: @"userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeTag_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMexpungeTag_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeTag_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeTag_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeTag_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMExpungeTag_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeTag_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeTag_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistSearches_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMlistSearches_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listSearches_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listSearches_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListSearches_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMListSearches_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size143;
          [inProtocol readListBeginReturningElementType: NULL size: &_size143];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size143];
          int _i144;
          for (_i144 = 0; _i144 < _size143; ++_i144)
          {
            EDAMSavedSearch *_elem145 = [[EDAMSavedSearch alloc] init];
            [_elem145 read: inProtocol];
            [fieldValue addObject: _elem145];
            [_elem145 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListSearches_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i147;
        for (i147 = 0; i147 < [__success count]; i147++)
        {
          [[__success objectAtIndex: i147] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListSearches_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetSearch_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSearch_result : NSObject <NSCoding> {
  EDAMSavedSearch * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSavedSearch * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMSavedSearch *) success;
- (void) setSuccess: (EDAMSavedSearch *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetSearch_result

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMSavedSearch *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSavedSearch *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSearch_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSavedSearch * __search;

  BOOL __authenticationToken_isset;
  BOOL __search_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=search, setter=setSearch:) EDAMSavedSearch * search;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMSavedSearch *) search;
- (void) setSearch: (EDAMSavedSearch *) search;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) searchIsSet;
@end

@implementation EDAMcreateSearch_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __search = [search retain];
  __search_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"search"])
  {
    __search = [[decoder decodeObjectForKey: @"search"] retain];
    __search_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__search_isset)
  {
    [encoder encodeObject: __search forKey: @"search"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__search release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSavedSearch *) search {
  return [[__search retain] autorelease];
}

- (void) setSearch: (EDAMSavedSearch *) search {
  [search retain];
  [__search release];
  __search = search;
  __search_isset = YES;
}

- (BOOL) searchIsSet {
  return __search_isset;
}

- (void) unsetSearch {
  [__search release];
  __search = nil;
  __search_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSearch: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__search_isset) {
    if (__search != nil) {
      [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
      [__search write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",search:"];
  [ms appendFormat: @"%@", __search];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateSearch_result : NSObject <NSCoding> {
  EDAMSavedSearch * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSavedSearch * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMSavedSearch *) success;
- (void) setSuccess: (EDAMSavedSearch *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMCreateSearch_result

- (id) initWithSuccess: (EDAMSavedSearch *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSavedSearch *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSavedSearch *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateSearch_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSavedSearch * __search;

  BOOL __authenticationToken_isset;
  BOOL __search_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=search, setter=setSearch:) EDAMSavedSearch * search;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMSavedSearch *) search;
- (void) setSearch: (EDAMSavedSearch *) search;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) searchIsSet;
@end

@implementation EDAMupdateSearch_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken search: (EDAMSavedSearch *) search
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __search = [search retain];
  __search_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"search"])
  {
    __search = [[decoder decodeObjectForKey: @"search"] retain];
    __search_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__search_isset)
  {
    [encoder encodeObject: __search forKey: @"search"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__search release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSavedSearch *) search {
  return [[__search retain] autorelease];
}

- (void) setSearch: (EDAMSavedSearch *) search {
  [search retain];
  [__search release];
  __search = search;
  __search_isset = YES;
}

- (BOOL) searchIsSet {
  return __search_isset;
}

- (void) unsetSearch {
  [__search release];
  __search = nil;
  __search_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSavedSearch *fieldValue = [[EDAMSavedSearch alloc] init];
          [fieldValue read: inProtocol];
          [self setSearch: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__search_isset) {
    if (__search != nil) {
      [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
      [__search write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",search:"];
  [ms appendFormat: @"%@", __search];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateSearch_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMUpdateSearch_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateSearch_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeSearch_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMexpungeSearch_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeSearch_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeSearch_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeSearch_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMExpungeSearch_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeSearch_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeSearch_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  int32_t __offset;
  int32_t __maxNotes;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __offset_isset;
  BOOL __maxNotes_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, getter=offset, setter=setOffset:) int32_t offset;
@property (nonatomic, getter=maxNotes, setter=setMaxNotes:) int32_t maxNotes;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;

- (int32_t) offset;
- (void) setOffset: (int32_t) offset;

- (int32_t) maxNotes;
- (void) setMaxNotes: (int32_t) maxNotes;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) filterIsSet;
- (BOOL) offsetIsSet;
- (BOOL) maxNotesIsSet;
@end

@implementation EDAMfindNotes_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __filter = [filter retain];
  __filter_isset = YES;
  __offset = offset;
  __offset_isset = YES;
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"offset"])
  {
    __offset = [decoder decodeInt32ForKey: @"offset"];
    __offset_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxNotes"])
  {
    __maxNotes = [decoder decodeInt32ForKey: @"maxNotes"];
    __maxNotes_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__offset_isset)
  {
    [encoder encodeInt32: __offset forKey: @"offset"];
  }
  if (__maxNotes_isset)
  {
    [encoder encodeInt32: __maxNotes forKey: @"maxNotes"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__filter release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain] autorelease];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain];
  [__filter release];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release];
  __filter = nil;
  __filter_isset = NO;
}

- (int32_t) offset {
  return __offset;
}

- (void) setOffset: (int32_t) offset {
  __offset = offset;
  __offset_isset = YES;
}

- (BOOL) offsetIsSet {
  return __offset_isset;
}

- (void) unsetOffset {
  __offset_isset = NO;
}

- (int32_t) maxNotes {
  return __maxNotes;
}

- (void) setMaxNotes: (int32_t) maxNotes {
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
}

- (BOOL) maxNotesIsSet {
  return __maxNotes_isset;
}

- (void) unsetMaxNotes {
  __maxNotes_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOffset: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__offset_isset) {
    [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __offset];
    [outProtocol writeFieldEnd];
  }
  if (__maxNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __maxNotes];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",offset:"];
  [ms appendFormat: @"%i", __offset];
  [ms appendString: @",maxNotes:"];
  [ms appendFormat: @"%i", __maxNotes];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNotes_result : NSObject <NSCoding> {
  EDAMNoteList * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNoteList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNoteList * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNoteList *) success;
- (void) setSuccess: (EDAMNoteList *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMFindNotes_result

- (id) initWithSuccess: (EDAMNoteList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNoteList *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNoteList *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNoteList *fieldValue = [[EDAMNoteList alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNotes_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNoteOffset_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) filterIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMfindNoteOffset_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __filter = [filter retain];
  __filter_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__filter release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain] autorelease];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain];
  [__filter release];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release];
  __filter = nil;
  __filter_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNoteOffset_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNoteOffset_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNoteOffset_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMFindNoteOffset_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNoteOffset_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNoteOffset_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNotesMetadata_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  int32_t __offset;
  int32_t __maxNotes;
  EDAMNotesMetadataResultSpec * __resultSpec;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __offset_isset;
  BOOL __maxNotes_isset;
  BOOL __resultSpec_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes resultSpec: (EDAMNotesMetadataResultSpec *) resultSpec;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, getter=offset, setter=setOffset:) int32_t offset;
@property (nonatomic, getter=maxNotes, setter=setMaxNotes:) int32_t maxNotes;
@property (nonatomic, retain, getter=resultSpec, setter=setResultSpec:) EDAMNotesMetadataResultSpec * resultSpec;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;

- (int32_t) offset;
- (void) setOffset: (int32_t) offset;

- (int32_t) maxNotes;
- (void) setMaxNotes: (int32_t) maxNotes;

- (EDAMNotesMetadataResultSpec *) resultSpec;
- (void) setResultSpec: (EDAMNotesMetadataResultSpec *) resultSpec;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) filterIsSet;
- (BOOL) offsetIsSet;
- (BOOL) maxNotesIsSet;
- (BOOL) resultSpecIsSet;
@end

@implementation EDAMfindNotesMetadata_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter offset: (int32_t) offset maxNotes: (int32_t) maxNotes resultSpec: (EDAMNotesMetadataResultSpec *) resultSpec
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __filter = [filter retain];
  __filter_isset = YES;
  __offset = offset;
  __offset_isset = YES;
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
  __resultSpec = [resultSpec retain];
  __resultSpec_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"offset"])
  {
    __offset = [decoder decodeInt32ForKey: @"offset"];
    __offset_isset = YES;
  }
  if ([decoder containsValueForKey: @"maxNotes"])
  {
    __maxNotes = [decoder decodeInt32ForKey: @"maxNotes"];
    __maxNotes_isset = YES;
  }
  if ([decoder containsValueForKey: @"resultSpec"])
  {
    __resultSpec = [[decoder decodeObjectForKey: @"resultSpec"] retain];
    __resultSpec_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__offset_isset)
  {
    [encoder encodeInt32: __offset forKey: @"offset"];
  }
  if (__maxNotes_isset)
  {
    [encoder encodeInt32: __maxNotes forKey: @"maxNotes"];
  }
  if (__resultSpec_isset)
  {
    [encoder encodeObject: __resultSpec forKey: @"resultSpec"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__filter release];
  [__resultSpec release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain] autorelease];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain];
  [__filter release];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release];
  __filter = nil;
  __filter_isset = NO;
}

- (int32_t) offset {
  return __offset;
}

- (void) setOffset: (int32_t) offset {
  __offset = offset;
  __offset_isset = YES;
}

- (BOOL) offsetIsSet {
  return __offset_isset;
}

- (void) unsetOffset {
  __offset_isset = NO;
}

- (int32_t) maxNotes {
  return __maxNotes;
}

- (void) setMaxNotes: (int32_t) maxNotes {
  __maxNotes = maxNotes;
  __maxNotes_isset = YES;
}

- (BOOL) maxNotesIsSet {
  return __maxNotes_isset;
}

- (void) unsetMaxNotes {
  __maxNotes_isset = NO;
}

- (EDAMNotesMetadataResultSpec *) resultSpec {
  return [[__resultSpec retain] autorelease];
}

- (void) setResultSpec: (EDAMNotesMetadataResultSpec *) resultSpec {
  [resultSpec retain];
  [__resultSpec release];
  __resultSpec = resultSpec;
  __resultSpec_isset = YES;
}

- (BOOL) resultSpecIsSet {
  return __resultSpec_isset;
}

- (void) unsetResultSpec {
  [__resultSpec release];
  __resultSpec = nil;
  __resultSpec_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setOffset: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setMaxNotes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRUCT) {
          EDAMNotesMetadataResultSpec *fieldValue = [[EDAMNotesMetadataResultSpec alloc] init];
          [fieldValue read: inProtocol];
          [self setResultSpec: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNotesMetadata_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__offset_isset) {
    [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __offset];
    [outProtocol writeFieldEnd];
  }
  if (__maxNotes_isset) {
    [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
    [outProtocol writeI32: __maxNotes];
    [outProtocol writeFieldEnd];
  }
  if (__resultSpec_isset) {
    if (__resultSpec != nil) {
      [outProtocol writeFieldBeginWithName: @"resultSpec" type: TType_STRUCT fieldID: 5];
      [__resultSpec write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNotesMetadata_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",offset:"];
  [ms appendFormat: @"%i", __offset];
  [ms appendString: @",maxNotes:"];
  [ms appendFormat: @"%i", __maxNotes];
  [ms appendString: @",resultSpec:"];
  [ms appendFormat: @"%@", __resultSpec];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNotesMetadata_result : NSObject <NSCoding> {
  EDAMNotesMetadataList * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNotesMetadataList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotesMetadataList * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNotesMetadataList *) success;
- (void) setSuccess: (EDAMNotesMetadataList *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMFindNotesMetadata_result

- (id) initWithSuccess: (EDAMNotesMetadataList *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNotesMetadataList *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotesMetadataList *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotesMetadataList *fieldValue = [[EDAMNotesMetadataList alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNotesMetadata_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNotesMetadata_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMfindNoteCounts_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteFilter * __filter;
  BOOL __withTrash;

  BOOL __authenticationToken_isset;
  BOOL __filter_isset;
  BOOL __withTrash_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=filter, setter=setFilter:) EDAMNoteFilter * filter;
@property (nonatomic, getter=withTrash, setter=setWithTrash:) BOOL withTrash;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNoteFilter *) filter;
- (void) setFilter: (EDAMNoteFilter *) filter;

- (BOOL) withTrash;
- (void) setWithTrash: (BOOL) withTrash;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) filterIsSet;
- (BOOL) withTrashIsSet;
@end

@implementation EDAMfindNoteCounts_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken filter: (EDAMNoteFilter *) filter withTrash: (BOOL) withTrash
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __filter = [filter retain];
  __filter_isset = YES;
  __withTrash = withTrash;
  __withTrash_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"filter"])
  {
    __filter = [[decoder decodeObjectForKey: @"filter"] retain];
    __filter_isset = YES;
  }
  if ([decoder containsValueForKey: @"withTrash"])
  {
    __withTrash = [decoder decodeBoolForKey: @"withTrash"];
    __withTrash_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__filter_isset)
  {
    [encoder encodeObject: __filter forKey: @"filter"];
  }
  if (__withTrash_isset)
  {
    [encoder encodeBool: __withTrash forKey: @"withTrash"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__filter release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteFilter *) filter {
  return [[__filter retain] autorelease];
}

- (void) setFilter: (EDAMNoteFilter *) filter {
  [filter retain];
  [__filter release];
  __filter = filter;
  __filter_isset = YES;
}

- (BOOL) filterIsSet {
  return __filter_isset;
}

- (void) unsetFilter {
  [__filter release];
  __filter = nil;
  __filter_isset = NO;
}

- (BOOL) withTrash {
  return __withTrash;
}

- (void) setWithTrash: (BOOL) withTrash {
  __withTrash = withTrash;
  __withTrash_isset = YES;
}

- (BOOL) withTrashIsSet {
  return __withTrash_isset;
}

- (void) unsetWithTrash {
  __withTrash_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteFilter *fieldValue = [[EDAMNoteFilter alloc] init];
          [fieldValue read: inProtocol];
          [self setFilter: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithTrash: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"findNoteCounts_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__filter_isset) {
    if (__filter != nil) {
      [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
      [__filter write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withTrash_isset) {
    [outProtocol writeFieldBeginWithName: @"withTrash" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withTrash];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"findNoteCounts_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",filter:"];
  [ms appendFormat: @"%@", __filter];
  [ms appendString: @",withTrash:"];
  [ms appendFormat: @"%i", __withTrash];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMFindNoteCounts_result : NSObject <NSCoding> {
  EDAMNoteCollectionCounts * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNoteCollectionCounts *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNoteCollectionCounts * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNoteCollectionCounts *) success;
- (void) setSuccess: (EDAMNoteCollectionCounts *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMFindNoteCounts_result

- (id) initWithSuccess: (EDAMNoteCollectionCounts *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNoteCollectionCounts *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNoteCollectionCounts *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNoteCollectionCounts *fieldValue = [[EDAMNoteCollectionCounts alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"FindNoteCounts_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"FindNoteCounts_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  BOOL __withContent;
  BOOL __withResourcesData;
  BOOL __withResourcesRecognition;
  BOOL __withResourcesAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __withContent_isset;
  BOOL __withResourcesData_isset;
  BOOL __withResourcesRecognition_isset;
  BOOL __withResourcesAlternateData_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, getter=withContent, setter=setWithContent:) BOOL withContent;
@property (nonatomic, getter=withResourcesData, setter=setWithResourcesData:) BOOL withResourcesData;
@property (nonatomic, getter=withResourcesRecognition, setter=setWithResourcesRecognition:) BOOL withResourcesRecognition;
@property (nonatomic, getter=withResourcesAlternateData, setter=setWithResourcesAlternateData:) BOOL withResourcesAlternateData;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (BOOL) withContent;
- (void) setWithContent: (BOOL) withContent;

- (BOOL) withResourcesData;
- (void) setWithResourcesData: (BOOL) withResourcesData;

- (BOOL) withResourcesRecognition;
- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition;

- (BOOL) withResourcesAlternateData;
- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) withContentIsSet;
- (BOOL) withResourcesDataIsSet;
- (BOOL) withResourcesRecognitionIsSet;
- (BOOL) withResourcesAlternateDataIsSet;
@end

@implementation EDAMgetNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withContent: (BOOL) withContent withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __withContent = withContent;
  __withContent_isset = YES;
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"withContent"])
  {
    __withContent = [decoder decodeBoolForKey: @"withContent"];
    __withContent_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesData"])
  {
    __withResourcesData = [decoder decodeBoolForKey: @"withResourcesData"];
    __withResourcesData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesRecognition"])
  {
    __withResourcesRecognition = [decoder decodeBoolForKey: @"withResourcesRecognition"];
    __withResourcesRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesAlternateData"])
  {
    __withResourcesAlternateData = [decoder decodeBoolForKey: @"withResourcesAlternateData"];
    __withResourcesAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__withContent_isset)
  {
    [encoder encodeBool: __withContent forKey: @"withContent"];
  }
  if (__withResourcesData_isset)
  {
    [encoder encodeBool: __withResourcesData forKey: @"withResourcesData"];
  }
  if (__withResourcesRecognition_isset)
  {
    [encoder encodeBool: __withResourcesRecognition forKey: @"withResourcesRecognition"];
  }
  if (__withResourcesAlternateData_isset)
  {
    [encoder encodeBool: __withResourcesAlternateData forKey: @"withResourcesAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (BOOL) withContent {
  return __withContent;
}

- (void) setWithContent: (BOOL) withContent {
  __withContent = withContent;
  __withContent_isset = YES;
}

- (BOOL) withContentIsSet {
  return __withContent_isset;
}

- (void) unsetWithContent {
  __withContent_isset = NO;
}

- (BOOL) withResourcesData {
  return __withResourcesData;
}

- (void) setWithResourcesData: (BOOL) withResourcesData {
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
}

- (BOOL) withResourcesDataIsSet {
  return __withResourcesData_isset;
}

- (void) unsetWithResourcesData {
  __withResourcesData_isset = NO;
}

- (BOOL) withResourcesRecognition {
  return __withResourcesRecognition;
}

- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition {
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
}

- (BOOL) withResourcesRecognitionIsSet {
  return __withResourcesRecognition_isset;
}

- (void) unsetWithResourcesRecognition {
  __withResourcesRecognition_isset = NO;
}

- (BOOL) withResourcesAlternateData {
  return __withResourcesAlternateData;
}

- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData {
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
}

- (BOOL) withResourcesAlternateDataIsSet {
  return __withResourcesAlternateData_isset;
}

- (void) unsetWithResourcesAlternateData {
  __withResourcesAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithContent: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withContent_isset) {
    [outProtocol writeFieldBeginWithName: @"withContent" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withContent];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withResourcesData];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withResourcesRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withResourcesAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",withContent:"];
  [ms appendFormat: @"%i", __withContent];
  [ms appendString: @",withResourcesData:"];
  [ms appendFormat: @"%i", __withResourcesData];
  [ms appendString: @",withResourcesRecognition:"];
  [ms appendFormat: @"%i", __withResourcesRecognition];
  [ms appendString: @",withResourcesAlternateData:"];
  [ms appendFormat: @"%i", __withResourcesAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetNote_result

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteApplicationData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetNoteApplicationData_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteApplicationData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteApplicationData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteApplicationData_result : NSObject <NSCoding> {
  EDAMLazyMap * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMLazyMap *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMLazyMap * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMLazyMap *) success;
- (void) setSuccess: (EDAMLazyMap *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetNoteApplicationData_result

- (id) initWithSuccess: (EDAMLazyMap *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMLazyMap *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMLazyMap *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMLazyMap *fieldValue = [[EDAMLazyMap alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteApplicationData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteApplicationData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, retain, getter=key, setter=setKey:) NSString * key;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (NSString *) key;
- (void) setKey: (NSString *) key;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) keyIsSet;
@end

@implementation EDAMgetNoteApplicationDataEntry_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __key = [key retain];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [__key release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain] autorelease];
}

- (void) setKey: (NSString *) key {
  [key retain];
  [__key release];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteApplicationDataEntry_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSString *) success;
- (void) setSuccess: (NSString *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetNoteApplicationDataEntry_result

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteApplicationDataEntry_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMsetNoteApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;
  NSString * __value;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
  BOOL __value_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, retain, getter=key, setter=setKey:) NSString * key;
@property (nonatomic, retain, getter=value, setter=setValue:) NSString * value;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (NSString *) key;
- (void) setKey: (NSString *) key;

- (NSString *) value;
- (void) setValue: (NSString *) value;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) keyIsSet;
- (BOOL) valueIsSet;
@end

@implementation EDAMsetNoteApplicationDataEntry_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __key = [key retain];
  __key_isset = YES;
  __value = [value retain];
  __value_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain];
    __key_isset = YES;
  }
  if ([decoder containsValueForKey: @"value"])
  {
    __value = [[decoder decodeObjectForKey: @"value"] retain];
    __value_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
  if (__value_isset)
  {
    [encoder encodeObject: __value forKey: @"value"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [__key release];
  [__value release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain] autorelease];
}

- (void) setKey: (NSString *) key {
  [key retain];
  [__key release];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release];
  __key = nil;
  __key_isset = NO;
}

- (NSString *) value {
  return [[__value retain] autorelease];
}

- (void) setValue: (NSString *) value {
  [value retain];
  [__value release];
  __value = value;
  __value_isset = YES;
}

- (BOOL) valueIsSet {
  return __value_isset;
}

- (void) unsetValue {
  [__value release];
  __value = nil;
  __value_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setValue: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"setNoteApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  if (__value_isset) {
    if (__value != nil) {
      [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __value];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"setNoteApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @",value:"];
  [ms appendFormat: @"\"%@\"", __value];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMSetNoteApplicationDataEntry_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMSetNoteApplicationDataEntry_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SetNoteApplicationDataEntry_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SetNoteApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMunsetNoteApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, retain, getter=key, setter=setKey:) NSString * key;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (NSString *) key;
- (void) setKey: (NSString *) key;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) keyIsSet;
@end

@implementation EDAMunsetNoteApplicationDataEntry_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __key = [key retain];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [__key release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain] autorelease];
}

- (void) setKey: (NSString *) key {
  [key retain];
  [__key release];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"unsetNoteApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"unsetNoteApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUnsetNoteApplicationDataEntry_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMUnsetNoteApplicationDataEntry_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UnsetNoteApplicationDataEntry_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UnsetNoteApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteContent_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetNoteContent_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteContent_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteContent_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteContent_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSString *) success;
- (void) setSuccess: (NSString *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetNoteContent_result

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteContent_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteContent_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteSearchText_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  BOOL __noteOnly;
  BOOL __tokenizeForIndexing;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __noteOnly_isset;
  BOOL __tokenizeForIndexing_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid noteOnly: (BOOL) noteOnly tokenizeForIndexing: (BOOL) tokenizeForIndexing;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, getter=noteOnly, setter=setNoteOnly:) BOOL noteOnly;
@property (nonatomic, getter=tokenizeForIndexing, setter=setTokenizeForIndexing:) BOOL tokenizeForIndexing;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (BOOL) noteOnly;
- (void) setNoteOnly: (BOOL) noteOnly;

- (BOOL) tokenizeForIndexing;
- (void) setTokenizeForIndexing: (BOOL) tokenizeForIndexing;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) noteOnlyIsSet;
- (BOOL) tokenizeForIndexingIsSet;
@end

@implementation EDAMgetNoteSearchText_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid noteOnly: (BOOL) noteOnly tokenizeForIndexing: (BOOL) tokenizeForIndexing
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __noteOnly = noteOnly;
  __noteOnly_isset = YES;
  __tokenizeForIndexing = tokenizeForIndexing;
  __tokenizeForIndexing_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteOnly"])
  {
    __noteOnly = [decoder decodeBoolForKey: @"noteOnly"];
    __noteOnly_isset = YES;
  }
  if ([decoder containsValueForKey: @"tokenizeForIndexing"])
  {
    __tokenizeForIndexing = [decoder decodeBoolForKey: @"tokenizeForIndexing"];
    __tokenizeForIndexing_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__noteOnly_isset)
  {
    [encoder encodeBool: __noteOnly forKey: @"noteOnly"];
  }
  if (__tokenizeForIndexing_isset)
  {
    [encoder encodeBool: __tokenizeForIndexing forKey: @"tokenizeForIndexing"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (BOOL) noteOnly {
  return __noteOnly;
}

- (void) setNoteOnly: (BOOL) noteOnly {
  __noteOnly = noteOnly;
  __noteOnly_isset = YES;
}

- (BOOL) noteOnlyIsSet {
  return __noteOnly_isset;
}

- (void) unsetNoteOnly {
  __noteOnly_isset = NO;
}

- (BOOL) tokenizeForIndexing {
  return __tokenizeForIndexing;
}

- (void) setTokenizeForIndexing: (BOOL) tokenizeForIndexing {
  __tokenizeForIndexing = tokenizeForIndexing;
  __tokenizeForIndexing_isset = YES;
}

- (BOOL) tokenizeForIndexingIsSet {
  return __tokenizeForIndexing_isset;
}

- (void) unsetTokenizeForIndexing {
  __tokenizeForIndexing_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setNoteOnly: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setTokenizeForIndexing: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteSearchText_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteOnly_isset) {
    [outProtocol writeFieldBeginWithName: @"noteOnly" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __noteOnly];
    [outProtocol writeFieldEnd];
  }
  if (__tokenizeForIndexing_isset) {
    [outProtocol writeFieldBeginWithName: @"tokenizeForIndexing" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __tokenizeForIndexing];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteSearchText_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",noteOnly:"];
  [ms appendFormat: @"%i", __noteOnly];
  [ms appendString: @",tokenizeForIndexing:"];
  [ms appendFormat: @"%i", __tokenizeForIndexing];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteSearchText_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSString *) success;
- (void) setSuccess: (NSString *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetNoteSearchText_result

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteSearchText_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteSearchText_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceSearchText_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetResourceSearchText_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceSearchText_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceSearchText_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceSearchText_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSString *) success;
- (void) setSuccess: (NSString *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResourceSearchText_result

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceSearchText_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceSearchText_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteTagNames_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetNoteTagNames_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteTagNames_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteTagNames_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteTagNames_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetNoteTagNames_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size148;
          [inProtocol readListBeginReturningElementType: NULL size: &_size148];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size148];
          int _i149;
          for (_i149 = 0; _i149 < _size148; ++_i149)
          {
            NSString * _elem150 = [inProtocol readString];
            [fieldValue addObject: _elem150];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteTagNames_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__success count]];
        int i152;
        for (i152 = 0; i152 < [__success count]; i152++)
        {
          [outProtocol writeString: [__success objectAtIndex: i152]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteTagNames_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNote * __note;

  BOOL __authenticationToken_isset;
  BOOL __note_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=note, setter=setNote:) EDAMNote * note;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNote *) note;
- (void) setNote: (EDAMNote *) note;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) noteIsSet;
@end

@implementation EDAMcreateNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __note = [note retain];
  __note_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain];
    __note_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__note release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain] autorelease];
}

- (void) setNote: (EDAMNote *) note {
  [note retain];
  [__note release];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release];
  __note = nil;
  __note_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMCreateNote_result

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNote * __note;

  BOOL __authenticationToken_isset;
  BOOL __note_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=note, setter=setNote:) EDAMNote * note;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNote *) note;
- (void) setNote: (EDAMNote *) note;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) noteIsSet;
@end

@implementation EDAMupdateNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken note: (EDAMNote *) note
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __note = [note retain];
  __note_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"note"])
  {
    __note = [[decoder decodeObjectForKey: @"note"] retain];
    __note_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__note_isset)
  {
    [encoder encodeObject: __note forKey: @"note"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__note release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNote *) note {
  return [[__note retain] autorelease];
}

- (void) setNote: (EDAMNote *) note {
  [note retain];
  [__note release];
  __note = note;
  __note_isset = YES;
}

- (BOOL) noteIsSet {
  return __note_isset;
}

- (void) unsetNote {
  [__note release];
  __note = nil;
  __note_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setNote: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__note_isset) {
    if (__note != nil) {
      [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
      [__note write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",note:"];
  [ms appendFormat: @"%@", __note];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMUpdateNote_result

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMdeleteNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMdeleteNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"deleteNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"deleteNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMDeleteNote_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMDeleteNote_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"DeleteNote_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"DeleteNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMexpungeNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNote_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMExpungeNote_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNote_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  NSArray * __noteGuids;

  BOOL __authenticationToken_isset;
  BOOL __noteGuids_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuids: (NSArray *) noteGuids;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuids, setter=setNoteGuids:) NSArray * noteGuids;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (NSArray *) noteGuids;
- (void) setNoteGuids: (NSArray *) noteGuids;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) noteGuidsIsSet;
@end

@implementation EDAMexpungeNotes_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuids: (NSArray *) noteGuids
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuids = [noteGuids retain];
  __noteGuids_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuids"])
  {
    __noteGuids = [[decoder decodeObjectForKey: @"noteGuids"] retain];
    __noteGuids_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuids_isset)
  {
    [encoder encodeObject: __noteGuids forKey: @"noteGuids"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuids release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSArray *) noteGuids {
  return [[__noteGuids retain] autorelease];
}

- (void) setNoteGuids: (NSArray *) noteGuids {
  [noteGuids retain];
  [__noteGuids release];
  __noteGuids = noteGuids;
  __noteGuids_isset = YES;
}

- (BOOL) noteGuidsIsSet {
  return __noteGuids_isset;
}

- (void) unsetNoteGuids {
  [__noteGuids release];
  __noteGuids = nil;
  __noteGuids_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size153;
          [inProtocol readListBeginReturningElementType: NULL size: &_size153];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size153];
          int _i154;
          for (_i154 = 0; _i154 < _size153; ++_i154)
          {
            NSString * _elem155 = [inProtocol readString];
            [fieldValue addObject: _elem155];
          }
          [inProtocol readListEnd];
          [self setNoteGuids: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuids_isset) {
    if (__noteGuids != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuids" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__noteGuids count]];
        int i157;
        for (i157 = 0; i157 < [__noteGuids count]; i157++)
        {
          [outProtocol writeString: [__noteGuids objectAtIndex: i157]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuids:"];
  [ms appendFormat: @"%@", __noteGuids];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeNotes_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMExpungeNotes_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeNotes_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeInactiveNotes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMexpungeInactiveNotes_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeInactiveNotes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeInactiveNotes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeInactiveNotes_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMExpungeInactiveNotes_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeInactiveNotes_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeInactiveNotes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcopyNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  EDAMGuid __toNotebookGuid;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __toNotebookGuid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, retain, getter=toNotebookGuid, setter=setToNotebookGuid:) EDAMGuid toNotebookGuid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;

- (EDAMGuid) toNotebookGuid;
- (void) setToNotebookGuid: (EDAMGuid) toNotebookGuid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) noteGuidIsSet;
- (BOOL) toNotebookGuidIsSet;
@end

@implementation EDAMcopyNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid toNotebookGuid: (EDAMGuid) toNotebookGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain];
  __noteGuid_isset = YES;
  __toNotebookGuid = [toNotebookGuid retain];
  __toNotebookGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"toNotebookGuid"])
  {
    __toNotebookGuid = [[decoder decodeObjectForKey: @"toNotebookGuid"] retain];
    __toNotebookGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__toNotebookGuid_isset)
  {
    [encoder encodeObject: __toNotebookGuid forKey: @"toNotebookGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuid release];
  [__toNotebookGuid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain] autorelease];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain];
  [__noteGuid release];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (NSString *) toNotebookGuid {
  return [[__toNotebookGuid retain] autorelease];
}

- (void) setToNotebookGuid: (NSString *) toNotebookGuid {
  [toNotebookGuid retain];
  [__toNotebookGuid release];
  __toNotebookGuid = toNotebookGuid;
  __toNotebookGuid_isset = YES;
}

- (BOOL) toNotebookGuidIsSet {
  return __toNotebookGuid_isset;
}

- (void) unsetToNotebookGuid {
  [__toNotebookGuid release];
  __toNotebookGuid = nil;
  __toNotebookGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setToNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"copyNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__toNotebookGuid_isset) {
    if (__toNotebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"toNotebookGuid" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __toNotebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"copyNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",toNotebookGuid:"];
  [ms appendFormat: @"\"%@\"", __toNotebookGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCopyNote_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMCopyNote_result

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CopyNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CopyNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistNoteVersions_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) noteGuidIsSet;
@end

@implementation EDAMlistNoteVersions_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain];
  __noteGuid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain];
    __noteGuid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain] autorelease];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain];
  [__noteGuid release];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listNoteVersions_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listNoteVersions_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListNoteVersions_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMListNoteVersions_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size158;
          [inProtocol readListBeginReturningElementType: NULL size: &_size158];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size158];
          int _i159;
          for (_i159 = 0; _i159 < _size158; ++_i159)
          {
            EDAMNoteVersionId *_elem160 = [[EDAMNoteVersionId alloc] init];
            [_elem160 read: inProtocol];
            [fieldValue addObject: _elem160];
            [_elem160 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListNoteVersions_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i162;
        for (i162 = 0; i162 < [__success count]; i162++)
        {
          [[__success objectAtIndex: i162] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListNoteVersions_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetNoteVersion_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  int32_t __updateSequenceNum;
  BOOL __withResourcesData;
  BOOL __withResourcesRecognition;
  BOOL __withResourcesAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __updateSequenceNum_isset;
  BOOL __withResourcesData_isset;
  BOOL __withResourcesRecognition_isset;
  BOOL __withResourcesAlternateData_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, getter=updateSequenceNum, setter=setUpdateSequenceNum:) int32_t updateSequenceNum;
@property (nonatomic, getter=withResourcesData, setter=setWithResourcesData:) BOOL withResourcesData;
@property (nonatomic, getter=withResourcesRecognition, setter=setWithResourcesRecognition:) BOOL withResourcesRecognition;
@property (nonatomic, getter=withResourcesAlternateData, setter=setWithResourcesAlternateData:) BOOL withResourcesAlternateData;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;

- (int32_t) updateSequenceNum;
- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum;

- (BOOL) withResourcesData;
- (void) setWithResourcesData: (BOOL) withResourcesData;

- (BOOL) withResourcesRecognition;
- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition;

- (BOOL) withResourcesAlternateData;
- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) noteGuidIsSet;
- (BOOL) updateSequenceNumIsSet;
- (BOOL) withResourcesDataIsSet;
- (BOOL) withResourcesRecognitionIsSet;
- (BOOL) withResourcesAlternateDataIsSet;
@end

@implementation EDAMgetNoteVersion_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid updateSequenceNum: (int32_t) updateSequenceNum withResourcesData: (BOOL) withResourcesData withResourcesRecognition: (BOOL) withResourcesRecognition withResourcesAlternateData: (BOOL) withResourcesAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain];
  __noteGuid_isset = YES;
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"updateSequenceNum"])
  {
    __updateSequenceNum = [decoder decodeInt32ForKey: @"updateSequenceNum"];
    __updateSequenceNum_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesData"])
  {
    __withResourcesData = [decoder decodeBoolForKey: @"withResourcesData"];
    __withResourcesData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesRecognition"])
  {
    __withResourcesRecognition = [decoder decodeBoolForKey: @"withResourcesRecognition"];
    __withResourcesRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withResourcesAlternateData"])
  {
    __withResourcesAlternateData = [decoder decodeBoolForKey: @"withResourcesAlternateData"];
    __withResourcesAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__updateSequenceNum_isset)
  {
    [encoder encodeInt32: __updateSequenceNum forKey: @"updateSequenceNum"];
  }
  if (__withResourcesData_isset)
  {
    [encoder encodeBool: __withResourcesData forKey: @"withResourcesData"];
  }
  if (__withResourcesRecognition_isset)
  {
    [encoder encodeBool: __withResourcesRecognition forKey: @"withResourcesRecognition"];
  }
  if (__withResourcesAlternateData_isset)
  {
    [encoder encodeBool: __withResourcesAlternateData forKey: @"withResourcesAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain] autorelease];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain];
  [__noteGuid release];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (int32_t) updateSequenceNum {
  return __updateSequenceNum;
}

- (void) setUpdateSequenceNum: (int32_t) updateSequenceNum {
  __updateSequenceNum = updateSequenceNum;
  __updateSequenceNum_isset = YES;
}

- (BOOL) updateSequenceNumIsSet {
  return __updateSequenceNum_isset;
}

- (void) unsetUpdateSequenceNum {
  __updateSequenceNum_isset = NO;
}

- (BOOL) withResourcesData {
  return __withResourcesData;
}

- (void) setWithResourcesData: (BOOL) withResourcesData {
  __withResourcesData = withResourcesData;
  __withResourcesData_isset = YES;
}

- (BOOL) withResourcesDataIsSet {
  return __withResourcesData_isset;
}

- (void) unsetWithResourcesData {
  __withResourcesData_isset = NO;
}

- (BOOL) withResourcesRecognition {
  return __withResourcesRecognition;
}

- (void) setWithResourcesRecognition: (BOOL) withResourcesRecognition {
  __withResourcesRecognition = withResourcesRecognition;
  __withResourcesRecognition_isset = YES;
}

- (BOOL) withResourcesRecognitionIsSet {
  return __withResourcesRecognition_isset;
}

- (void) unsetWithResourcesRecognition {
  __withResourcesRecognition_isset = NO;
}

- (BOOL) withResourcesAlternateData {
  return __withResourcesAlternateData;
}

- (void) setWithResourcesAlternateData: (BOOL) withResourcesAlternateData {
  __withResourcesAlternateData = withResourcesAlternateData;
  __withResourcesAlternateData_isset = YES;
}

- (BOOL) withResourcesAlternateDataIsSet {
  return __withResourcesAlternateData_isset;
}

- (void) unsetWithResourcesAlternateData {
  __withResourcesAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUpdateSequenceNum: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithResourcesAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNoteVersion_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__updateSequenceNum_isset) {
    [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __updateSequenceNum];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withResourcesData];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withResourcesRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withResourcesAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withResourcesAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNoteVersion_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",updateSequenceNum:"];
  [ms appendFormat: @"%i", __updateSequenceNum];
  [ms appendString: @",withResourcesData:"];
  [ms appendFormat: @"%i", __withResourcesData];
  [ms appendString: @",withResourcesRecognition:"];
  [ms appendFormat: @"%i", __withResourcesRecognition];
  [ms appendString: @",withResourcesAlternateData:"];
  [ms appendFormat: @"%i", __withResourcesAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetNoteVersion_result : NSObject <NSCoding> {
  EDAMNote * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNote * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNote *) success;
- (void) setSuccess: (EDAMNote *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetNoteVersion_result

- (id) initWithSuccess: (EDAMNote *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNote *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNote *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNote *fieldValue = [[EDAMNote alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNoteVersion_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNoteVersion_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResource_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  BOOL __withData;
  BOOL __withRecognition;
  BOOL __withAttributes;
  BOOL __withAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __withData_isset;
  BOOL __withRecognition_isset;
  BOOL __withAttributes_isset;
  BOOL __withAlternateData_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, getter=withData, setter=setWithData:) BOOL withData;
@property (nonatomic, getter=withRecognition, setter=setWithRecognition:) BOOL withRecognition;
@property (nonatomic, getter=withAttributes, setter=setWithAttributes:) BOOL withAttributes;
@property (nonatomic, getter=withAlternateData, setter=setWithAlternateData:) BOOL withAlternateData;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (BOOL) withData;
- (void) setWithData: (BOOL) withData;

- (BOOL) withRecognition;
- (void) setWithRecognition: (BOOL) withRecognition;

- (BOOL) withAttributes;
- (void) setWithAttributes: (BOOL) withAttributes;

- (BOOL) withAlternateData;
- (void) setWithAlternateData: (BOOL) withAlternateData;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) withDataIsSet;
- (BOOL) withRecognitionIsSet;
- (BOOL) withAttributesIsSet;
- (BOOL) withAlternateDataIsSet;
@end

@implementation EDAMgetResource_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAttributes: (BOOL) withAttributes withAlternateData: (BOOL) withAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __withData = withData;
  __withData_isset = YES;
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
  __withAttributes = withAttributes;
  __withAttributes_isset = YES;
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"withData"])
  {
    __withData = [decoder decodeBoolForKey: @"withData"];
    __withData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withRecognition"])
  {
    __withRecognition = [decoder decodeBoolForKey: @"withRecognition"];
    __withRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAttributes"])
  {
    __withAttributes = [decoder decodeBoolForKey: @"withAttributes"];
    __withAttributes_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAlternateData"])
  {
    __withAlternateData = [decoder decodeBoolForKey: @"withAlternateData"];
    __withAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__withData_isset)
  {
    [encoder encodeBool: __withData forKey: @"withData"];
  }
  if (__withRecognition_isset)
  {
    [encoder encodeBool: __withRecognition forKey: @"withRecognition"];
  }
  if (__withAttributes_isset)
  {
    [encoder encodeBool: __withAttributes forKey: @"withAttributes"];
  }
  if (__withAlternateData_isset)
  {
    [encoder encodeBool: __withAlternateData forKey: @"withAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (BOOL) withData {
  return __withData;
}

- (void) setWithData: (BOOL) withData {
  __withData = withData;
  __withData_isset = YES;
}

- (BOOL) withDataIsSet {
  return __withData_isset;
}

- (void) unsetWithData {
  __withData_isset = NO;
}

- (BOOL) withRecognition {
  return __withRecognition;
}

- (void) setWithRecognition: (BOOL) withRecognition {
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
}

- (BOOL) withRecognitionIsSet {
  return __withRecognition_isset;
}

- (void) unsetWithRecognition {
  __withRecognition_isset = NO;
}

- (BOOL) withAttributes {
  return __withAttributes;
}

- (void) setWithAttributes: (BOOL) withAttributes {
  __withAttributes = withAttributes;
  __withAttributes_isset = YES;
}

- (BOOL) withAttributesIsSet {
  return __withAttributes_isset;
}

- (void) unsetWithAttributes {
  __withAttributes_isset = NO;
}

- (BOOL) withAlternateData {
  return __withAlternateData;
}

- (void) setWithAlternateData: (BOOL) withAlternateData {
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
}

- (BOOL) withAlternateDataIsSet {
  return __withAlternateData_isset;
}

- (void) unsetWithAlternateData {
  __withAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAttributes: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResource_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withData_isset) {
    [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 3];
    [outProtocol writeBool: __withData];
    [outProtocol writeFieldEnd];
  }
  if (__withRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withAttributes_isset) {
    [outProtocol writeFieldBeginWithName: @"withAttributes" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withAttributes];
    [outProtocol writeFieldEnd];
  }
  if (__withAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResource_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",withData:"];
  [ms appendFormat: @"%i", __withData];
  [ms appendString: @",withRecognition:"];
  [ms appendFormat: @"%i", __withRecognition];
  [ms appendString: @",withAttributes:"];
  [ms appendFormat: @"%i", __withAttributes];
  [ms appendString: @",withAlternateData:"];
  [ms appendFormat: @"%i", __withAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResource_result : NSObject <NSCoding> {
  EDAMResource * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMResource * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMResource *) success;
- (void) setSuccess: (EDAMResource *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResource_result

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMResource *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMResource *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResource_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResource_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceApplicationData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetResourceApplicationData_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceApplicationData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceApplicationData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceApplicationData_result : NSObject <NSCoding> {
  EDAMLazyMap * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMLazyMap *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMLazyMap * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMLazyMap *) success;
- (void) setSuccess: (EDAMLazyMap *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResourceApplicationData_result

- (id) initWithSuccess: (EDAMLazyMap *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMLazyMap *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMLazyMap *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMLazyMap *fieldValue = [[EDAMLazyMap alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceApplicationData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceApplicationData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, retain, getter=key, setter=setKey:) NSString * key;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (NSString *) key;
- (void) setKey: (NSString *) key;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) keyIsSet;
@end

@implementation EDAMgetResourceApplicationDataEntry_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __key = [key retain];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [__key release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain] autorelease];
}

- (void) setKey: (NSString *) key {
  [key retain];
  [__key release];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceApplicationDataEntry_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSString *) success;
- (void) setSuccess: (NSString *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResourceApplicationDataEntry_result

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceApplicationDataEntry_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMsetResourceApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;
  NSString * __value;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
  BOOL __value_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, retain, getter=key, setter=setKey:) NSString * key;
@property (nonatomic, retain, getter=value, setter=setValue:) NSString * value;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (NSString *) key;
- (void) setKey: (NSString *) key;

- (NSString *) value;
- (void) setValue: (NSString *) value;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) keyIsSet;
- (BOOL) valueIsSet;
@end

@implementation EDAMsetResourceApplicationDataEntry_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key value: (NSString *) value
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __key = [key retain];
  __key_isset = YES;
  __value = [value retain];
  __value_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain];
    __key_isset = YES;
  }
  if ([decoder containsValueForKey: @"value"])
  {
    __value = [[decoder decodeObjectForKey: @"value"] retain];
    __value_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
  if (__value_isset)
  {
    [encoder encodeObject: __value forKey: @"value"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [__key release];
  [__value release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain] autorelease];
}

- (void) setKey: (NSString *) key {
  [key retain];
  [__key release];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release];
  __key = nil;
  __key_isset = NO;
}

- (NSString *) value {
  return [[__value retain] autorelease];
}

- (void) setValue: (NSString *) value {
  [value retain];
  [__value release];
  __value = value;
  __value_isset = YES;
}

- (BOOL) valueIsSet {
  return __value_isset;
}

- (void) unsetValue {
  [__value release];
  __value = nil;
  __value_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setValue: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"setResourceApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  if (__value_isset) {
    if (__value != nil) {
      [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __value];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"setResourceApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @",value:"];
  [ms appendFormat: @"\"%@\"", __value];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMSetResourceApplicationDataEntry_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMSetResourceApplicationDataEntry_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SetResourceApplicationDataEntry_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SetResourceApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMunsetResourceApplicationDataEntry_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;
  NSString * __key;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
  BOOL __key_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
@property (nonatomic, retain, getter=key, setter=setKey:) NSString * key;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

- (NSString *) key;
- (void) setKey: (NSString *) key;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
- (BOOL) keyIsSet;
@end

@implementation EDAMunsetResourceApplicationDataEntry_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid key: (NSString *) key
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  __key = [key retain];
  __key_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"key"])
  {
    __key = [[decoder decodeObjectForKey: @"key"] retain];
    __key_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__key_isset)
  {
    [encoder encodeObject: __key forKey: @"key"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [__key release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) key {
  return [[__key retain] autorelease];
}

- (void) setKey: (NSString *) key {
  [key retain];
  [__key release];
  __key = key;
  __key_isset = YES;
}

- (BOOL) keyIsSet {
  return __key_isset;
}

- (void) unsetKey {
  [__key release];
  __key = nil;
  __key_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"unsetResourceApplicationDataEntry_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__key_isset) {
    if (__key != nil) {
      [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __key];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"unsetResourceApplicationDataEntry_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",key:"];
  [ms appendFormat: @"\"%@\"", __key];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUnsetResourceApplicationDataEntry_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMUnsetResourceApplicationDataEntry_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UnsetResourceApplicationDataEntry_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UnsetResourceApplicationDataEntry_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateResource_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMResource * __resource;

  BOOL __authenticationToken_isset;
  BOOL __resource_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken resource: (EDAMResource *) resource;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=resource, setter=setResource:) EDAMResource * resource;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMResource *) resource;
- (void) setResource: (EDAMResource *) resource;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) resourceIsSet;
@end

@implementation EDAMupdateResource_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken resource: (EDAMResource *) resource
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __resource = [resource retain];
  __resource_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"resource"])
  {
    __resource = [[decoder decodeObjectForKey: @"resource"] retain];
    __resource_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__resource_isset)
  {
    [encoder encodeObject: __resource forKey: @"resource"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__resource release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMResource *) resource {
  return [[__resource retain] autorelease];
}

- (void) setResource: (EDAMResource *) resource {
  [resource retain];
  [__resource release];
  __resource = resource;
  __resource_isset = YES;
}

- (BOOL) resourceIsSet {
  return __resource_isset;
}

- (void) unsetResource {
  [__resource release];
  __resource = nil;
  __resource_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setResource: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateResource_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__resource_isset) {
    if (__resource != nil) {
      [outProtocol writeFieldBeginWithName: @"resource" type: TType_STRUCT fieldID: 2];
      [__resource write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateResource_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",resource:"];
  [ms appendFormat: @"%@", __resource];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateResource_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMUpdateResource_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateResource_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateResource_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetResourceData_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceData_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSData *) success;
- (void) setSuccess: (NSData *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResourceData_result

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSData *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSData *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceByHash_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __noteGuid;
  NSData * __contentHash;
  BOOL __withData;
  BOOL __withRecognition;
  BOOL __withAlternateData;

  BOOL __authenticationToken_isset;
  BOOL __noteGuid_isset;
  BOOL __contentHash_isset;
  BOOL __withData_isset;
  BOOL __withRecognition_isset;
  BOOL __withAlternateData_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=noteGuid, setter=setNoteGuid:) EDAMGuid noteGuid;
@property (nonatomic, retain, getter=contentHash, setter=setContentHash:) NSData * contentHash;
@property (nonatomic, getter=withData, setter=setWithData:) BOOL withData;
@property (nonatomic, getter=withRecognition, setter=setWithRecognition:) BOOL withRecognition;
@property (nonatomic, getter=withAlternateData, setter=setWithAlternateData:) BOOL withAlternateData;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) noteGuid;
- (void) setNoteGuid: (EDAMGuid) noteGuid;

- (NSData *) contentHash;
- (void) setContentHash: (NSData *) contentHash;

- (BOOL) withData;
- (void) setWithData: (BOOL) withData;

- (BOOL) withRecognition;
- (void) setWithRecognition: (BOOL) withRecognition;

- (BOOL) withAlternateData;
- (void) setWithAlternateData: (BOOL) withAlternateData;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) noteGuidIsSet;
- (BOOL) contentHashIsSet;
- (BOOL) withDataIsSet;
- (BOOL) withRecognitionIsSet;
- (BOOL) withAlternateDataIsSet;
@end

@implementation EDAMgetResourceByHash_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken noteGuid: (EDAMGuid) noteGuid contentHash: (NSData *) contentHash withData: (BOOL) withData withRecognition: (BOOL) withRecognition withAlternateData: (BOOL) withAlternateData
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __noteGuid = [noteGuid retain];
  __noteGuid_isset = YES;
  __contentHash = [contentHash retain];
  __contentHash_isset = YES;
  __withData = withData;
  __withData_isset = YES;
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteGuid"])
  {
    __noteGuid = [[decoder decodeObjectForKey: @"noteGuid"] retain];
    __noteGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"contentHash"])
  {
    __contentHash = [[decoder decodeObjectForKey: @"contentHash"] retain];
    __contentHash_isset = YES;
  }
  if ([decoder containsValueForKey: @"withData"])
  {
    __withData = [decoder decodeBoolForKey: @"withData"];
    __withData_isset = YES;
  }
  if ([decoder containsValueForKey: @"withRecognition"])
  {
    __withRecognition = [decoder decodeBoolForKey: @"withRecognition"];
    __withRecognition_isset = YES;
  }
  if ([decoder containsValueForKey: @"withAlternateData"])
  {
    __withAlternateData = [decoder decodeBoolForKey: @"withAlternateData"];
    __withAlternateData_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__noteGuid_isset)
  {
    [encoder encodeObject: __noteGuid forKey: @"noteGuid"];
  }
  if (__contentHash_isset)
  {
    [encoder encodeObject: __contentHash forKey: @"contentHash"];
  }
  if (__withData_isset)
  {
    [encoder encodeBool: __withData forKey: @"withData"];
  }
  if (__withRecognition_isset)
  {
    [encoder encodeBool: __withRecognition forKey: @"withRecognition"];
  }
  if (__withAlternateData_isset)
  {
    [encoder encodeBool: __withAlternateData forKey: @"withAlternateData"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__noteGuid release];
  [__contentHash release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) noteGuid {
  return [[__noteGuid retain] autorelease];
}

- (void) setNoteGuid: (NSString *) noteGuid {
  [noteGuid retain];
  [__noteGuid release];
  __noteGuid = noteGuid;
  __noteGuid_isset = YES;
}

- (BOOL) noteGuidIsSet {
  return __noteGuid_isset;
}

- (void) unsetNoteGuid {
  [__noteGuid release];
  __noteGuid = nil;
  __noteGuid_isset = NO;
}

- (NSData *) contentHash {
  return [[__contentHash retain] autorelease];
}

- (void) setContentHash: (NSData *) contentHash {
  [contentHash retain];
  [__contentHash release];
  __contentHash = contentHash;
  __contentHash_isset = YES;
}

- (BOOL) contentHashIsSet {
  return __contentHash_isset;
}

- (void) unsetContentHash {
  [__contentHash release];
  __contentHash = nil;
  __contentHash_isset = NO;
}

- (BOOL) withData {
  return __withData;
}

- (void) setWithData: (BOOL) withData {
  __withData = withData;
  __withData_isset = YES;
}

- (BOOL) withDataIsSet {
  return __withData_isset;
}

- (void) unsetWithData {
  __withData_isset = NO;
}

- (BOOL) withRecognition {
  return __withRecognition;
}

- (void) setWithRecognition: (BOOL) withRecognition {
  __withRecognition = withRecognition;
  __withRecognition_isset = YES;
}

- (BOOL) withRecognitionIsSet {
  return __withRecognition_isset;
}

- (void) unsetWithRecognition {
  __withRecognition_isset = NO;
}

- (BOOL) withAlternateData {
  return __withAlternateData;
}

- (void) setWithAlternateData: (BOOL) withAlternateData {
  __withAlternateData = withAlternateData;
  __withAlternateData_isset = YES;
}

- (BOOL) withAlternateDataIsSet {
  return __withAlternateData_isset;
}

- (void) unsetWithAlternateData {
  __withAlternateData_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setContentHash: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithRecognition: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 6:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setWithAlternateData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceByHash_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteGuid_isset) {
    if (__noteGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__contentHash_isset) {
    if (__contentHash != nil) {
      [outProtocol writeFieldBeginWithName: @"contentHash" type: TType_STRING fieldID: 3];
      [outProtocol writeBinary: __contentHash];
      [outProtocol writeFieldEnd];
    }
  }
  if (__withData_isset) {
    [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __withData];
    [outProtocol writeFieldEnd];
  }
  if (__withRecognition_isset) {
    [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __withRecognition];
    [outProtocol writeFieldEnd];
  }
  if (__withAlternateData_isset) {
    [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
    [outProtocol writeBool: __withAlternateData];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceByHash_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",noteGuid:"];
  [ms appendFormat: @"\"%@\"", __noteGuid];
  [ms appendString: @",contentHash:"];
  [ms appendFormat: @"\"%@\"", __contentHash];
  [ms appendString: @",withData:"];
  [ms appendFormat: @"%i", __withData];
  [ms appendString: @",withRecognition:"];
  [ms appendFormat: @"%i", __withRecognition];
  [ms appendString: @",withAlternateData:"];
  [ms appendFormat: @"%i", __withAlternateData];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceByHash_result : NSObject <NSCoding> {
  EDAMResource * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMResource * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMResource *) success;
- (void) setSuccess: (EDAMResource *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResourceByHash_result

- (id) initWithSuccess: (EDAMResource *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMResource *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMResource *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResource *fieldValue = [[EDAMResource alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceByHash_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceByHash_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceRecognition_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetResourceRecognition_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceRecognition_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceRecognition_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceRecognition_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSData *) success;
- (void) setSuccess: (NSData *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResourceRecognition_result

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSData *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSData *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceRecognition_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceRecognition_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceAlternateData_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetResourceAlternateData_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceAlternateData_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceAlternateData_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceAlternateData_result : NSObject <NSCoding> {
  NSData * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSData * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (NSData *) success;
- (void) setSuccess: (NSData *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResourceAlternateData_result

- (id) initWithSuccess: (NSData *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (NSData *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSData *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceAlternateData_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeBinary: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceAlternateData_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetResourceAttributes_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMgetResourceAttributes_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getResourceAttributes_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getResourceAttributes_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetResourceAttributes_result : NSObject <NSCoding> {
  EDAMResourceAttributes * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMResourceAttributes *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMResourceAttributes * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMResourceAttributes *) success;
- (void) setSuccess: (EDAMResourceAttributes *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetResourceAttributes_result

- (id) initWithSuccess: (EDAMResourceAttributes *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMResourceAttributes *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMResourceAttributes *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMResourceAttributes *fieldValue = [[EDAMResourceAttributes alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetResourceAttributes_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 3];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetResourceAttributes_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetAccountSize_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMgetAccountSize_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAccountSize_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAccountSize_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetAccountSize_result : NSObject <NSCoding> {
  int64_t __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (int64_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int64_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (int64_t) success;
- (void) setSuccess: (int64_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMGetAccountSize_result

- (id) initWithSuccess: (int64_t) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt64ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt64: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (int64_t) success {
  return __success;
}

- (void) setSuccess: (int64_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAccountSize_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I64 fieldID: 0];
    [outProtocol writeI64: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAccountSize_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%qi", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetAds_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMAdParameters * __adParameters;

  BOOL __authenticationToken_isset;
  BOOL __adParameters_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=adParameters, setter=setAdParameters:) EDAMAdParameters * adParameters;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMAdParameters *) adParameters;
- (void) setAdParameters: (EDAMAdParameters *) adParameters;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) adParametersIsSet;
@end

@implementation EDAMgetAds_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __adParameters = [adParameters retain];
  __adParameters_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"adParameters"])
  {
    __adParameters = [[decoder decodeObjectForKey: @"adParameters"] retain];
    __adParameters_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__adParameters_isset)
  {
    [encoder encodeObject: __adParameters forKey: @"adParameters"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__adParameters release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMAdParameters *) adParameters {
  return [[__adParameters retain] autorelease];
}

- (void) setAdParameters: (EDAMAdParameters *) adParameters {
  [adParameters retain];
  [__adParameters release];
  __adParameters = adParameters;
  __adParameters_isset = YES;
}

- (BOOL) adParametersIsSet {
  return __adParameters_isset;
}

- (void) unsetAdParameters {
  [__adParameters release];
  __adParameters = nil;
  __adParameters_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMAdParameters *fieldValue = [[EDAMAdParameters alloc] init];
          [fieldValue read: inProtocol];
          [self setAdParameters: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getAds_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__adParameters_isset) {
    if (__adParameters != nil) {
      [outProtocol writeFieldBeginWithName: @"adParameters" type: TType_STRUCT fieldID: 2];
      [__adParameters write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getAds_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",adParameters:"];
  [ms appendFormat: @"%@", __adParameters];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetAds_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMGetAds_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size163;
          [inProtocol readListBeginReturningElementType: NULL size: &_size163];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size163];
          int _i164;
          for (_i164 = 0; _i164 < _size163; ++_i164)
          {
            EDAMAd *_elem165 = [[EDAMAd alloc] init];
            [_elem165 read: inProtocol];
            [fieldValue addObject: _elem165];
            [_elem165 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetAds_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i167;
        for (i167 = 0; i167 < [__success count]; i167++)
        {
          [[__success objectAtIndex: i167] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetAds_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetRandomAd_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMAdParameters * __adParameters;

  BOOL __authenticationToken_isset;
  BOOL __adParameters_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=adParameters, setter=setAdParameters:) EDAMAdParameters * adParameters;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMAdParameters *) adParameters;
- (void) setAdParameters: (EDAMAdParameters *) adParameters;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) adParametersIsSet;
@end

@implementation EDAMgetRandomAd_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken adParameters: (EDAMAdParameters *) adParameters
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __adParameters = [adParameters retain];
  __adParameters_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"adParameters"])
  {
    __adParameters = [[decoder decodeObjectForKey: @"adParameters"] retain];
    __adParameters_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__adParameters_isset)
  {
    [encoder encodeObject: __adParameters forKey: @"adParameters"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__adParameters release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMAdParameters *) adParameters {
  return [[__adParameters retain] autorelease];
}

- (void) setAdParameters: (EDAMAdParameters *) adParameters {
  [adParameters retain];
  [__adParameters release];
  __adParameters = adParameters;
  __adParameters_isset = YES;
}

- (BOOL) adParametersIsSet {
  return __adParameters_isset;
}

- (void) unsetAdParameters {
  [__adParameters release];
  __adParameters = nil;
  __adParameters_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMAdParameters *fieldValue = [[EDAMAdParameters alloc] init];
          [fieldValue read: inProtocol];
          [self setAdParameters: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getRandomAd_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__adParameters_isset) {
    if (__adParameters != nil) {
      [outProtocol writeFieldBeginWithName: @"adParameters" type: TType_STRUCT fieldID: 2];
      [__adParameters write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getRandomAd_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",adParameters:"];
  [ms appendFormat: @"%@", __adParameters];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetRandomAd_result : NSObject <NSCoding> {
  EDAMAd * __success;
  EDAMUserException * __userException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMAd *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMAd * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMAd *) success;
- (void) setSuccess: (EDAMAd *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMGetRandomAd_result

- (id) initWithSuccess: (EDAMAd *) success userException: (EDAMUserException *) userException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMAd *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMAd *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMAd *fieldValue = [[EDAMAd alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetRandomAd_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 2];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetRandomAd_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetPublicNotebook_args : NSObject <NSCoding> {
  EDAMUserID __userId;
  NSString * __publicUri;

  BOOL __userId_isset;
  BOOL __publicUri_isset;
}

- (id) initWithUserId: (EDAMUserID) userId publicUri: (NSString *) publicUri;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=userId, setter=setUserId:) EDAMUserID userId;
@property (nonatomic, retain, getter=publicUri, setter=setPublicUri:) NSString * publicUri;
#else

- (EDAMUserID) userId;
- (void) setUserId: (EDAMUserID) userId;

- (NSString *) publicUri;
- (void) setPublicUri: (NSString *) publicUri;

#endif

- (BOOL) userIdIsSet;
- (BOOL) publicUriIsSet;
@end

@implementation EDAMgetPublicNotebook_args

- (id) initWithUserId: (EDAMUserID) userId publicUri: (NSString *) publicUri
{
  self = [super init];
  __userId = userId;
  __userId_isset = YES;
  __publicUri = [publicUri retain];
  __publicUri_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userId"])
  {
    __userId = [decoder decodeInt32ForKey: @"userId"];
    __userId_isset = YES;
  }
  if ([decoder containsValueForKey: @"publicUri"])
  {
    __publicUri = [[decoder decodeObjectForKey: @"publicUri"] retain];
    __publicUri_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userId_isset)
  {
    [encoder encodeInt32: __userId forKey: @"userId"];
  }
  if (__publicUri_isset)
  {
    [encoder encodeObject: __publicUri forKey: @"publicUri"];
  }
}

- (void) dealloc
{
  [__publicUri release];
  [super dealloc];
}

- (int32_t) userId {
  return __userId;
}

- (void) setUserId: (int32_t) userId {
  __userId = userId;
  __userId_isset = YES;
}

- (BOOL) userIdIsSet {
  return __userId_isset;
}

- (void) unsetUserId {
  __userId_isset = NO;
}

- (NSString *) publicUri {
  return [[__publicUri retain] autorelease];
}

- (void) setPublicUri: (NSString *) publicUri {
  [publicUri retain];
  [__publicUri release];
  __publicUri = publicUri;
  __publicUri_isset = YES;
}

- (BOOL) publicUriIsSet {
  return __publicUri_isset;
}

- (void) unsetPublicUri {
  [__publicUri release];
  __publicUri = nil;
  __publicUri_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setUserId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setPublicUri: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getPublicNotebook_args"];
  if (__userId_isset) {
    [outProtocol writeFieldBeginWithName: @"userId" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __userId];
    [outProtocol writeFieldEnd];
  }
  if (__publicUri_isset) {
    if (__publicUri != nil) {
      [outProtocol writeFieldBeginWithName: @"publicUri" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __publicUri];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getPublicNotebook_args("];
  [ms appendString: @"userId:"];
  [ms appendFormat: @"%i", __userId];
  [ms appendString: @",publicUri:"];
  [ms appendFormat: @"\"%@\"", __publicUri];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetPublicNotebook_result : NSObject <NSCoding> {
  EDAMNotebook * __success;
  EDAMSystemException * __systemException;
  EDAMNotFoundException * __notFoundException;

  BOOL __success_isset;
  BOOL __systemException_isset;
  BOOL __notFoundException_isset;
}

- (id) initWithSuccess: (EDAMNotebook *) success systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMNotebook * success;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
#else

- (EDAMNotebook *) success;
- (void) setSuccess: (EDAMNotebook *) success;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

#endif

- (BOOL) successIsSet;
- (BOOL) systemExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
@end

@implementation EDAMGetPublicNotebook_result

- (id) initWithSuccess: (EDAMNotebook *) success systemException: (EDAMSystemException *) systemException notFoundException: (EDAMNotFoundException *) notFoundException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__systemException release];
  [__notFoundException release];
  [super dealloc];
}

- (EDAMNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMNotebook *fieldValue = [[EDAMNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetPublicNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 1];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetPublicNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateSharedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMSharedNotebook * __sharedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __sharedNotebook_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=sharedNotebook, setter=setSharedNotebook:) EDAMSharedNotebook * sharedNotebook;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMSharedNotebook *) sharedNotebook;
- (void) setSharedNotebook: (EDAMSharedNotebook *) sharedNotebook;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) sharedNotebookIsSet;
@end

@implementation EDAMcreateSharedNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebook: (EDAMSharedNotebook *) sharedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __sharedNotebook = [sharedNotebook retain];
  __sharedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"sharedNotebook"])
  {
    __sharedNotebook = [[decoder decodeObjectForKey: @"sharedNotebook"] retain];
    __sharedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__sharedNotebook_isset)
  {
    [encoder encodeObject: __sharedNotebook forKey: @"sharedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__sharedNotebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMSharedNotebook *) sharedNotebook {
  return [[__sharedNotebook retain] autorelease];
}

- (void) setSharedNotebook: (EDAMSharedNotebook *) sharedNotebook {
  [sharedNotebook retain];
  [__sharedNotebook release];
  __sharedNotebook = sharedNotebook;
  __sharedNotebook_isset = YES;
}

- (BOOL) sharedNotebookIsSet {
  return __sharedNotebook_isset;
}

- (void) unsetSharedNotebook {
  [__sharedNotebook release];
  __sharedNotebook = nil;
  __sharedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSharedNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createSharedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sharedNotebook_isset) {
    if (__sharedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"sharedNotebook" type: TType_STRUCT fieldID: 2];
      [__sharedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createSharedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",sharedNotebook:"];
  [ms appendFormat: @"%@", __sharedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateSharedNotebook_result : NSObject <NSCoding> {
  EDAMSharedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSharedNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMSharedNotebook *) success;
- (void) setSuccess: (EDAMSharedNotebook *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMCreateSharedNotebook_result

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSharedNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSharedNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateSharedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateSharedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMsendMessageToSharedNotebookMembers_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __notebookGuid;
  NSString * __messageText;
  NSArray * __recipients;

  BOOL __authenticationToken_isset;
  BOOL __notebookGuid_isset;
  BOOL __messageText_isset;
  BOOL __recipients_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid messageText: (NSString *) messageText recipients: (NSArray *) recipients;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=notebookGuid, setter=setNotebookGuid:) EDAMGuid notebookGuid;
@property (nonatomic, retain, getter=messageText, setter=setMessageText:) NSString * messageText;
@property (nonatomic, retain, getter=recipients, setter=setRecipients:) NSArray * recipients;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) notebookGuid;
- (void) setNotebookGuid: (EDAMGuid) notebookGuid;

- (NSString *) messageText;
- (void) setMessageText: (NSString *) messageText;

- (NSArray *) recipients;
- (void) setRecipients: (NSArray *) recipients;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) notebookGuidIsSet;
- (BOOL) messageTextIsSet;
- (BOOL) recipientsIsSet;
@end

@implementation EDAMsendMessageToSharedNotebookMembers_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken notebookGuid: (EDAMGuid) notebookGuid messageText: (NSString *) messageText recipients: (NSArray *) recipients
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __notebookGuid = [notebookGuid retain];
  __notebookGuid_isset = YES;
  __messageText = [messageText retain];
  __messageText_isset = YES;
  __recipients = [recipients retain];
  __recipients_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"notebookGuid"])
  {
    __notebookGuid = [[decoder decodeObjectForKey: @"notebookGuid"] retain];
    __notebookGuid_isset = YES;
  }
  if ([decoder containsValueForKey: @"messageText"])
  {
    __messageText = [[decoder decodeObjectForKey: @"messageText"] retain];
    __messageText_isset = YES;
  }
  if ([decoder containsValueForKey: @"recipients"])
  {
    __recipients = [[decoder decodeObjectForKey: @"recipients"] retain];
    __recipients_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__notebookGuid_isset)
  {
    [encoder encodeObject: __notebookGuid forKey: @"notebookGuid"];
  }
  if (__messageText_isset)
  {
    [encoder encodeObject: __messageText forKey: @"messageText"];
  }
  if (__recipients_isset)
  {
    [encoder encodeObject: __recipients forKey: @"recipients"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__notebookGuid release];
  [__messageText release];
  [__recipients release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) notebookGuid {
  return [[__notebookGuid retain] autorelease];
}

- (void) setNotebookGuid: (NSString *) notebookGuid {
  [notebookGuid retain];
  [__notebookGuid release];
  __notebookGuid = notebookGuid;
  __notebookGuid_isset = YES;
}

- (BOOL) notebookGuidIsSet {
  return __notebookGuid_isset;
}

- (void) unsetNotebookGuid {
  [__notebookGuid release];
  __notebookGuid = nil;
  __notebookGuid_isset = NO;
}

- (NSString *) messageText {
  return [[__messageText retain] autorelease];
}

- (void) setMessageText: (NSString *) messageText {
  [messageText retain];
  [__messageText release];
  __messageText = messageText;
  __messageText_isset = YES;
}

- (BOOL) messageTextIsSet {
  return __messageText_isset;
}

- (void) unsetMessageText {
  [__messageText release];
  __messageText = nil;
  __messageText_isset = NO;
}

- (NSArray *) recipients {
  return [[__recipients retain] autorelease];
}

- (void) setRecipients: (NSArray *) recipients {
  [recipients retain];
  [__recipients release];
  __recipients = recipients;
  __recipients_isset = YES;
}

- (BOOL) recipientsIsSet {
  return __recipients_isset;
}

- (void) unsetRecipients {
  [__recipients release];
  __recipients = nil;
  __recipients_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNotebookGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setMessageText: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_LIST) {
          int _size168;
          [inProtocol readListBeginReturningElementType: NULL size: &_size168];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size168];
          int _i169;
          for (_i169 = 0; _i169 < _size168; ++_i169)
          {
            NSString * _elem170 = [inProtocol readString];
            [fieldValue addObject: _elem170];
          }
          [inProtocol readListEnd];
          [self setRecipients: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"sendMessageToSharedNotebookMembers_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__notebookGuid_isset) {
    if (__notebookGuid != nil) {
      [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __notebookGuid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__messageText_isset) {
    if (__messageText != nil) {
      [outProtocol writeFieldBeginWithName: @"messageText" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __messageText];
      [outProtocol writeFieldEnd];
    }
  }
  if (__recipients_isset) {
    if (__recipients != nil) {
      [outProtocol writeFieldBeginWithName: @"recipients" type: TType_LIST fieldID: 4];
      {
        [outProtocol writeListBeginWithElementType: TType_STRING size: [__recipients count]];
        int i172;
        for (i172 = 0; i172 < [__recipients count]; i172++)
        {
          [outProtocol writeString: [__recipients objectAtIndex: i172]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"sendMessageToSharedNotebookMembers_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",notebookGuid:"];
  [ms appendFormat: @"\"%@\"", __notebookGuid];
  [ms appendString: @",messageText:"];
  [ms appendFormat: @"\"%@\"", __messageText];
  [ms appendString: @",recipients:"];
  [ms appendFormat: @"%@", __recipients];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMSendMessageToSharedNotebookMembers_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMSendMessageToSharedNotebookMembers_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SendMessageToSharedNotebookMembers_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SendMessageToSharedNotebookMembers_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistSharedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMlistSharedNotebooks_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listSharedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listSharedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListSharedNotebooks_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMListSharedNotebooks_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size173;
          [inProtocol readListBeginReturningElementType: NULL size: &_size173];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size173];
          int _i174;
          for (_i174 = 0; _i174 < _size173; ++_i174)
          {
            EDAMSharedNotebook *_elem175 = [[EDAMSharedNotebook alloc] init];
            [_elem175 read: inProtocol];
            [fieldValue addObject: _elem175];
            [_elem175 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListSharedNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i177;
        for (i177 = 0; i177 < [__success count]; i177++)
        {
          [[__success objectAtIndex: i177] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListSharedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeSharedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  NSArray * __sharedNotebookIds;

  BOOL __authenticationToken_isset;
  BOOL __sharedNotebookIds_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebookIds: (NSArray *) sharedNotebookIds;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=sharedNotebookIds, setter=setSharedNotebookIds:) NSArray * sharedNotebookIds;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (NSArray *) sharedNotebookIds;
- (void) setSharedNotebookIds: (NSArray *) sharedNotebookIds;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) sharedNotebookIdsIsSet;
@end

@implementation EDAMexpungeSharedNotebooks_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken sharedNotebookIds: (NSArray *) sharedNotebookIds
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __sharedNotebookIds = [sharedNotebookIds retain];
  __sharedNotebookIds_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"sharedNotebookIds"])
  {
    __sharedNotebookIds = [[decoder decodeObjectForKey: @"sharedNotebookIds"] retain];
    __sharedNotebookIds_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__sharedNotebookIds_isset)
  {
    [encoder encodeObject: __sharedNotebookIds forKey: @"sharedNotebookIds"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__sharedNotebookIds release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSArray *) sharedNotebookIds {
  return [[__sharedNotebookIds retain] autorelease];
}

- (void) setSharedNotebookIds: (NSArray *) sharedNotebookIds {
  [sharedNotebookIds retain];
  [__sharedNotebookIds release];
  __sharedNotebookIds = sharedNotebookIds;
  __sharedNotebookIds_isset = YES;
}

- (BOOL) sharedNotebookIdsIsSet {
  return __sharedNotebookIds_isset;
}

- (void) unsetSharedNotebookIds {
  [__sharedNotebookIds release];
  __sharedNotebookIds = nil;
  __sharedNotebookIds_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_LIST) {
          int _size178;
          [inProtocol readListBeginReturningElementType: NULL size: &_size178];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size178];
          int _i179;
          for (_i179 = 0; _i179 < _size178; ++_i179)
          {
            int64_t _elem180 = [inProtocol readI64];
            [fieldValue addObject: [NSNumber numberWithLongLong: _elem180]];
          }
          [inProtocol readListEnd];
          [self setSharedNotebookIds: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeSharedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__sharedNotebookIds_isset) {
    if (__sharedNotebookIds != nil) {
      [outProtocol writeFieldBeginWithName: @"sharedNotebookIds" type: TType_LIST fieldID: 2];
      {
        [outProtocol writeListBeginWithElementType: TType_I64 size: [__sharedNotebookIds count]];
        int i182;
        for (i182 = 0; i182 < [__sharedNotebookIds count]; i182++)
        {
          [outProtocol writeI64: [[__sharedNotebookIds objectAtIndex: i182] longLongValue]];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeSharedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",sharedNotebookIds:"];
  [ms appendFormat: @"%@", __sharedNotebookIds];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeSharedNotebooks_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMExpungeSharedNotebooks_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeSharedNotebooks_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeSharedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMcreateLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) linkedNotebookIsSet;
@end

@implementation EDAMcreateLinkedNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain];
  __linkedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain];
    __linkedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__linkedNotebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain] autorelease];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain];
  [__linkedNotebook release];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"createLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"createLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMCreateLinkedNotebook_result : NSObject <NSCoding> {
  EDAMLinkedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMLinkedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMLinkedNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMLinkedNotebook *) success;
- (void) setSuccess: (EDAMLinkedNotebook *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMCreateLinkedNotebook_result

- (id) initWithSuccess: (EDAMLinkedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMLinkedNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMLinkedNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CreateLinkedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CreateLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMupdateLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMLinkedNotebook * __linkedNotebook;

  BOOL __authenticationToken_isset;
  BOOL __linkedNotebook_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=linkedNotebook, setter=setLinkedNotebook:) EDAMLinkedNotebook * linkedNotebook;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMLinkedNotebook *) linkedNotebook;
- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) linkedNotebookIsSet;
@end

@implementation EDAMupdateLinkedNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken linkedNotebook: (EDAMLinkedNotebook *) linkedNotebook
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __linkedNotebook = [linkedNotebook retain];
  __linkedNotebook_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"linkedNotebook"])
  {
    __linkedNotebook = [[decoder decodeObjectForKey: @"linkedNotebook"] retain];
    __linkedNotebook_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__linkedNotebook_isset)
  {
    [encoder encodeObject: __linkedNotebook forKey: @"linkedNotebook"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__linkedNotebook release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMLinkedNotebook *) linkedNotebook {
  return [[__linkedNotebook retain] autorelease];
}

- (void) setLinkedNotebook: (EDAMLinkedNotebook *) linkedNotebook {
  [linkedNotebook retain];
  [__linkedNotebook release];
  __linkedNotebook = linkedNotebook;
  __linkedNotebook_isset = YES;
}

- (BOOL) linkedNotebookIsSet {
  return __linkedNotebook_isset;
}

- (void) unsetLinkedNotebook {
  [__linkedNotebook release];
  __linkedNotebook = nil;
  __linkedNotebook_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMLinkedNotebook *fieldValue = [[EDAMLinkedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setLinkedNotebook: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"updateLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__linkedNotebook_isset) {
    if (__linkedNotebook != nil) {
      [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
      [__linkedNotebook write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"updateLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",linkedNotebook:"];
  [ms appendFormat: @"%@", __linkedNotebook];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMUpdateLinkedNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMUpdateLinkedNotebook_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"UpdateLinkedNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"UpdateLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMlistLinkedNotebooks_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMlistLinkedNotebooks_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"listLinkedNotebooks_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"listLinkedNotebooks_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMListLinkedNotebooks_result : NSObject <NSCoding> {
  NSArray * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSArray * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (NSArray *) success;
- (void) setSuccess: (NSArray *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMListLinkedNotebooks_result

- (id) initWithSuccess: (NSArray *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (NSArray *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSArray *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_LIST) {
          int _size183;
          [inProtocol readListBeginReturningElementType: NULL size: &_size183];
          NSMutableArray * fieldValue = [[NSMutableArray alloc] initWithCapacity: _size183];
          int _i184;
          for (_i184 = 0; _i184 < _size183; ++_i184)
          {
            EDAMLinkedNotebook *_elem185 = [[EDAMLinkedNotebook alloc] init];
            [_elem185 read: inProtocol];
            [fieldValue addObject: _elem185];
            [_elem185 release];
          }
          [inProtocol readListEnd];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ListLinkedNotebooks_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_LIST fieldID: 0];
      {
        [outProtocol writeListBeginWithElementType: TType_STRUCT size: [__success count]];
        int i187;
        for (i187 = 0; i187 < [__success count]; i187++)
        {
          [[__success objectAtIndex: i187] write: outProtocol];
        }
        [outProtocol writeListEnd];
      }
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ListLinkedNotebooks_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMexpungeLinkedNotebook_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMexpungeLinkedNotebook_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"expungeLinkedNotebook_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"expungeLinkedNotebook_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMExpungeLinkedNotebook_result : NSObject <NSCoding> {
  int32_t __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) int32_t success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (int32_t) success;
- (void) setSuccess: (int32_t) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMExpungeLinkedNotebook_result

- (id) initWithSuccess: (int32_t) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeInt32ForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeInt32: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (int32_t) success {
  return __success;
}

- (void) setSuccess: (int32_t) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ExpungeLinkedNotebook_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_I32 fieldID: 0];
    [outProtocol writeI32: __success];
    [outProtocol writeFieldEnd];
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ExpungeLinkedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMauthenticateToSharedNotebook_args : NSObject <NSCoding> {
  NSString * __shareKey;
  NSString * __authenticationToken;

  BOOL __shareKey_isset;
  BOOL __authenticationToken_isset;
}

- (id) initWithShareKey: (NSString *) shareKey authenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=shareKey, setter=setShareKey:) NSString * shareKey;
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) shareKey;
- (void) setShareKey: (NSString *) shareKey;

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) shareKeyIsSet;
- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMauthenticateToSharedNotebook_args

- (id) initWithShareKey: (NSString *) shareKey authenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __shareKey = [shareKey retain];
  __shareKey_isset = YES;
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"shareKey"])
  {
    __shareKey = [[decoder decodeObjectForKey: @"shareKey"] retain];
    __shareKey_isset = YES;
  }
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__shareKey_isset)
  {
    [encoder encodeObject: __shareKey forKey: @"shareKey"];
  }
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__shareKey release];
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) shareKey {
  return [[__shareKey retain] autorelease];
}

- (void) setShareKey: (NSString *) shareKey {
  [shareKey retain];
  [__shareKey release];
  __shareKey = shareKey;
  __shareKey_isset = YES;
}

- (BOOL) shareKeyIsSet {
  return __shareKey_isset;
}

- (void) unsetShareKey {
  [__shareKey release];
  __shareKey = nil;
  __shareKey_isset = NO;
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setShareKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNotebook_args"];
  if (__shareKey_isset) {
    if (__shareKey != nil) {
      [outProtocol writeFieldBeginWithName: @"shareKey" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __shareKey];
      [outProtocol writeFieldEnd];
    }
  }
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"authenticateToSharedNotebook_args("];
  [ms appendString: @"shareKey:"];
  [ms appendFormat: @"\"%@\"", __shareKey];
  [ms appendString: @",authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMAuthenticateToSharedNotebook_result : NSObject <NSCoding> {
  EDAMAuthenticationResult * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMAuthenticationResult * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMAuthenticationResult *) success;
- (void) setSuccess: (EDAMAuthenticationResult *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMAuthenticateToSharedNotebook_result

- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMAuthenticationResult *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMAuthenticationResult *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMAuthenticationResult *fieldValue = [[EDAMAuthenticationResult alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AuthenticateToSharedNotebook_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AuthenticateToSharedNotebook_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMgetSharedNotebookByAuth_args : NSObject <NSCoding> {
  NSString * __authenticationToken;

  BOOL __authenticationToken_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

#endif

- (BOOL) authenticationTokenIsSet;
@end

@implementation EDAMgetSharedNotebookByAuth_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getSharedNotebookByAuth_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getSharedNotebookByAuth_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMGetSharedNotebookByAuth_result : NSObject <NSCoding> {
  EDAMSharedNotebook * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMSharedNotebook * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMSharedNotebook *) success;
- (void) setSuccess: (EDAMSharedNotebook *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMGetSharedNotebookByAuth_result

- (id) initWithSuccess: (EDAMSharedNotebook *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMSharedNotebook *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMSharedNotebook *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMSharedNotebook *fieldValue = [[EDAMSharedNotebook alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetSharedNotebookByAuth_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetSharedNotebookByAuth_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMemailNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMNoteEmailParameters * __parameters;

  BOOL __authenticationToken_isset;
  BOOL __parameters_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=parameters, setter=setParameters:) EDAMNoteEmailParameters * parameters;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMNoteEmailParameters *) parameters;
- (void) setParameters: (EDAMNoteEmailParameters *) parameters;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) parametersIsSet;
@end

@implementation EDAMemailNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken parameters: (EDAMNoteEmailParameters *) parameters
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __parameters = [parameters retain];
  __parameters_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"parameters"])
  {
    __parameters = [[decoder decodeObjectForKey: @"parameters"] retain];
    __parameters_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__parameters_isset)
  {
    [encoder encodeObject: __parameters forKey: @"parameters"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__parameters release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (EDAMNoteEmailParameters *) parameters {
  return [[__parameters retain] autorelease];
}

- (void) setParameters: (EDAMNoteEmailParameters *) parameters {
  [parameters retain];
  [__parameters release];
  __parameters = parameters;
  __parameters_isset = YES;
}

- (BOOL) parametersIsSet {
  return __parameters_isset;
}

- (void) unsetParameters {
  [__parameters release];
  __parameters = nil;
  __parameters_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNoteEmailParameters *fieldValue = [[EDAMNoteEmailParameters alloc] init];
          [fieldValue read: inProtocol];
          [self setParameters: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"emailNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__parameters_isset) {
    if (__parameters != nil) {
      [outProtocol writeFieldBeginWithName: @"parameters" type: TType_STRUCT fieldID: 2];
      [__parameters write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"emailNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",parameters:"];
  [ms appendFormat: @"%@", __parameters];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMEmailNote_result : NSObject <NSCoding> {
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMEmailNote_result

- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"EmailNote_result"];

  if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"EmailNote_result("];
  [ms appendString: @"userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMshareNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMshareNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"shareNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"shareNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMShareNote_result : NSObject <NSCoding> {
  NSString * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) NSString * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (NSString *) success;
- (void) setSuccess: (NSString *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMShareNote_result

- (id) initWithSuccess: (NSString *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (NSString *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (NSString *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ShareNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRING fieldID: 0];
      [outProtocol writeString: __success];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ShareNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"\"%@\"", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMstopSharingNote_args : NSObject <NSCoding> {
  NSString * __authenticationToken;
  EDAMGuid __guid;

  BOOL __authenticationToken_isset;
  BOOL __guid_isset;
}

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authenticationToken, setter=setAuthenticationToken:) NSString * authenticationToken;
@property (nonatomic, retain, getter=guid, setter=setGuid:) EDAMGuid guid;
#else

- (NSString *) authenticationToken;
- (void) setAuthenticationToken: (NSString *) authenticationToken;

- (EDAMGuid) guid;
- (void) setGuid: (EDAMGuid) guid;

#endif

- (BOOL) authenticationTokenIsSet;
- (BOOL) guidIsSet;
@end

@implementation EDAMstopSharingNote_args

- (id) initWithAuthenticationToken: (NSString *) authenticationToken guid: (EDAMGuid) guid
{
  self = [super init];
  __authenticationToken = [authenticationToken retain];
  __authenticationToken_isset = YES;
  __guid = [guid retain];
  __guid_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authenticationToken"])
  {
    __authenticationToken = [[decoder decodeObjectForKey: @"authenticationToken"] retain];
    __authenticationToken_isset = YES;
  }
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authenticationToken_isset)
  {
    [encoder encodeObject: __authenticationToken forKey: @"authenticationToken"];
  }
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
}

- (void) dealloc
{
  [__authenticationToken release];
  [__guid release];
  [super dealloc];
}

- (NSString *) authenticationToken {
  return [[__authenticationToken retain] autorelease];
}

- (void) setAuthenticationToken: (NSString *) authenticationToken {
  [authenticationToken retain];
  [__authenticationToken release];
  __authenticationToken = authenticationToken;
  __authenticationToken_isset = YES;
}

- (BOOL) authenticationTokenIsSet {
  return __authenticationToken_isset;
}

- (void) unsetAuthenticationToken {
  [__authenticationToken release];
  __authenticationToken = nil;
  __authenticationToken_isset = NO;
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setAuthenticationToken: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"stopSharingNote_args"];
  if (__authenticationToken_isset) {
    if (__authenticationToken != nil) {
      [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __authenticationToken];
      [outProtocol writeFieldEnd];
    }
  }
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"stopSharingNote_args("];
  [ms appendString: @"authenticationToken:"];
  [ms appendFormat: @"\"%@\"", __authenticationToken];
  [ms appendString: @",guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMStopSharingNote_result : NSObject <NSCoding> {
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMStopSharingNote_result

- (id) initWithUserException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"StopSharingNote_result"];

  if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"StopSharingNote_result("];
  [ms appendString: @"userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMauthenticateToSharedNote_args : NSObject <NSCoding> {
  NSString * __guid;
  NSString * __noteKey;

  BOOL __guid_isset;
  BOOL __noteKey_isset;
}

- (id) initWithGuid: (NSString *) guid noteKey: (NSString *) noteKey;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=guid, setter=setGuid:) NSString * guid;
@property (nonatomic, retain, getter=noteKey, setter=setNoteKey:) NSString * noteKey;
#else

- (NSString *) guid;
- (void) setGuid: (NSString *) guid;

- (NSString *) noteKey;
- (void) setNoteKey: (NSString *) noteKey;

#endif

- (BOOL) guidIsSet;
- (BOOL) noteKeyIsSet;
@end

@implementation EDAMauthenticateToSharedNote_args

- (id) initWithGuid: (NSString *) guid noteKey: (NSString *) noteKey
{
  self = [super init];
  __guid = [guid retain];
  __guid_isset = YES;
  __noteKey = [noteKey retain];
  __noteKey_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"guid"])
  {
    __guid = [[decoder decodeObjectForKey: @"guid"] retain];
    __guid_isset = YES;
  }
  if ([decoder containsValueForKey: @"noteKey"])
  {
    __noteKey = [[decoder decodeObjectForKey: @"noteKey"] retain];
    __noteKey_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__guid_isset)
  {
    [encoder encodeObject: __guid forKey: @"guid"];
  }
  if (__noteKey_isset)
  {
    [encoder encodeObject: __noteKey forKey: @"noteKey"];
  }
}

- (void) dealloc
{
  [__guid release];
  [__noteKey release];
  [super dealloc];
}

- (NSString *) guid {
  return [[__guid retain] autorelease];
}

- (void) setGuid: (NSString *) guid {
  [guid retain];
  [__guid release];
  __guid = guid;
  __guid_isset = YES;
}

- (BOOL) guidIsSet {
  return __guid_isset;
}

- (void) unsetGuid {
  [__guid release];
  __guid = nil;
  __guid_isset = NO;
}

- (NSString *) noteKey {
  return [[__noteKey retain] autorelease];
}

- (void) setNoteKey: (NSString *) noteKey {
  [noteKey retain];
  [__noteKey release];
  __noteKey = noteKey;
  __noteKey_isset = YES;
}

- (BOOL) noteKeyIsSet {
  return __noteKey_isset;
}

- (void) unsetNoteKey {
  [__noteKey release];
  __noteKey = nil;
  __noteKey_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setGuid: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setNoteKey: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNote_args"];
  if (__guid_isset) {
    if (__guid != nil) {
      [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __guid];
      [outProtocol writeFieldEnd];
    }
  }
  if (__noteKey_isset) {
    if (__noteKey != nil) {
      [outProtocol writeFieldBeginWithName: @"noteKey" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __noteKey];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"authenticateToSharedNote_args("];
  [ms appendString: @"guid:"];
  [ms appendFormat: @"\"%@\"", __guid];
  [ms appendString: @",noteKey:"];
  [ms appendFormat: @"\"%@\"", __noteKey];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface EDAMAuthenticateToSharedNote_result : NSObject <NSCoding> {
  EDAMAuthenticationResult * __success;
  EDAMUserException * __userException;
  EDAMNotFoundException * __notFoundException;
  EDAMSystemException * __systemException;

  BOOL __success_isset;
  BOOL __userException_isset;
  BOOL __notFoundException_isset;
  BOOL __systemException_isset;
}

- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=success, setter=setSuccess:) EDAMAuthenticationResult * success;
@property (nonatomic, retain, getter=userException, setter=setUserException:) EDAMUserException * userException;
@property (nonatomic, retain, getter=notFoundException, setter=setNotFoundException:) EDAMNotFoundException * notFoundException;
@property (nonatomic, retain, getter=systemException, setter=setSystemException:) EDAMSystemException * systemException;
#else

- (EDAMAuthenticationResult *) success;
- (void) setSuccess: (EDAMAuthenticationResult *) success;

- (EDAMUserException *) userException;
- (void) setUserException: (EDAMUserException *) userException;

- (EDAMNotFoundException *) notFoundException;
- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException;

- (EDAMSystemException *) systemException;
- (void) setSystemException: (EDAMSystemException *) systemException;

#endif

- (BOOL) successIsSet;
- (BOOL) userExceptionIsSet;
- (BOOL) notFoundExceptionIsSet;
- (BOOL) systemExceptionIsSet;
@end

@implementation EDAMAuthenticateToSharedNote_result

- (id) initWithSuccess: (EDAMAuthenticationResult *) success userException: (EDAMUserException *) userException notFoundException: (EDAMNotFoundException *) notFoundException systemException: (EDAMSystemException *) systemException
{
  self = [super init];
  __success = [success retain];
  __success_isset = YES;
  __userException = [userException retain];
  __userException_isset = YES;
  __notFoundException = [notFoundException retain];
  __notFoundException_isset = YES;
  __systemException = [systemException retain];
  __systemException_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [[decoder decodeObjectForKey: @"success"] retain];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"userException"])
  {
    __userException = [[decoder decodeObjectForKey: @"userException"] retain];
    __userException_isset = YES;
  }
  if ([decoder containsValueForKey: @"notFoundException"])
  {
    __notFoundException = [[decoder decodeObjectForKey: @"notFoundException"] retain];
    __notFoundException_isset = YES;
  }
  if ([decoder containsValueForKey: @"systemException"])
  {
    __systemException = [[decoder decodeObjectForKey: @"systemException"] retain];
    __systemException_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeObject: __success forKey: @"success"];
  }
  if (__userException_isset)
  {
    [encoder encodeObject: __userException forKey: @"userException"];
  }
  if (__notFoundException_isset)
  {
    [encoder encodeObject: __notFoundException forKey: @"notFoundException"];
  }
  if (__systemException_isset)
  {
    [encoder encodeObject: __systemException forKey: @"systemException"];
  }
}

- (void) dealloc
{
  [__success release];
  [__userException release];
  [__notFoundException release];
  [__systemException release];
  [super dealloc];
}

- (EDAMAuthenticationResult *) success {
  return [[__success retain] autorelease];
}

- (void) setSuccess: (EDAMAuthenticationResult *) success {
  [success retain];
  [__success release];
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  [__success release];
  __success = nil;
  __success_isset = NO;
}

- (EDAMUserException *) userException {
  return [[__userException retain] autorelease];
}

- (void) setUserException: (EDAMUserException *) userException {
  [userException retain];
  [__userException release];
  __userException = userException;
  __userException_isset = YES;
}

- (BOOL) userExceptionIsSet {
  return __userException_isset;
}

- (void) unsetUserException {
  [__userException release];
  __userException = nil;
  __userException_isset = NO;
}

- (EDAMNotFoundException *) notFoundException {
  return [[__notFoundException retain] autorelease];
}

- (void) setNotFoundException: (EDAMNotFoundException *) notFoundException {
  [notFoundException retain];
  [__notFoundException release];
  __notFoundException = notFoundException;
  __notFoundException_isset = YES;
}

- (BOOL) notFoundExceptionIsSet {
  return __notFoundException_isset;
}

- (void) unsetNotFoundException {
  [__notFoundException release];
  __notFoundException = nil;
  __notFoundException_isset = NO;
}

- (EDAMSystemException *) systemException {
  return [[__systemException retain] autorelease];
}

- (void) setSystemException: (EDAMSystemException *) systemException {
  [systemException retain];
  [__systemException release];
  __systemException = systemException;
  __systemException_isset = YES;
}

- (BOOL) systemExceptionIsSet {
  return __systemException_isset;
}

- (void) unsetSystemException {
  [__systemException release];
  __systemException = nil;
  __systemException_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_STRUCT) {
          EDAMAuthenticationResult *fieldValue = [[EDAMAuthenticationResult alloc] init];
          [fieldValue read: inProtocol];
          [self setSuccess: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          EDAMUserException *fieldValue = [[EDAMUserException alloc] init];
          [fieldValue read: inProtocol];
          [self setUserException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRUCT) {
          EDAMNotFoundException *fieldValue = [[EDAMNotFoundException alloc] init];
          [fieldValue read: inProtocol];
          [self setNotFoundException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRUCT) {
          EDAMSystemException *fieldValue = [[EDAMSystemException alloc] init];
          [fieldValue read: inProtocol];
          [self setSystemException: fieldValue];
          [fieldValue release];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AuthenticateToSharedNote_result"];

  if (__success_isset) {
    if (__success != nil) {
      [outProtocol writeFieldBeginWithName: @"success" type: TType_STRUCT fieldID: 0];
      [__success write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__userException_isset) {
    if (__userException != nil) {
      [outProtocol writeFieldBeginWithName: @"userException" type: TType_STRUCT fieldID: 1];
      [__userException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__notFoundException_isset) {
    if (__notFoundException != nil) {
      [outProtocol writeFieldBeginWithName: @"notFoundException" type: TType_STRUCT fieldID: 2];
      [__notFoundException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  } else if (__systemException_isset) {
    if (__systemException != nil) {
      [outProtocol writeFieldBeginWithName: @"systemException" type: TType_STRUCT fieldID: 3];
      [__systemException write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AuthenticateToSharedNote_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%@", __success];
  [ms appendString: @",userException:"];
  [ms appendFormat: @"%@", __userException];
  [ms appendString: @",notFoundException:"];
  [ms appendFormat: @"%@", __notFoundException];
  [ms appendString: @",systemException:"];
  [ms appendFormat: @"%@", __systemException];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation EDAMNoteStoreClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  [super init];
  inProtocol = [anInProtocol retain];
  outProtocol = [anOutProtocol retain];
  return self;
}

- (void) dealloc
{
  [inProtocol release];
  [outProtocol release];
  [super dealloc];
}

- (void) send_getSyncState: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getSyncState" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSyncState_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncState *) recv_getSyncState
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSyncState_result * result = [[[EDAMGetSyncState_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSyncState failed: unknown result"];
}

- (EDAMSyncState *) getSyncState: (NSString *) authenticationToken
{
  [self send_getSyncState: authenticationToken];
  return [self recv_getSyncState];
}

- (void) send_getSyncChunk: (NSString *) authenticationToken : (int32_t) afterUSN : (int32_t) maxEntries : (BOOL) fullSyncOnly
{
  [outProtocol writeMessageBeginWithName: @"getSyncChunk" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSyncChunk_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: afterUSN];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: maxEntries];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: fullSyncOnly];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncChunk *) recv_getSyncChunk
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSyncChunk_result * result = [[[EDAMGetSyncChunk_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSyncChunk failed: unknown result"];
}

- (EDAMSyncChunk *) getSyncChunk: (NSString *) authenticationToken : (int32_t) afterUSN : (int32_t) maxEntries : (BOOL) fullSyncOnly
{
  [self send_getSyncChunk: authenticationToken : afterUSN : maxEntries : fullSyncOnly];
  return [self recv_getSyncChunk];
}

- (void) send_getFilteredSyncChunk: (NSString *) authenticationToken : (int32_t) afterUSN : (int32_t) maxEntries : (EDAMSyncChunkFilter *) filter
{
  [outProtocol writeMessageBeginWithName: @"getFilteredSyncChunk" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getFilteredSyncChunk_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 2];
  [outProtocol writeI32: afterUSN];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: maxEntries];
  [outProtocol writeFieldEnd];
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 4];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncChunk *) recv_getFilteredSyncChunk
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetFilteredSyncChunk_result * result = [[[EDAMGetFilteredSyncChunk_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getFilteredSyncChunk failed: unknown result"];
}

- (EDAMSyncChunk *) getFilteredSyncChunk: (NSString *) authenticationToken : (int32_t) afterUSN : (int32_t) maxEntries : (EDAMSyncChunkFilter *) filter
{
  [self send_getFilteredSyncChunk: authenticationToken : afterUSN : maxEntries : filter];
  return [self recv_getFilteredSyncChunk];
}

- (void) send_getLinkedNotebookSyncState: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [outProtocol writeMessageBeginWithName: @"getLinkedNotebookSyncState" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getLinkedNotebookSyncState_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncState *) recv_getLinkedNotebookSyncState
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetLinkedNotebookSyncState_result * result = [[[EDAMGetLinkedNotebookSyncState_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getLinkedNotebookSyncState failed: unknown result"];
}

- (EDAMSyncState *) getLinkedNotebookSyncState: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [self send_getLinkedNotebookSyncState: authenticationToken : linkedNotebook];
  return [self recv_getLinkedNotebookSyncState];
}

- (void) send_getLinkedNotebookSyncChunk: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook : (int32_t) afterUSN : (int32_t) maxEntries : (BOOL) fullSyncOnly
{
  [outProtocol writeMessageBeginWithName: @"getLinkedNotebookSyncChunk" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getLinkedNotebookSyncChunk_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"afterUSN" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: afterUSN];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxEntries" type: TType_I32 fieldID: 4];
  [outProtocol writeI32: maxEntries];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"fullSyncOnly" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: fullSyncOnly];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSyncChunk *) recv_getLinkedNotebookSyncChunk
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetLinkedNotebookSyncChunk_result * result = [[[EDAMGetLinkedNotebookSyncChunk_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getLinkedNotebookSyncChunk failed: unknown result"];
}

- (EDAMSyncChunk *) getLinkedNotebookSyncChunk: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook : (int32_t) afterUSN : (int32_t) maxEntries : (BOOL) fullSyncOnly
{
  [self send_getLinkedNotebookSyncChunk: authenticationToken : linkedNotebook : afterUSN : maxEntries : fullSyncOnly];
  return [self recv_getLinkedNotebookSyncChunk];
}

- (void) send_listNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListNotebooks_result * result = [[[EDAMListNotebooks_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listNotebooks failed: unknown result"];
}

- (NSArray *) listNotebooks: (NSString *) authenticationToken
{
  [self send_listNotebooks: authenticationToken];
  return [self recv_listNotebooks];
}

- (void) send_getNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNotebook_result * result = [[[EDAMGetNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNotebook failed: unknown result"];
}

- (EDAMNotebook *) getNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getNotebook: authenticationToken : guid];
  return [self recv_getNotebook];
}

- (void) send_getDefaultNotebook: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getDefaultNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getDefaultNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getDefaultNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetDefaultNotebook_result * result = [[[EDAMGetDefaultNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getDefaultNotebook failed: unknown result"];
}

- (EDAMNotebook *) getDefaultNotebook: (NSString *) authenticationToken
{
  [self send_getDefaultNotebook: authenticationToken];
  return [self recv_getDefaultNotebook];
}

- (void) send_createNotebook: (NSString *) authenticationToken : (EDAMNotebook *) notebook
{
  [outProtocol writeMessageBeginWithName: @"createNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
    [notebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_createNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateNotebook_result * result = [[[EDAMCreateNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createNotebook failed: unknown result"];
}

- (EDAMNotebook *) createNotebook: (NSString *) authenticationToken : (EDAMNotebook *) notebook
{
  [self send_createNotebook: authenticationToken : notebook];
  return [self recv_createNotebook];
}

- (void) send_updateNotebook: (NSString *) authenticationToken : (EDAMNotebook *) notebook
{
  [outProtocol writeMessageBeginWithName: @"updateNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebook" type: TType_STRUCT fieldID: 2];
    [notebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateNotebook_result * result = [[[EDAMUpdateNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateNotebook failed: unknown result"];
}

- (int32_t) updateNotebook: (NSString *) authenticationToken : (EDAMNotebook *) notebook
{
  [self send_updateNotebook: authenticationToken : notebook];
  return [self recv_updateNotebook];
}

- (void) send_expungeNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNotebook_result * result = [[[EDAMExpungeNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNotebook failed: unknown result"];
}

- (int32_t) expungeNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeNotebook: authenticationToken : guid];
  return [self recv_expungeNotebook];
}

- (void) send_listTags: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listTags" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listTags_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listTags
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListTags_result * result = [[[EDAMListTags_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listTags failed: unknown result"];
}

- (NSArray *) listTags: (NSString *) authenticationToken
{
  [self send_listTags: authenticationToken];
  return [self recv_listTags];
}

- (void) send_listTagsByNotebook: (NSString *) authenticationToken : (EDAMGuid) notebookGuid
{
  [outProtocol writeMessageBeginWithName: @"listTagsByNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listTagsByNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebookGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: notebookGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listTagsByNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListTagsByNotebook_result * result = [[[EDAMListTagsByNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listTagsByNotebook failed: unknown result"];
}

- (NSArray *) listTagsByNotebook: (NSString *) authenticationToken : (EDAMGuid) notebookGuid
{
  [self send_listTagsByNotebook: authenticationToken : notebookGuid];
  return [self recv_listTagsByNotebook];
}

- (void) send_getTag: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMTag *) recv_getTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetTag_result * result = [[[EDAMGetTag_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getTag failed: unknown result"];
}

- (EDAMTag *) getTag: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getTag: authenticationToken : guid];
  return [self recv_getTag];
}

- (void) send_createTag: (NSString *) authenticationToken : (EDAMTag *) tag
{
  [outProtocol writeMessageBeginWithName: @"createTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (tag != nil)  {
    [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
    [tag write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMTag *) recv_createTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateTag_result * result = [[[EDAMCreateTag_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createTag failed: unknown result"];
}

- (EDAMTag *) createTag: (NSString *) authenticationToken : (EDAMTag *) tag
{
  [self send_createTag: authenticationToken : tag];
  return [self recv_createTag];
}

- (void) send_updateTag: (NSString *) authenticationToken : (EDAMTag *) tag
{
  [outProtocol writeMessageBeginWithName: @"updateTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (tag != nil)  {
    [outProtocol writeFieldBeginWithName: @"tag" type: TType_STRUCT fieldID: 2];
    [tag write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateTag_result * result = [[[EDAMUpdateTag_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateTag failed: unknown result"];
}

- (int32_t) updateTag: (NSString *) authenticationToken : (EDAMTag *) tag
{
  [self send_updateTag: authenticationToken : tag];
  return [self recv_updateTag];
}

- (void) send_untagAll: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"untagAll" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"untagAll_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_untagAll
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUntagAll_result * result = [[[EDAMUntagAll_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  return;
}

- (void) untagAll: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_untagAll: authenticationToken : guid];
  [self recv_untagAll];
}

- (void) send_expungeTag: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeTag" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeTag_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeTag
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeTag_result * result = [[[EDAMExpungeTag_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeTag failed: unknown result"];
}

- (int32_t) expungeTag: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeTag: authenticationToken : guid];
  return [self recv_expungeTag];
}

- (void) send_listSearches: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listSearches" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listSearches_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listSearches
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListSearches_result * result = [[[EDAMListSearches_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listSearches failed: unknown result"];
}

- (NSArray *) listSearches: (NSString *) authenticationToken
{
  [self send_listSearches: authenticationToken];
  return [self recv_listSearches];
}

- (void) send_getSearch: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSavedSearch *) recv_getSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSearch_result * result = [[[EDAMGetSearch_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSearch failed: unknown result"];
}

- (EDAMSavedSearch *) getSearch: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getSearch: authenticationToken : guid];
  return [self recv_getSearch];
}

- (void) send_createSearch: (NSString *) authenticationToken : (EDAMSavedSearch *) search
{
  [outProtocol writeMessageBeginWithName: @"createSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (search != nil)  {
    [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
    [search write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSavedSearch *) recv_createSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateSearch_result * result = [[[EDAMCreateSearch_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createSearch failed: unknown result"];
}

- (EDAMSavedSearch *) createSearch: (NSString *) authenticationToken : (EDAMSavedSearch *) search
{
  [self send_createSearch: authenticationToken : search];
  return [self recv_createSearch];
}

- (void) send_updateSearch: (NSString *) authenticationToken : (EDAMSavedSearch *) search
{
  [outProtocol writeMessageBeginWithName: @"updateSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (search != nil)  {
    [outProtocol writeFieldBeginWithName: @"search" type: TType_STRUCT fieldID: 2];
    [search write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateSearch_result * result = [[[EDAMUpdateSearch_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateSearch failed: unknown result"];
}

- (int32_t) updateSearch: (NSString *) authenticationToken : (EDAMSavedSearch *) search
{
  [self send_updateSearch: authenticationToken : search];
  return [self recv_updateSearch];
}

- (void) send_expungeSearch: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeSearch" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeSearch_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeSearch
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeSearch_result * result = [[[EDAMExpungeSearch_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeSearch failed: unknown result"];
}

- (int32_t) expungeSearch: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeSearch: authenticationToken : guid];
  return [self recv_expungeSearch];
}

- (void) send_findNotes: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (int32_t) offset : (int32_t) maxNotes
{
  [outProtocol writeMessageBeginWithName: @"findNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: offset];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
  [outProtocol writeI32: maxNotes];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNoteList *) recv_findNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNotes_result * result = [[[EDAMFindNotes_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNotes failed: unknown result"];
}

- (EDAMNoteList *) findNotes: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (int32_t) offset : (int32_t) maxNotes
{
  [self send_findNotes: authenticationToken : filter : offset : maxNotes];
  return [self recv_findNotes];
}

- (void) send_findNoteOffset: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"findNoteOffset" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNoteOffset_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 3];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_findNoteOffset
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNoteOffset_result * result = [[[EDAMFindNoteOffset_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNoteOffset failed: unknown result"];
}

- (int32_t) findNoteOffset: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (EDAMGuid) guid
{
  [self send_findNoteOffset: authenticationToken : filter : guid];
  return [self recv_findNoteOffset];
}

- (void) send_findNotesMetadata: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (int32_t) offset : (int32_t) maxNotes : (EDAMNotesMetadataResultSpec *) resultSpec
{
  [outProtocol writeMessageBeginWithName: @"findNotesMetadata" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNotesMetadata_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"offset" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: offset];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"maxNotes" type: TType_I32 fieldID: 4];
  [outProtocol writeI32: maxNotes];
  [outProtocol writeFieldEnd];
  if (resultSpec != nil)  {
    [outProtocol writeFieldBeginWithName: @"resultSpec" type: TType_STRUCT fieldID: 5];
    [resultSpec write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotesMetadataList *) recv_findNotesMetadata
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNotesMetadata_result * result = [[[EDAMFindNotesMetadata_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNotesMetadata failed: unknown result"];
}

- (EDAMNotesMetadataList *) findNotesMetadata: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (int32_t) offset : (int32_t) maxNotes : (EDAMNotesMetadataResultSpec *) resultSpec
{
  [self send_findNotesMetadata: authenticationToken : filter : offset : maxNotes : resultSpec];
  return [self recv_findNotesMetadata];
}

- (void) send_findNoteCounts: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (BOOL) withTrash
{
  [outProtocol writeMessageBeginWithName: @"findNoteCounts" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"findNoteCounts_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (filter != nil)  {
    [outProtocol writeFieldBeginWithName: @"filter" type: TType_STRUCT fieldID: 2];
    [filter write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withTrash" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withTrash];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNoteCollectionCounts *) recv_findNoteCounts
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMFindNoteCounts_result * result = [[[EDAMFindNoteCounts_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"findNoteCounts failed: unknown result"];
}

- (EDAMNoteCollectionCounts *) findNoteCounts: (NSString *) authenticationToken : (EDAMNoteFilter *) filter : (BOOL) withTrash
{
  [self send_findNoteCounts: authenticationToken : filter : withTrash];
  return [self recv_findNoteCounts];
}

- (void) send_getNote: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) withContent : (BOOL) withResourcesData : (BOOL) withResourcesRecognition : (BOOL) withResourcesAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withContent" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withContent];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withResourcesData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withResourcesRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withResourcesAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_getNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNote_result * result = [[[EDAMGetNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNote failed: unknown result"];
}

- (EDAMNote *) getNote: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) withContent : (BOOL) withResourcesData : (BOOL) withResourcesRecognition : (BOOL) withResourcesAlternateData
{
  [self send_getNote: authenticationToken : guid : withContent : withResourcesData : withResourcesRecognition : withResourcesAlternateData];
  return [self recv_getNote];
}

- (void) send_getNoteApplicationData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteApplicationData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteApplicationData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMLazyMap *) recv_getNoteApplicationData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteApplicationData_result * result = [[[EDAMGetNoteApplicationData_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteApplicationData failed: unknown result"];
}

- (EDAMLazyMap *) getNoteApplicationData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getNoteApplicationData: authenticationToken : guid];
  return [self recv_getNoteApplicationData];
}

- (void) send_getNoteApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key
{
  [outProtocol writeMessageBeginWithName: @"getNoteApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNoteApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteApplicationDataEntry_result * result = [[[EDAMGetNoteApplicationDataEntry_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteApplicationDataEntry failed: unknown result"];
}

- (NSString *) getNoteApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key
{
  [self send_getNoteApplicationDataEntry: authenticationToken : guid : key];
  return [self recv_getNoteApplicationDataEntry];
}

- (void) send_setNoteApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key : (NSString *) value
{
  [outProtocol writeMessageBeginWithName: @"setNoteApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"setNoteApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  if (value != nil)  {
    [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
    [outProtocol writeString: value];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_setNoteApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMSetNoteApplicationDataEntry_result * result = [[[EDAMSetNoteApplicationDataEntry_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"setNoteApplicationDataEntry failed: unknown result"];
}

- (int32_t) setNoteApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key : (NSString *) value
{
  [self send_setNoteApplicationDataEntry: authenticationToken : guid : key : value];
  return [self recv_setNoteApplicationDataEntry];
}

- (void) send_unsetNoteApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key
{
  [outProtocol writeMessageBeginWithName: @"unsetNoteApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"unsetNoteApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_unsetNoteApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUnsetNoteApplicationDataEntry_result * result = [[[EDAMUnsetNoteApplicationDataEntry_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"unsetNoteApplicationDataEntry failed: unknown result"];
}

- (int32_t) unsetNoteApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key
{
  [self send_unsetNoteApplicationDataEntry: authenticationToken : guid : key];
  return [self recv_unsetNoteApplicationDataEntry];
}

- (void) send_getNoteContent: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteContent" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteContent_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNoteContent
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteContent_result * result = [[[EDAMGetNoteContent_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteContent failed: unknown result"];
}

- (NSString *) getNoteContent: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getNoteContent: authenticationToken : guid];
  return [self recv_getNoteContent];
}

- (void) send_getNoteSearchText: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) noteOnly : (BOOL) tokenizeForIndexing
{
  [outProtocol writeMessageBeginWithName: @"getNoteSearchText" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteSearchText_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"noteOnly" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: noteOnly];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"tokenizeForIndexing" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: tokenizeForIndexing];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getNoteSearchText
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteSearchText_result * result = [[[EDAMGetNoteSearchText_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteSearchText failed: unknown result"];
}

- (NSString *) getNoteSearchText: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) noteOnly : (BOOL) tokenizeForIndexing
{
  [self send_getNoteSearchText: authenticationToken : guid : noteOnly : tokenizeForIndexing];
  return [self recv_getNoteSearchText];
}

- (void) send_getResourceSearchText: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceSearchText" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceSearchText_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getResourceSearchText
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceSearchText_result * result = [[[EDAMGetResourceSearchText_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceSearchText failed: unknown result"];
}

- (NSString *) getResourceSearchText: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceSearchText: authenticationToken : guid];
  return [self recv_getResourceSearchText];
}

- (void) send_getNoteTagNames: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getNoteTagNames" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteTagNames_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_getNoteTagNames
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteTagNames_result * result = [[[EDAMGetNoteTagNames_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteTagNames failed: unknown result"];
}

- (NSArray *) getNoteTagNames: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getNoteTagNames: authenticationToken : guid];
  return [self recv_getNoteTagNames];
}

- (void) send_createNote: (NSString *) authenticationToken : (EDAMNote *) note
{
  [outProtocol writeMessageBeginWithName: @"createNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (note != nil)  {
    [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
    [note write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_createNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateNote_result * result = [[[EDAMCreateNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createNote failed: unknown result"];
}

- (EDAMNote *) createNote: (NSString *) authenticationToken : (EDAMNote *) note
{
  [self send_createNote: authenticationToken : note];
  return [self recv_createNote];
}

- (void) send_updateNote: (NSString *) authenticationToken : (EDAMNote *) note
{
  [outProtocol writeMessageBeginWithName: @"updateNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (note != nil)  {
    [outProtocol writeFieldBeginWithName: @"note" type: TType_STRUCT fieldID: 2];
    [note write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_updateNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateNote_result * result = [[[EDAMUpdateNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateNote failed: unknown result"];
}

- (EDAMNote *) updateNote: (NSString *) authenticationToken : (EDAMNote *) note
{
  [self send_updateNote: authenticationToken : note];
  return [self recv_updateNote];
}

- (void) send_deleteNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"deleteNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"deleteNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_deleteNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMDeleteNote_result * result = [[[EDAMDeleteNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"deleteNote failed: unknown result"];
}

- (int32_t) deleteNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_deleteNote: authenticationToken : guid];
  return [self recv_deleteNote];
}

- (void) send_expungeNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNote_result * result = [[[EDAMExpungeNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNote failed: unknown result"];
}

- (int32_t) expungeNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeNote: authenticationToken : guid];
  return [self recv_expungeNote];
}

- (void) send_expungeNotes: (NSString *) authenticationToken : (NSArray *) noteGuids
{
  [outProtocol writeMessageBeginWithName: @"expungeNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuids != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuids" type: TType_LIST fieldID: 2];
    {
      [outProtocol writeListBeginWithElementType: TType_STRING size: [noteGuids count]];
      int i189;
      for (i189 = 0; i189 < [noteGuids count]; i189++)
      {
        [outProtocol writeString: [noteGuids objectAtIndex: i189]];
      }
      [outProtocol writeListEnd];
    }
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeNotes_result * result = [[[EDAMExpungeNotes_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeNotes failed: unknown result"];
}

- (int32_t) expungeNotes: (NSString *) authenticationToken : (NSArray *) noteGuids
{
  [self send_expungeNotes: authenticationToken : noteGuids];
  return [self recv_expungeNotes];
}

- (void) send_expungeInactiveNotes: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"expungeInactiveNotes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeInactiveNotes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeInactiveNotes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeInactiveNotes_result * result = [[[EDAMExpungeInactiveNotes_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeInactiveNotes failed: unknown result"];
}

- (int32_t) expungeInactiveNotes: (NSString *) authenticationToken
{
  [self send_expungeInactiveNotes: authenticationToken];
  return [self recv_expungeInactiveNotes];
}

- (void) send_copyNote: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (EDAMGuid) toNotebookGuid
{
  [outProtocol writeMessageBeginWithName: @"copyNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"copyNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  if (toNotebookGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"toNotebookGuid" type: TType_STRING fieldID: 3];
    [outProtocol writeString: toNotebookGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_copyNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCopyNote_result * result = [[[EDAMCopyNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"copyNote failed: unknown result"];
}

- (EDAMNote *) copyNote: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (EDAMGuid) toNotebookGuid
{
  [self send_copyNote: authenticationToken : noteGuid : toNotebookGuid];
  return [self recv_copyNote];
}

- (void) send_listNoteVersions: (NSString *) authenticationToken : (EDAMGuid) noteGuid
{
  [outProtocol writeMessageBeginWithName: @"listNoteVersions" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listNoteVersions_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listNoteVersions
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListNoteVersions_result * result = [[[EDAMListNoteVersions_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listNoteVersions failed: unknown result"];
}

- (NSArray *) listNoteVersions: (NSString *) authenticationToken : (EDAMGuid) noteGuid
{
  [self send_listNoteVersions: authenticationToken : noteGuid];
  return [self recv_listNoteVersions];
}

- (void) send_getNoteVersion: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (int32_t) updateSequenceNum : (BOOL) withResourcesData : (BOOL) withResourcesRecognition : (BOOL) withResourcesAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getNoteVersion" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNoteVersion_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"updateSequenceNum" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: updateSequenceNum];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withResourcesData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withResourcesRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withResourcesAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withResourcesAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNote *) recv_getNoteVersion
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetNoteVersion_result * result = [[[EDAMGetNoteVersion_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getNoteVersion failed: unknown result"];
}

- (EDAMNote *) getNoteVersion: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (int32_t) updateSequenceNum : (BOOL) withResourcesData : (BOOL) withResourcesRecognition : (BOOL) withResourcesAlternateData
{
  [self send_getNoteVersion: authenticationToken : noteGuid : updateSequenceNum : withResourcesData : withResourcesRecognition : withResourcesAlternateData];
  return [self recv_getNoteVersion];
}

- (void) send_getResource: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) withData : (BOOL) withRecognition : (BOOL) withAttributes : (BOOL) withAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getResource" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResource_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 3];
  [outProtocol writeBool: withData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAttributes" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withAttributes];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResource *) recv_getResource
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResource_result * result = [[[EDAMGetResource_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResource failed: unknown result"];
}

- (EDAMResource *) getResource: (NSString *) authenticationToken : (EDAMGuid) guid : (BOOL) withData : (BOOL) withRecognition : (BOOL) withAttributes : (BOOL) withAlternateData
{
  [self send_getResource: authenticationToken : guid : withData : withRecognition : withAttributes : withAlternateData];
  return [self recv_getResource];
}

- (void) send_getResourceApplicationData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceApplicationData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceApplicationData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMLazyMap *) recv_getResourceApplicationData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceApplicationData_result * result = [[[EDAMGetResourceApplicationData_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceApplicationData failed: unknown result"];
}

- (EDAMLazyMap *) getResourceApplicationData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceApplicationData: authenticationToken : guid];
  return [self recv_getResourceApplicationData];
}

- (void) send_getResourceApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key
{
  [outProtocol writeMessageBeginWithName: @"getResourceApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_getResourceApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceApplicationDataEntry_result * result = [[[EDAMGetResourceApplicationDataEntry_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceApplicationDataEntry failed: unknown result"];
}

- (NSString *) getResourceApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key
{
  [self send_getResourceApplicationDataEntry: authenticationToken : guid : key];
  return [self recv_getResourceApplicationDataEntry];
}

- (void) send_setResourceApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key : (NSString *) value
{
  [outProtocol writeMessageBeginWithName: @"setResourceApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"setResourceApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  if (value != nil)  {
    [outProtocol writeFieldBeginWithName: @"value" type: TType_STRING fieldID: 4];
    [outProtocol writeString: value];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_setResourceApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMSetResourceApplicationDataEntry_result * result = [[[EDAMSetResourceApplicationDataEntry_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"setResourceApplicationDataEntry failed: unknown result"];
}

- (int32_t) setResourceApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key : (NSString *) value
{
  [self send_setResourceApplicationDataEntry: authenticationToken : guid : key : value];
  return [self recv_setResourceApplicationDataEntry];
}

- (void) send_unsetResourceApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key
{
  [outProtocol writeMessageBeginWithName: @"unsetResourceApplicationDataEntry" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"unsetResourceApplicationDataEntry_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (key != nil)  {
    [outProtocol writeFieldBeginWithName: @"key" type: TType_STRING fieldID: 3];
    [outProtocol writeString: key];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_unsetResourceApplicationDataEntry
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUnsetResourceApplicationDataEntry_result * result = [[[EDAMUnsetResourceApplicationDataEntry_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"unsetResourceApplicationDataEntry failed: unknown result"];
}

- (int32_t) unsetResourceApplicationDataEntry: (NSString *) authenticationToken : (EDAMGuid) guid : (NSString *) key
{
  [self send_unsetResourceApplicationDataEntry: authenticationToken : guid : key];
  return [self recv_unsetResourceApplicationDataEntry];
}

- (void) send_updateResource: (NSString *) authenticationToken : (EDAMResource *) resource
{
  [outProtocol writeMessageBeginWithName: @"updateResource" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateResource_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (resource != nil)  {
    [outProtocol writeFieldBeginWithName: @"resource" type: TType_STRUCT fieldID: 2];
    [resource write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateResource
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateResource_result * result = [[[EDAMUpdateResource_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateResource failed: unknown result"];
}

- (int32_t) updateResource: (NSString *) authenticationToken : (EDAMResource *) resource
{
  [self send_updateResource: authenticationToken : resource];
  return [self recv_updateResource];
}

- (void) send_getResourceData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceData_result * result = [[[EDAMGetResourceData_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceData failed: unknown result"];
}

- (NSData *) getResourceData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceData: authenticationToken : guid];
  return [self recv_getResourceData];
}

- (void) send_getResourceByHash: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (NSData *) contentHash : (BOOL) withData : (BOOL) withRecognition : (BOOL) withAlternateData
{
  [outProtocol writeMessageBeginWithName: @"getResourceByHash" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceByHash_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (noteGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteGuid];
    [outProtocol writeFieldEnd];
  }
  if (contentHash != nil)  {
    [outProtocol writeFieldBeginWithName: @"contentHash" type: TType_STRING fieldID: 3];
    [outProtocol writeBinary: contentHash];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"withData" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: withData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withRecognition" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: withRecognition];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"withAlternateData" type: TType_BOOL fieldID: 6];
  [outProtocol writeBool: withAlternateData];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResource *) recv_getResourceByHash
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceByHash_result * result = [[[EDAMGetResourceByHash_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceByHash failed: unknown result"];
}

- (EDAMResource *) getResourceByHash: (NSString *) authenticationToken : (EDAMGuid) noteGuid : (NSData *) contentHash : (BOOL) withData : (BOOL) withRecognition : (BOOL) withAlternateData
{
  [self send_getResourceByHash: authenticationToken : noteGuid : contentHash : withData : withRecognition : withAlternateData];
  return [self recv_getResourceByHash];
}

- (void) send_getResourceRecognition: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceRecognition" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceRecognition_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceRecognition
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceRecognition_result * result = [[[EDAMGetResourceRecognition_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceRecognition failed: unknown result"];
}

- (NSData *) getResourceRecognition: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceRecognition: authenticationToken : guid];
  return [self recv_getResourceRecognition];
}

- (void) send_getResourceAlternateData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceAlternateData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceAlternateData_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSData *) recv_getResourceAlternateData
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceAlternateData_result * result = [[[EDAMGetResourceAlternateData_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceAlternateData failed: unknown result"];
}

- (NSData *) getResourceAlternateData: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceAlternateData: authenticationToken : guid];
  return [self recv_getResourceAlternateData];
}

- (void) send_getResourceAttributes: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"getResourceAttributes" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getResourceAttributes_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMResourceAttributes *) recv_getResourceAttributes
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetResourceAttributes_result * result = [[[EDAMGetResourceAttributes_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getResourceAttributes failed: unknown result"];
}

- (EDAMResourceAttributes *) getResourceAttributes: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_getResourceAttributes: authenticationToken : guid];
  return [self recv_getResourceAttributes];
}

- (void) send_getAccountSize: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getAccountSize" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAccountSize_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int64_t) recv_getAccountSize
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetAccountSize_result * result = [[[EDAMGetAccountSize_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAccountSize failed: unknown result"];
}

- (int64_t) getAccountSize: (NSString *) authenticationToken
{
  [self send_getAccountSize: authenticationToken];
  return [self recv_getAccountSize];
}

- (void) send_getAds: (NSString *) authenticationToken : (EDAMAdParameters *) adParameters
{
  [outProtocol writeMessageBeginWithName: @"getAds" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getAds_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (adParameters != nil)  {
    [outProtocol writeFieldBeginWithName: @"adParameters" type: TType_STRUCT fieldID: 2];
    [adParameters write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_getAds
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetAds_result * result = [[[EDAMGetAds_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getAds failed: unknown result"];
}

- (NSArray *) getAds: (NSString *) authenticationToken : (EDAMAdParameters *) adParameters
{
  [self send_getAds: authenticationToken : adParameters];
  return [self recv_getAds];
}

- (void) send_getRandomAd: (NSString *) authenticationToken : (EDAMAdParameters *) adParameters
{
  [outProtocol writeMessageBeginWithName: @"getRandomAd" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getRandomAd_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (adParameters != nil)  {
    [outProtocol writeFieldBeginWithName: @"adParameters" type: TType_STRUCT fieldID: 2];
    [adParameters write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMAd *) recv_getRandomAd
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetRandomAd_result * result = [[[EDAMGetRandomAd_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getRandomAd failed: unknown result"];
}

- (EDAMAd *) getRandomAd: (NSString *) authenticationToken : (EDAMAdParameters *) adParameters
{
  [self send_getRandomAd: authenticationToken : adParameters];
  return [self recv_getRandomAd];
}

- (void) send_getPublicNotebook: (EDAMUserID) userId : (NSString *) publicUri
{
  [outProtocol writeMessageBeginWithName: @"getPublicNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getPublicNotebook_args"];
  [outProtocol writeFieldBeginWithName: @"userId" type: TType_I32 fieldID: 1];
  [outProtocol writeI32: userId];
  [outProtocol writeFieldEnd];
  if (publicUri != nil)  {
    [outProtocol writeFieldBeginWithName: @"publicUri" type: TType_STRING fieldID: 2];
    [outProtocol writeString: publicUri];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMNotebook *) recv_getPublicNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetPublicNotebook_result * result = [[[EDAMGetPublicNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getPublicNotebook failed: unknown result"];
}

- (EDAMNotebook *) getPublicNotebook: (EDAMUserID) userId : (NSString *) publicUri
{
  [self send_getPublicNotebook: userId : publicUri];
  return [self recv_getPublicNotebook];
}

- (void) send_createSharedNotebook: (NSString *) authenticationToken : (EDAMSharedNotebook *) sharedNotebook
{
  [outProtocol writeMessageBeginWithName: @"createSharedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createSharedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (sharedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"sharedNotebook" type: TType_STRUCT fieldID: 2];
    [sharedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSharedNotebook *) recv_createSharedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateSharedNotebook_result * result = [[[EDAMCreateSharedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createSharedNotebook failed: unknown result"];
}

- (EDAMSharedNotebook *) createSharedNotebook: (NSString *) authenticationToken : (EDAMSharedNotebook *) sharedNotebook
{
  [self send_createSharedNotebook: authenticationToken : sharedNotebook];
  return [self recv_createSharedNotebook];
}

- (void) send_sendMessageToSharedNotebookMembers: (NSString *) authenticationToken : (EDAMGuid) notebookGuid : (NSString *) messageText : (NSArray *) recipients
{
  [outProtocol writeMessageBeginWithName: @"sendMessageToSharedNotebookMembers" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"sendMessageToSharedNotebookMembers_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (notebookGuid != nil)  {
    [outProtocol writeFieldBeginWithName: @"notebookGuid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: notebookGuid];
    [outProtocol writeFieldEnd];
  }
  if (messageText != nil)  {
    [outProtocol writeFieldBeginWithName: @"messageText" type: TType_STRING fieldID: 3];
    [outProtocol writeString: messageText];
    [outProtocol writeFieldEnd];
  }
  if (recipients != nil)  {
    [outProtocol writeFieldBeginWithName: @"recipients" type: TType_LIST fieldID: 4];
    {
      [outProtocol writeListBeginWithElementType: TType_STRING size: [recipients count]];
      int i191;
      for (i191 = 0; i191 < [recipients count]; i191++)
      {
        [outProtocol writeString: [recipients objectAtIndex: i191]];
      }
      [outProtocol writeListEnd];
    }
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_sendMessageToSharedNotebookMembers
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMSendMessageToSharedNotebookMembers_result * result = [[[EDAMSendMessageToSharedNotebookMembers_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"sendMessageToSharedNotebookMembers failed: unknown result"];
}

- (int32_t) sendMessageToSharedNotebookMembers: (NSString *) authenticationToken : (EDAMGuid) notebookGuid : (NSString *) messageText : (NSArray *) recipients
{
  [self send_sendMessageToSharedNotebookMembers: authenticationToken : notebookGuid : messageText : recipients];
  return [self recv_sendMessageToSharedNotebookMembers];
}

- (void) send_listSharedNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listSharedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listSharedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listSharedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListSharedNotebooks_result * result = [[[EDAMListSharedNotebooks_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listSharedNotebooks failed: unknown result"];
}

- (NSArray *) listSharedNotebooks: (NSString *) authenticationToken
{
  [self send_listSharedNotebooks: authenticationToken];
  return [self recv_listSharedNotebooks];
}

- (void) send_expungeSharedNotebooks: (NSString *) authenticationToken : (NSArray *) sharedNotebookIds
{
  [outProtocol writeMessageBeginWithName: @"expungeSharedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeSharedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (sharedNotebookIds != nil)  {
    [outProtocol writeFieldBeginWithName: @"sharedNotebookIds" type: TType_LIST fieldID: 2];
    {
      [outProtocol writeListBeginWithElementType: TType_I64 size: [sharedNotebookIds count]];
      int i193;
      for (i193 = 0; i193 < [sharedNotebookIds count]; i193++)
      {
        [outProtocol writeI64: [[sharedNotebookIds objectAtIndex: i193] longLongValue]];
      }
      [outProtocol writeListEnd];
    }
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeSharedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeSharedNotebooks_result * result = [[[EDAMExpungeSharedNotebooks_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeSharedNotebooks failed: unknown result"];
}

- (int32_t) expungeSharedNotebooks: (NSString *) authenticationToken : (NSArray *) sharedNotebookIds
{
  [self send_expungeSharedNotebooks: authenticationToken : sharedNotebookIds];
  return [self recv_expungeSharedNotebooks];
}

- (void) send_createLinkedNotebook: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [outProtocol writeMessageBeginWithName: @"createLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"createLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMLinkedNotebook *) recv_createLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMCreateLinkedNotebook_result * result = [[[EDAMCreateLinkedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"createLinkedNotebook failed: unknown result"];
}

- (EDAMLinkedNotebook *) createLinkedNotebook: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [self send_createLinkedNotebook: authenticationToken : linkedNotebook];
  return [self recv_createLinkedNotebook];
}

- (void) send_updateLinkedNotebook: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [outProtocol writeMessageBeginWithName: @"updateLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"updateLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (linkedNotebook != nil)  {
    [outProtocol writeFieldBeginWithName: @"linkedNotebook" type: TType_STRUCT fieldID: 2];
    [linkedNotebook write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_updateLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMUpdateLinkedNotebook_result * result = [[[EDAMUpdateLinkedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"updateLinkedNotebook failed: unknown result"];
}

- (int32_t) updateLinkedNotebook: (NSString *) authenticationToken : (EDAMLinkedNotebook *) linkedNotebook
{
  [self send_updateLinkedNotebook: authenticationToken : linkedNotebook];
  return [self recv_updateLinkedNotebook];
}

- (void) send_listLinkedNotebooks: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"listLinkedNotebooks" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"listLinkedNotebooks_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSArray *) recv_listLinkedNotebooks
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMListLinkedNotebooks_result * result = [[[EDAMListLinkedNotebooks_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"listLinkedNotebooks failed: unknown result"];
}

- (NSArray *) listLinkedNotebooks: (NSString *) authenticationToken
{
  [self send_listLinkedNotebooks: authenticationToken];
  return [self recv_listLinkedNotebooks];
}

- (void) send_expungeLinkedNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"expungeLinkedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"expungeLinkedNotebook_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (int32_t) recv_expungeLinkedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMExpungeLinkedNotebook_result * result = [[[EDAMExpungeLinkedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"expungeLinkedNotebook failed: unknown result"];
}

- (int32_t) expungeLinkedNotebook: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_expungeLinkedNotebook: authenticationToken : guid];
  return [self recv_expungeLinkedNotebook];
}

- (void) send_authenticateToSharedNotebook: (NSString *) shareKey : (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNotebook" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNotebook_args"];
  if (shareKey != nil)  {
    [outProtocol writeFieldBeginWithName: @"shareKey" type: TType_STRING fieldID: 1];
    [outProtocol writeString: shareKey];
    [outProtocol writeFieldEnd];
  }
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 2];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMAuthenticationResult *) recv_authenticateToSharedNotebook
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMAuthenticateToSharedNotebook_result * result = [[[EDAMAuthenticateToSharedNotebook_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"authenticateToSharedNotebook failed: unknown result"];
}

- (EDAMAuthenticationResult *) authenticateToSharedNotebook: (NSString *) shareKey : (NSString *) authenticationToken
{
  [self send_authenticateToSharedNotebook: shareKey : authenticationToken];
  return [self recv_authenticateToSharedNotebook];
}

- (void) send_getSharedNotebookByAuth: (NSString *) authenticationToken
{
  [outProtocol writeMessageBeginWithName: @"getSharedNotebookByAuth" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getSharedNotebookByAuth_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMSharedNotebook *) recv_getSharedNotebookByAuth
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMGetSharedNotebookByAuth_result * result = [[[EDAMGetSharedNotebookByAuth_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"getSharedNotebookByAuth failed: unknown result"];
}

- (EDAMSharedNotebook *) getSharedNotebookByAuth: (NSString *) authenticationToken
{
  [self send_getSharedNotebookByAuth: authenticationToken];
  return [self recv_getSharedNotebookByAuth];
}

- (void) send_emailNote: (NSString *) authenticationToken : (EDAMNoteEmailParameters *) parameters
{
  [outProtocol writeMessageBeginWithName: @"emailNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"emailNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (parameters != nil)  {
    [outProtocol writeFieldBeginWithName: @"parameters" type: TType_STRUCT fieldID: 2];
    [parameters write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_emailNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMEmailNote_result * result = [[[EDAMEmailNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  return;
}

- (void) emailNote: (NSString *) authenticationToken : (EDAMNoteEmailParameters *) parameters
{
  [self send_emailNote: authenticationToken : parameters];
  [self recv_emailNote];
}

- (void) send_shareNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"shareNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"shareNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (NSString *) recv_shareNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMShareNote_result * result = [[[EDAMShareNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"shareNote failed: unknown result"];
}

- (NSString *) shareNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_shareNote: authenticationToken : guid];
  return [self recv_shareNote];
}

- (void) send_stopSharingNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [outProtocol writeMessageBeginWithName: @"stopSharingNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"stopSharingNote_args"];
  if (authenticationToken != nil)  {
    [outProtocol writeFieldBeginWithName: @"authenticationToken" type: TType_STRING fieldID: 1];
    [outProtocol writeString: authenticationToken];
    [outProtocol writeFieldEnd];
  }
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 2];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_stopSharingNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMStopSharingNote_result * result = [[[EDAMStopSharingNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  return;
}

- (void) stopSharingNote: (NSString *) authenticationToken : (EDAMGuid) guid
{
  [self send_stopSharingNote: authenticationToken : guid];
  [self recv_stopSharingNote];
}

- (void) send_authenticateToSharedNote: (NSString *) guid : (NSString *) noteKey
{
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNote" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"authenticateToSharedNote_args"];
  if (guid != nil)  {
    [outProtocol writeFieldBeginWithName: @"guid" type: TType_STRING fieldID: 1];
    [outProtocol writeString: guid];
    [outProtocol writeFieldEnd];
  }
  if (noteKey != nil)  {
    [outProtocol writeFieldBeginWithName: @"noteKey" type: TType_STRING fieldID: 2];
    [outProtocol writeString: noteKey];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (EDAMAuthenticationResult *) recv_authenticateToSharedNote
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  EDAMAuthenticateToSharedNote_result * result = [[[EDAMAuthenticateToSharedNote_result alloc] init] autorelease];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result userExceptionIsSet]) {
    @throw [result userException];
  }
  if ([result notFoundExceptionIsSet]) {
    @throw [result notFoundException];
  }
  if ([result systemExceptionIsSet]) {
    @throw [result systemException];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"authenticateToSharedNote failed: unknown result"];
}

- (EDAMAuthenticationResult *) authenticateToSharedNote: (NSString *) guid : (NSString *) noteKey
{
  [self send_authenticateToSharedNote: guid : noteKey];
  return [self recv_authenticateToSharedNote];
}

@end

@implementation EDAMNoteStoreProcessor

- (id) initWithNoteStore: (id <EDAMNoteStore>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain];
  mMethodMap = [[NSMutableDictionary dictionary] retain];
  {
    SEL s = @selector(process_getSyncState_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSyncState"];
  }
  {
    SEL s = @selector(process_getSyncChunk_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSyncChunk"];
  }
  {
    SEL s = @selector(process_getFilteredSyncChunk_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getFilteredSyncChunk"];
  }
  {
    SEL s = @selector(process_getLinkedNotebookSyncState_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getLinkedNotebookSyncState"];
  }
  {
    SEL s = @selector(process_getLinkedNotebookSyncChunk_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getLinkedNotebookSyncChunk"];
  }
  {
    SEL s = @selector(process_listNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listNotebooks"];
  }
  {
    SEL s = @selector(process_getNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNotebook"];
  }
  {
    SEL s = @selector(process_getDefaultNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getDefaultNotebook"];
  }
  {
    SEL s = @selector(process_createNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createNotebook"];
  }
  {
    SEL s = @selector(process_updateNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateNotebook"];
  }
  {
    SEL s = @selector(process_expungeNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNotebook"];
  }
  {
    SEL s = @selector(process_listTags_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listTags"];
  }
  {
    SEL s = @selector(process_listTagsByNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listTagsByNotebook"];
  }
  {
    SEL s = @selector(process_getTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getTag"];
  }
  {
    SEL s = @selector(process_createTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createTag"];
  }
  {
    SEL s = @selector(process_updateTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateTag"];
  }
  {
    SEL s = @selector(process_untagAll_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"untagAll"];
  }
  {
    SEL s = @selector(process_expungeTag_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeTag"];
  }
  {
    SEL s = @selector(process_listSearches_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listSearches"];
  }
  {
    SEL s = @selector(process_getSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSearch"];
  }
  {
    SEL s = @selector(process_createSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createSearch"];
  }
  {
    SEL s = @selector(process_updateSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateSearch"];
  }
  {
    SEL s = @selector(process_expungeSearch_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeSearch"];
  }
  {
    SEL s = @selector(process_findNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNotes"];
  }
  {
    SEL s = @selector(process_findNoteOffset_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNoteOffset"];
  }
  {
    SEL s = @selector(process_findNotesMetadata_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNotesMetadata"];
  }
  {
    SEL s = @selector(process_findNoteCounts_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"findNoteCounts"];
  }
  {
    SEL s = @selector(process_getNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNote"];
  }
  {
    SEL s = @selector(process_getNoteApplicationData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteApplicationData"];
  }
  {
    SEL s = @selector(process_getNoteApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_setNoteApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"setNoteApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_unsetNoteApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"unsetNoteApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_getNoteContent_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteContent"];
  }
  {
    SEL s = @selector(process_getNoteSearchText_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteSearchText"];
  }
  {
    SEL s = @selector(process_getResourceSearchText_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceSearchText"];
  }
  {
    SEL s = @selector(process_getNoteTagNames_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteTagNames"];
  }
  {
    SEL s = @selector(process_createNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createNote"];
  }
  {
    SEL s = @selector(process_updateNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateNote"];
  }
  {
    SEL s = @selector(process_deleteNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"deleteNote"];
  }
  {
    SEL s = @selector(process_expungeNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNote"];
  }
  {
    SEL s = @selector(process_expungeNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeNotes"];
  }
  {
    SEL s = @selector(process_expungeInactiveNotes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeInactiveNotes"];
  }
  {
    SEL s = @selector(process_copyNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"copyNote"];
  }
  {
    SEL s = @selector(process_listNoteVersions_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listNoteVersions"];
  }
  {
    SEL s = @selector(process_getNoteVersion_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNoteVersion"];
  }
  {
    SEL s = @selector(process_getResource_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResource"];
  }
  {
    SEL s = @selector(process_getResourceApplicationData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceApplicationData"];
  }
  {
    SEL s = @selector(process_getResourceApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_setResourceApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"setResourceApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_unsetResourceApplicationDataEntry_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"unsetResourceApplicationDataEntry"];
  }
  {
    SEL s = @selector(process_updateResource_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateResource"];
  }
  {
    SEL s = @selector(process_getResourceData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceData"];
  }
  {
    SEL s = @selector(process_getResourceByHash_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceByHash"];
  }
  {
    SEL s = @selector(process_getResourceRecognition_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceRecognition"];
  }
  {
    SEL s = @selector(process_getResourceAlternateData_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceAlternateData"];
  }
  {
    SEL s = @selector(process_getResourceAttributes_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getResourceAttributes"];
  }
  {
    SEL s = @selector(process_getAccountSize_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAccountSize"];
  }
  {
    SEL s = @selector(process_getAds_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getAds"];
  }
  {
    SEL s = @selector(process_getRandomAd_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getRandomAd"];
  }
  {
    SEL s = @selector(process_getPublicNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getPublicNotebook"];
  }
  {
    SEL s = @selector(process_createSharedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createSharedNotebook"];
  }
  {
    SEL s = @selector(process_sendMessageToSharedNotebookMembers_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"sendMessageToSharedNotebookMembers"];
  }
  {
    SEL s = @selector(process_listSharedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listSharedNotebooks"];
  }
  {
    SEL s = @selector(process_expungeSharedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeSharedNotebooks"];
  }
  {
    SEL s = @selector(process_createLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"createLinkedNotebook"];
  }
  {
    SEL s = @selector(process_updateLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"updateLinkedNotebook"];
  }
  {
    SEL s = @selector(process_listLinkedNotebooks_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"listLinkedNotebooks"];
  }
  {
    SEL s = @selector(process_expungeLinkedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"expungeLinkedNotebook"];
  }
  {
    SEL s = @selector(process_authenticateToSharedNotebook_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"authenticateToSharedNotebook"];
  }
  {
    SEL s = @selector(process_getSharedNotebookByAuth_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getSharedNotebookByAuth"];
  }
  {
    SEL s = @selector(process_emailNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"emailNote"];
  }
  {
    SEL s = @selector(process_shareNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"shareNote"];
  }
  {
    SEL s = @selector(process_stopSharingNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"stopSharingNote"];
  }
  {
    SEL s = @selector(process_authenticateToSharedNote_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"authenticateToSharedNote"];
  }
  return self;
}

- (id<EDAMNoteStore>) service
{
  return [[mService retain] autorelease];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_getSyncState_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSyncState_args * args = [[EDAMgetSyncState_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSyncState_result * result = [[EDAMGetSyncState_result alloc] init];
  [result setSuccess: [mService getSyncState: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getSyncState"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getSyncChunk_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSyncChunk_args * args = [[EDAMgetSyncChunk_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSyncChunk_result * result = [[EDAMGetSyncChunk_result alloc] init];
  [result setSuccess: [mService getSyncChunk: [args authenticationToken]: [args afterUSN]: [args maxEntries]: [args fullSyncOnly]]];
  [outProtocol writeMessageBeginWithName: @"getSyncChunk"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getFilteredSyncChunk_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetFilteredSyncChunk_args * args = [[EDAMgetFilteredSyncChunk_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetFilteredSyncChunk_result * result = [[EDAMGetFilteredSyncChunk_result alloc] init];
  [result setSuccess: [mService getFilteredSyncChunk: [args authenticationToken]: [args afterUSN]: [args maxEntries]: [args filter]]];
  [outProtocol writeMessageBeginWithName: @"getFilteredSyncChunk"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getLinkedNotebookSyncState_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetLinkedNotebookSyncState_args * args = [[EDAMgetLinkedNotebookSyncState_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetLinkedNotebookSyncState_result * result = [[EDAMGetLinkedNotebookSyncState_result alloc] init];
  [result setSuccess: [mService getLinkedNotebookSyncState: [args authenticationToken]: [args linkedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"getLinkedNotebookSyncState"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getLinkedNotebookSyncChunk_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetLinkedNotebookSyncChunk_args * args = [[EDAMgetLinkedNotebookSyncChunk_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetLinkedNotebookSyncChunk_result * result = [[EDAMGetLinkedNotebookSyncChunk_result alloc] init];
  [result setSuccess: [mService getLinkedNotebookSyncChunk: [args authenticationToken]: [args linkedNotebook]: [args afterUSN]: [args maxEntries]: [args fullSyncOnly]]];
  [outProtocol writeMessageBeginWithName: @"getLinkedNotebookSyncChunk"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistNotebooks_args * args = [[EDAMlistNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListNotebooks_result * result = [[EDAMListNotebooks_result alloc] init];
  [result setSuccess: [mService listNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNotebook_args * args = [[EDAMgetNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNotebook_result * result = [[EDAMGetNotebook_result alloc] init];
  [result setSuccess: [mService getNotebook: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getDefaultNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetDefaultNotebook_args * args = [[EDAMgetDefaultNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetDefaultNotebook_result * result = [[EDAMGetDefaultNotebook_result alloc] init];
  [result setSuccess: [mService getDefaultNotebook: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getDefaultNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateNotebook_args * args = [[EDAMcreateNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateNotebook_result * result = [[EDAMCreateNotebook_result alloc] init];
  [result setSuccess: [mService createNotebook: [args authenticationToken]: [args notebook]]];
  [outProtocol writeMessageBeginWithName: @"createNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateNotebook_args * args = [[EDAMupdateNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateNotebook_result * result = [[EDAMUpdateNotebook_result alloc] init];
  [result setSuccess: [mService updateNotebook: [args authenticationToken]: [args notebook]]];
  [outProtocol writeMessageBeginWithName: @"updateNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNotebook_args * args = [[EDAMexpungeNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNotebook_result * result = [[EDAMExpungeNotebook_result alloc] init];
  [result setSuccess: [mService expungeNotebook: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listTags_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistTags_args * args = [[EDAMlistTags_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListTags_result * result = [[EDAMListTags_result alloc] init];
  [result setSuccess: [mService listTags: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listTags"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listTagsByNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistTagsByNotebook_args * args = [[EDAMlistTagsByNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListTagsByNotebook_result * result = [[EDAMListTagsByNotebook_result alloc] init];
  [result setSuccess: [mService listTagsByNotebook: [args authenticationToken]: [args notebookGuid]]];
  [outProtocol writeMessageBeginWithName: @"listTagsByNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetTag_args * args = [[EDAMgetTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetTag_result * result = [[EDAMGetTag_result alloc] init];
  [result setSuccess: [mService getTag: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateTag_args * args = [[EDAMcreateTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateTag_result * result = [[EDAMCreateTag_result alloc] init];
  [result setSuccess: [mService createTag: [args authenticationToken]: [args tag]]];
  [outProtocol writeMessageBeginWithName: @"createTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateTag_args * args = [[EDAMupdateTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateTag_result * result = [[EDAMUpdateTag_result alloc] init];
  [result setSuccess: [mService updateTag: [args authenticationToken]: [args tag]]];
  [outProtocol writeMessageBeginWithName: @"updateTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_untagAll_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMuntagAll_args * args = [[EDAMuntagAll_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUntagAll_result * result = [[EDAMUntagAll_result alloc] init];
  [mService untagAll: [args authenticationToken]: [args guid]];
  [outProtocol writeMessageBeginWithName: @"untagAll"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeTag_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeTag_args * args = [[EDAMexpungeTag_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeTag_result * result = [[EDAMExpungeTag_result alloc] init];
  [result setSuccess: [mService expungeTag: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeTag"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listSearches_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistSearches_args * args = [[EDAMlistSearches_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListSearches_result * result = [[EDAMListSearches_result alloc] init];
  [result setSuccess: [mService listSearches: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listSearches"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSearch_args * args = [[EDAMgetSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSearch_result * result = [[EDAMGetSearch_result alloc] init];
  [result setSuccess: [mService getSearch: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateSearch_args * args = [[EDAMcreateSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateSearch_result * result = [[EDAMCreateSearch_result alloc] init];
  [result setSuccess: [mService createSearch: [args authenticationToken]: [args search]]];
  [outProtocol writeMessageBeginWithName: @"createSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateSearch_args * args = [[EDAMupdateSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateSearch_result * result = [[EDAMUpdateSearch_result alloc] init];
  [result setSuccess: [mService updateSearch: [args authenticationToken]: [args search]]];
  [outProtocol writeMessageBeginWithName: @"updateSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeSearch_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeSearch_args * args = [[EDAMexpungeSearch_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeSearch_result * result = [[EDAMExpungeSearch_result alloc] init];
  [result setSuccess: [mService expungeSearch: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeSearch"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_findNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNotes_args * args = [[EDAMfindNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNotes_result * result = [[EDAMFindNotes_result alloc] init];
  [result setSuccess: [mService findNotes: [args authenticationToken]: [args filter]: [args offset]: [args maxNotes]]];
  [outProtocol writeMessageBeginWithName: @"findNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_findNoteOffset_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNoteOffset_args * args = [[EDAMfindNoteOffset_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNoteOffset_result * result = [[EDAMFindNoteOffset_result alloc] init];
  [result setSuccess: [mService findNoteOffset: [args authenticationToken]: [args filter]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"findNoteOffset"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_findNotesMetadata_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNotesMetadata_args * args = [[EDAMfindNotesMetadata_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNotesMetadata_result * result = [[EDAMFindNotesMetadata_result alloc] init];
  [result setSuccess: [mService findNotesMetadata: [args authenticationToken]: [args filter]: [args offset]: [args maxNotes]: [args resultSpec]]];
  [outProtocol writeMessageBeginWithName: @"findNotesMetadata"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_findNoteCounts_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMfindNoteCounts_args * args = [[EDAMfindNoteCounts_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMFindNoteCounts_result * result = [[EDAMFindNoteCounts_result alloc] init];
  [result setSuccess: [mService findNoteCounts: [args authenticationToken]: [args filter]: [args withTrash]]];
  [outProtocol writeMessageBeginWithName: @"findNoteCounts"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNote_args * args = [[EDAMgetNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNote_result * result = [[EDAMGetNote_result alloc] init];
  [result setSuccess: [mService getNote: [args authenticationToken]: [args guid]: [args withContent]: [args withResourcesData]: [args withResourcesRecognition]: [args withResourcesAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteApplicationData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteApplicationData_args * args = [[EDAMgetNoteApplicationData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteApplicationData_result * result = [[EDAMGetNoteApplicationData_result alloc] init];
  [result setSuccess: [mService getNoteApplicationData: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteApplicationData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteApplicationDataEntry_args * args = [[EDAMgetNoteApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteApplicationDataEntry_result * result = [[EDAMGetNoteApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService getNoteApplicationDataEntry: [args authenticationToken]: [args guid]: [args key]]];
  [outProtocol writeMessageBeginWithName: @"getNoteApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_setNoteApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMsetNoteApplicationDataEntry_args * args = [[EDAMsetNoteApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMSetNoteApplicationDataEntry_result * result = [[EDAMSetNoteApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService setNoteApplicationDataEntry: [args authenticationToken]: [args guid]: [args key]: [args value]]];
  [outProtocol writeMessageBeginWithName: @"setNoteApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_unsetNoteApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMunsetNoteApplicationDataEntry_args * args = [[EDAMunsetNoteApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUnsetNoteApplicationDataEntry_result * result = [[EDAMUnsetNoteApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService unsetNoteApplicationDataEntry: [args authenticationToken]: [args guid]: [args key]]];
  [outProtocol writeMessageBeginWithName: @"unsetNoteApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteContent_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteContent_args * args = [[EDAMgetNoteContent_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteContent_result * result = [[EDAMGetNoteContent_result alloc] init];
  [result setSuccess: [mService getNoteContent: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteContent"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteSearchText_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteSearchText_args * args = [[EDAMgetNoteSearchText_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteSearchText_result * result = [[EDAMGetNoteSearchText_result alloc] init];
  [result setSuccess: [mService getNoteSearchText: [args authenticationToken]: [args guid]: [args noteOnly]: [args tokenizeForIndexing]]];
  [outProtocol writeMessageBeginWithName: @"getNoteSearchText"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceSearchText_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceSearchText_args * args = [[EDAMgetResourceSearchText_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceSearchText_result * result = [[EDAMGetResourceSearchText_result alloc] init];
  [result setSuccess: [mService getResourceSearchText: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceSearchText"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteTagNames_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteTagNames_args * args = [[EDAMgetNoteTagNames_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteTagNames_result * result = [[EDAMGetNoteTagNames_result alloc] init];
  [result setSuccess: [mService getNoteTagNames: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getNoteTagNames"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateNote_args * args = [[EDAMcreateNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateNote_result * result = [[EDAMCreateNote_result alloc] init];
  [result setSuccess: [mService createNote: [args authenticationToken]: [args note]]];
  [outProtocol writeMessageBeginWithName: @"createNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateNote_args * args = [[EDAMupdateNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateNote_result * result = [[EDAMUpdateNote_result alloc] init];
  [result setSuccess: [mService updateNote: [args authenticationToken]: [args note]]];
  [outProtocol writeMessageBeginWithName: @"updateNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_deleteNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMdeleteNote_args * args = [[EDAMdeleteNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMDeleteNote_result * result = [[EDAMDeleteNote_result alloc] init];
  [result setSuccess: [mService deleteNote: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"deleteNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNote_args * args = [[EDAMexpungeNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNote_result * result = [[EDAMExpungeNote_result alloc] init];
  [result setSuccess: [mService expungeNote: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeNotes_args * args = [[EDAMexpungeNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeNotes_result * result = [[EDAMExpungeNotes_result alloc] init];
  [result setSuccess: [mService expungeNotes: [args authenticationToken]: [args noteGuids]]];
  [outProtocol writeMessageBeginWithName: @"expungeNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeInactiveNotes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeInactiveNotes_args * args = [[EDAMexpungeInactiveNotes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeInactiveNotes_result * result = [[EDAMExpungeInactiveNotes_result alloc] init];
  [result setSuccess: [mService expungeInactiveNotes: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"expungeInactiveNotes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_copyNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcopyNote_args * args = [[EDAMcopyNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCopyNote_result * result = [[EDAMCopyNote_result alloc] init];
  [result setSuccess: [mService copyNote: [args authenticationToken]: [args noteGuid]: [args toNotebookGuid]]];
  [outProtocol writeMessageBeginWithName: @"copyNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listNoteVersions_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistNoteVersions_args * args = [[EDAMlistNoteVersions_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListNoteVersions_result * result = [[EDAMListNoteVersions_result alloc] init];
  [result setSuccess: [mService listNoteVersions: [args authenticationToken]: [args noteGuid]]];
  [outProtocol writeMessageBeginWithName: @"listNoteVersions"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getNoteVersion_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetNoteVersion_args * args = [[EDAMgetNoteVersion_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetNoteVersion_result * result = [[EDAMGetNoteVersion_result alloc] init];
  [result setSuccess: [mService getNoteVersion: [args authenticationToken]: [args noteGuid]: [args updateSequenceNum]: [args withResourcesData]: [args withResourcesRecognition]: [args withResourcesAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getNoteVersion"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResource_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResource_args * args = [[EDAMgetResource_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResource_result * result = [[EDAMGetResource_result alloc] init];
  [result setSuccess: [mService getResource: [args authenticationToken]: [args guid]: [args withData]: [args withRecognition]: [args withAttributes]: [args withAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getResource"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceApplicationData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceApplicationData_args * args = [[EDAMgetResourceApplicationData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceApplicationData_result * result = [[EDAMGetResourceApplicationData_result alloc] init];
  [result setSuccess: [mService getResourceApplicationData: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceApplicationData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceApplicationDataEntry_args * args = [[EDAMgetResourceApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceApplicationDataEntry_result * result = [[EDAMGetResourceApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService getResourceApplicationDataEntry: [args authenticationToken]: [args guid]: [args key]]];
  [outProtocol writeMessageBeginWithName: @"getResourceApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_setResourceApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMsetResourceApplicationDataEntry_args * args = [[EDAMsetResourceApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMSetResourceApplicationDataEntry_result * result = [[EDAMSetResourceApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService setResourceApplicationDataEntry: [args authenticationToken]: [args guid]: [args key]: [args value]]];
  [outProtocol writeMessageBeginWithName: @"setResourceApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_unsetResourceApplicationDataEntry_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMunsetResourceApplicationDataEntry_args * args = [[EDAMunsetResourceApplicationDataEntry_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUnsetResourceApplicationDataEntry_result * result = [[EDAMUnsetResourceApplicationDataEntry_result alloc] init];
  [result setSuccess: [mService unsetResourceApplicationDataEntry: [args authenticationToken]: [args guid]: [args key]]];
  [outProtocol writeMessageBeginWithName: @"unsetResourceApplicationDataEntry"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateResource_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateResource_args * args = [[EDAMupdateResource_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateResource_result * result = [[EDAMUpdateResource_result alloc] init];
  [result setSuccess: [mService updateResource: [args authenticationToken]: [args resource]]];
  [outProtocol writeMessageBeginWithName: @"updateResource"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceData_args * args = [[EDAMgetResourceData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceData_result * result = [[EDAMGetResourceData_result alloc] init];
  [result setSuccess: [mService getResourceData: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceByHash_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceByHash_args * args = [[EDAMgetResourceByHash_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceByHash_result * result = [[EDAMGetResourceByHash_result alloc] init];
  [result setSuccess: [mService getResourceByHash: [args authenticationToken]: [args noteGuid]: [args contentHash]: [args withData]: [args withRecognition]: [args withAlternateData]]];
  [outProtocol writeMessageBeginWithName: @"getResourceByHash"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceRecognition_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceRecognition_args * args = [[EDAMgetResourceRecognition_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceRecognition_result * result = [[EDAMGetResourceRecognition_result alloc] init];
  [result setSuccess: [mService getResourceRecognition: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceRecognition"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceAlternateData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceAlternateData_args * args = [[EDAMgetResourceAlternateData_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceAlternateData_result * result = [[EDAMGetResourceAlternateData_result alloc] init];
  [result setSuccess: [mService getResourceAlternateData: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceAlternateData"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getResourceAttributes_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetResourceAttributes_args * args = [[EDAMgetResourceAttributes_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetResourceAttributes_result * result = [[EDAMGetResourceAttributes_result alloc] init];
  [result setSuccess: [mService getResourceAttributes: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"getResourceAttributes"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getAccountSize_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetAccountSize_args * args = [[EDAMgetAccountSize_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetAccountSize_result * result = [[EDAMGetAccountSize_result alloc] init];
  [result setSuccess: [mService getAccountSize: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getAccountSize"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getAds_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetAds_args * args = [[EDAMgetAds_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetAds_result * result = [[EDAMGetAds_result alloc] init];
  [result setSuccess: [mService getAds: [args authenticationToken]: [args adParameters]]];
  [outProtocol writeMessageBeginWithName: @"getAds"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getRandomAd_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetRandomAd_args * args = [[EDAMgetRandomAd_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetRandomAd_result * result = [[EDAMGetRandomAd_result alloc] init];
  [result setSuccess: [mService getRandomAd: [args authenticationToken]: [args adParameters]]];
  [outProtocol writeMessageBeginWithName: @"getRandomAd"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getPublicNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetPublicNotebook_args * args = [[EDAMgetPublicNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetPublicNotebook_result * result = [[EDAMGetPublicNotebook_result alloc] init];
  [result setSuccess: [mService getPublicNotebook: [args userId]: [args publicUri]]];
  [outProtocol writeMessageBeginWithName: @"getPublicNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateSharedNotebook_args * args = [[EDAMcreateSharedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateSharedNotebook_result * result = [[EDAMCreateSharedNotebook_result alloc] init];
  [result setSuccess: [mService createSharedNotebook: [args authenticationToken]: [args sharedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"createSharedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_sendMessageToSharedNotebookMembers_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMsendMessageToSharedNotebookMembers_args * args = [[EDAMsendMessageToSharedNotebookMembers_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMSendMessageToSharedNotebookMembers_result * result = [[EDAMSendMessageToSharedNotebookMembers_result alloc] init];
  [result setSuccess: [mService sendMessageToSharedNotebookMembers: [args authenticationToken]: [args notebookGuid]: [args messageText]: [args recipients]]];
  [outProtocol writeMessageBeginWithName: @"sendMessageToSharedNotebookMembers"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listSharedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistSharedNotebooks_args * args = [[EDAMlistSharedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListSharedNotebooks_result * result = [[EDAMListSharedNotebooks_result alloc] init];
  [result setSuccess: [mService listSharedNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listSharedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeSharedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeSharedNotebooks_args * args = [[EDAMexpungeSharedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeSharedNotebooks_result * result = [[EDAMExpungeSharedNotebooks_result alloc] init];
  [result setSuccess: [mService expungeSharedNotebooks: [args authenticationToken]: [args sharedNotebookIds]]];
  [outProtocol writeMessageBeginWithName: @"expungeSharedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_createLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMcreateLinkedNotebook_args * args = [[EDAMcreateLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMCreateLinkedNotebook_result * result = [[EDAMCreateLinkedNotebook_result alloc] init];
  [result setSuccess: [mService createLinkedNotebook: [args authenticationToken]: [args linkedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"createLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_updateLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMupdateLinkedNotebook_args * args = [[EDAMupdateLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMUpdateLinkedNotebook_result * result = [[EDAMUpdateLinkedNotebook_result alloc] init];
  [result setSuccess: [mService updateLinkedNotebook: [args authenticationToken]: [args linkedNotebook]]];
  [outProtocol writeMessageBeginWithName: @"updateLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_listLinkedNotebooks_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMlistLinkedNotebooks_args * args = [[EDAMlistLinkedNotebooks_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMListLinkedNotebooks_result * result = [[EDAMListLinkedNotebooks_result alloc] init];
  [result setSuccess: [mService listLinkedNotebooks: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"listLinkedNotebooks"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_expungeLinkedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMexpungeLinkedNotebook_args * args = [[EDAMexpungeLinkedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMExpungeLinkedNotebook_result * result = [[EDAMExpungeLinkedNotebook_result alloc] init];
  [result setSuccess: [mService expungeLinkedNotebook: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"expungeLinkedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_authenticateToSharedNotebook_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMauthenticateToSharedNotebook_args * args = [[EDAMauthenticateToSharedNotebook_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMAuthenticateToSharedNotebook_result * result = [[EDAMAuthenticateToSharedNotebook_result alloc] init];
  [result setSuccess: [mService authenticateToSharedNotebook: [args shareKey]: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNotebook"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_getSharedNotebookByAuth_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMgetSharedNotebookByAuth_args * args = [[EDAMgetSharedNotebookByAuth_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMGetSharedNotebookByAuth_result * result = [[EDAMGetSharedNotebookByAuth_result alloc] init];
  [result setSuccess: [mService getSharedNotebookByAuth: [args authenticationToken]]];
  [outProtocol writeMessageBeginWithName: @"getSharedNotebookByAuth"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_emailNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMemailNote_args * args = [[EDAMemailNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMEmailNote_result * result = [[EDAMEmailNote_result alloc] init];
  [mService emailNote: [args authenticationToken]: [args parameters]];
  [outProtocol writeMessageBeginWithName: @"emailNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_shareNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMshareNote_args * args = [[EDAMshareNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMShareNote_result * result = [[EDAMShareNote_result alloc] init];
  [result setSuccess: [mService shareNote: [args authenticationToken]: [args guid]]];
  [outProtocol writeMessageBeginWithName: @"shareNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_stopSharingNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMstopSharingNote_args * args = [[EDAMstopSharingNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMStopSharingNote_result * result = [[EDAMStopSharingNote_result alloc] init];
  [mService stopSharingNote: [args authenticationToken]: [args guid]];
  [outProtocol writeMessageBeginWithName: @"stopSharingNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) process_authenticateToSharedNote_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  EDAMauthenticateToSharedNote_args * args = [[EDAMauthenticateToSharedNote_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  EDAMAuthenticateToSharedNote_result * result = [[EDAMAuthenticateToSharedNote_result alloc] init];
  [result setSuccess: [mService authenticateToSharedNote: [args guid]: [args noteKey]]];
  [outProtocol writeMessageBeginWithName: @"authenticateToSharedNote"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release];
  [args release];
}

- (void) dealloc
{
  [mService release];
  [mMethodMap release];
  [super dealloc];
}

@end

